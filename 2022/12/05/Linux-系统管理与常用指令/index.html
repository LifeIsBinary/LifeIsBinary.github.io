<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Linux 系统管理与常用指令 | Life Is Binary</title><meta name="keywords" content="效率,Linux"><meta name="author" content="Alfred"><meta name="copyright" content="Alfred"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="[toc] Linuxlinux的历史 unix  1970，贝尔实验室的工程师因开发的游戏无法继续在贝尔实验室的系统上继续使用，开发了unix来继续运行游戏 特点：  多任务、多用户 多用户：多个用户可以在同一时间使用同一个linux系统 多任务：Linux中可以同时运行多个程序，执行多个任务   有网络 并行处理，稳定性好 C编写，可移植性强   linux 1987，荷兰教授因unix系统版">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux 系统管理与常用指令">
<meta property="og:url" content="https://lifeisbinary.space/2022/12/05/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E4%B8%8E%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/index.html">
<meta property="og:site_name" content="Life Is Binary">
<meta property="og:description" content="[toc] Linuxlinux的历史 unix  1970，贝尔实验室的工程师因开发的游戏无法继续在贝尔实验室的系统上继续使用，开发了unix来继续运行游戏 特点：  多任务、多用户 多用户：多个用户可以在同一时间使用同一个linux系统 多任务：Linux中可以同时运行多个程序，执行多个任务   有网络 并行处理，稳定性好 C编写，可移植性强   linux 1987，荷兰教授因unix系统版">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20221205001616.png">
<meta property="article:published_time" content="2022-12-04T16:14:07.000Z">
<meta property="article:modified_time" content="2022-12-04T16:16:38.286Z">
<meta property="article:author" content="Alfred">
<meta property="article:tag" content="效率">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20221205001616.png"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/blogIcon.png"><link rel="canonical" href="https://lifeisbinary.space/2022/12/05/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E4%B8%8E%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="LSyTZ5bzZY2Vg6lZXS1Qa1008wPY9-QhDE67ar1Xqig"/><meta name="baidu-site-verification" content="code-p8ou8Pog9O"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'mediumZoom',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux 系统管理与常用指令',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-12-05 00:16:38'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/weiChatIcon.JPG" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">26</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章列表</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 全部标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 全部分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于本站</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20221205001616.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Life Is Binary</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章列表</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 全部标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 全部分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于本站</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Linux 系统管理与常用指令</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-12-04T16:14:07.000Z" title="发表于 2022-12-05 00:14:07">2022-12-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-04T16:16:38.286Z" title="更新于 2022-12-05 00:16:38">2022-12-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%94%B5%E8%84%91%E4%BD%BF%E7%94%A8tips/">电脑使用tips</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">20.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>64分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Linux 系统管理与常用指令"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>[toc]</p>
<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="linux的历史"><a href="#linux的历史" class="headerlink" title="linux的历史"></a>linux的历史</h2><ol>
<li><p>unix</p>
<p> 1970，贝尔实验室的工程师因开发的游戏无法继续在贝尔实验室的系统上继续使用，开发了unix来继续运行游戏</p>
<p>特点：</p>
<ul>
<li>多任务、多用户<ul>
<li>多用户：多个用户可以在同一时间使用同一个linux系统</li>
<li>多任务：Linux中可以同时运行多个程序，执行多个任务</li>
</ul>
</li>
<li>有网络</li>
<li>并行处理，稳定性好</li>
<li>C编写，可移植性强</li>
</ul>
</li>
<li><p>linux</p>
<p>1987，荷兰教授因unix系统版权被收回，讲操作系统原理课不方便。开发了minix。芬兰的linux在minix上增加功能，并与1991年将其上传到互联网成为linux（跟准确的说linux发布的是<strong>linux kernel</strong>）</p>
<p>特点：</p>
<ul>
<li>承袭unix的特点（多任务、多用户、网络、并行处理、稳定性和移植性好）</li>
<li>常用来搭建网络服务器，LAMP（linux + Apache + MySql + PHP） 和 LNMP （linux + Nginx+ MySql + PHP）就是使用极为普遍的web服务平台。</li>
<li>广泛应用于嵌入式系统。手机、机顶盒、路由器等。</li>
</ul>
</li>
</ol>
<h2 id="linux的内核——kernel"><a href="#linux的内核——kernel" class="headerlink" title="linux的内核——kernel"></a>linux的内核——kernel</h2><p>kernel：</p>
<p>​    完成操作系统<strong>最基本功能</strong>的程序。</p>
<p>​    运行在硬件之上，是所有应用程序运行的基础。是计算机硬件和用户之间的桥梁。通过它，我们才能让CPU处理各种数据，在硬盘中读写各种数据，与网络上的计算机进行通信</p>
<p>最基本的功能：</p>
<p>​    管理形形色色的硬件设备</p>
<p>​    提供用户操作界面</p>
<p>​    提供应用程序的运行环境    </p>
<p>linux = kernel + 应用程序（linux系统桌面也是应用程序）</p>
<h2 id="linux的发型版本"><a href="#linux的发型版本" class="headerlink" title="linux的发型版本"></a>linux的发型版本</h2><p>linux kernel 符号GUN协议，任何人可以免费使用，并修改。</p>
<ol>
<li><p>RedHat Linux</p>
<p>RHEL（企业付费版，提供技术支持和定制第三方软件）和 Fedora（免费版）</p>
</li>
<li><p>CentOS</p>
<p>在RHEL开放出的源代码基础上二次编译而成的linux系统，<strong>命令操作和服务配置方法与RHEL相同</strong>，去掉了RedHat的收费套件</p>
</li>
<li><p>Debian</p>
<p>以稳定著称的免费linux系统，有很多服务器采用Debian作为操作系统。</p>
<p>基于Debian二次开发出的有：Ubuntu 和 Kali Linux</p>
</li>
<li><p>SUSE</p>
<p>在欧洲流行的linux发行版，不适合初级用户。</p>
<p>有 企业版SUSE 和 openSUSE</p>
</li>
</ol>
<h2 id="VMware"><a href="#VMware" class="headerlink" title="VMware"></a>VMware</h2><h3 id="虚拟机的架构"><a href="#虚拟机的架构" class="headerlink" title="虚拟机的架构"></a>虚拟机的架构</h3><p>我们平时使用的虚拟机，是寄居架构（虚拟化软件在操作系统上安装）。企业使用的是裸金属架构（原生架构：在硬件上直接安装虚拟化软件），两者的性能有天壤之别。</p>
<h3 id="虚拟机的网络"><a href="#虚拟机的网络" class="headerlink" title="虚拟机的网络"></a>虚拟机的网络</h3><ol>
<li><p>桥接模式（bridged）</p>
<p>虚拟机类似一台物理机，可以访问外网，外网的计算机也可以访问该虚拟机。</p>
<p>将虚拟机的IP设置为与物理机的IP同一个网段，则虚拟机可以与该局域网中的物理机和其他主机通信。</p>
<p>桥接模式对应的虚拟网络名称：VMnet0</p>
<p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20221205000442.png" alt="image-20210430210749765"></p>
</li>
<li><p>仅主机模式（host-only）</p>
<p>虚拟机在一个独立的虚拟网络中，与物理网络之间是隔离的。所有仅主机模式的虚拟机之间以及虚拟机与物理机之间可以互相通信，但是它们与外部网络的主机无法通信。</p>
<p>仅主机模式对应的虚拟网络名称：VMnet1，物理主机要与仅主机模式下的虚拟机通信，需要保证VMnet1网卡的IP与虚拟机IP在同一网段。</p>
<p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20221205000450.png" alt="image-20210430211522637"></p>
</li>
<li><p>NAT模式（网络地址转换）</p>
<p>NAT模式对应的虚拟网络名称：VMnet8。</p>
<p>与仅主机模式类似，虚拟机也是处于与物理网络隔离的独立的网络中。但是此时，物理主机作为一个支持NAT功能的代理服务器，虚拟机可以作为客户端，通过物理主机的IP地址访问外部网络的计算机，但是由于NAT技术的特点，外部网络中的计算机无法主动与NAT模式下的虚拟机进行通信，只有虚拟机到外部网络计算机的单向通信。</p>
</li>
</ol>
<h2 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h2><p>shell也属于应用程序。</p>
<p>shell 就是 Command Line Interface。将用户的命令解释为系统内核可以理解的语言，内核执行以后，将结果以用户可以理解的方式显示出来。</p>
<p>![image-20210430212829106](/Users/lifeisbinary/Library/Application Support/typora-user-images/image-20210430212829106.png)</p>
<p>shell的实现有多种：sh、Csh、Zsh和Bash。CentOS默认使用Bash，这也是目前应用最为广泛的一种shell。</p>
<h3 id="命令提示符"><a href="#命令提示符" class="headerlink" title="命令提示符"></a>命令提示符</h3><p><code>[lifeisbinary@centos-linux ~]$</code>        【终端当前用户@主机名 当前所在目录】    $ ——普通用户； #——管理员</p>
<p>用户切换命令： <code>su - root</code>     实现不同权限的操作 </p>
<p>用户在本地所打开的终端称为虚拟终端TTY，用户在远程所打开的终端称为伪终端PTS。</p>
<h3 id="Shell的格式"><a href="#Shell的格式" class="headerlink" title="Shell的格式"></a>Shell的格式</h3><p><code>命令名 【选项】 【参数】</code></p>
<p>命令名：必不可少</p>
<p>选项：调节命令的具体功能，用“-”开头。选项即可以有一个，也可以有多个。 如 <code>ls -l -a</code> 与 <code>ls -la</code></p>
<p>​            部分选项以“–”开头， 如<code> ls --help</code></p>
<p>shell中，一行可以输入多条命令，命令之间用分号隔开。如果在一行命令后加上 “\”，可以进行换行</p>
<p>命令区分大小写</p>
<h3 id="关机和重启命令"><a href="#关机和重启命令" class="headerlink" title="关机和重启命令"></a>关机和重启命令</h3><p>单用户时使用，只保存当前用户的更改，其他用户的更改会丢失。</p>
<p><code>poweroff</code></p>
<p><code>reboot</code></p>
<p>多用户时使用，因为可以发送提示信息所以更加安全</p>
<p><code>shutdown -h now</code>     //立即关闭系统</p>
<p><code>shutdown -r now</code></p>
<p><code>shutdown -h +15</code>     //15min后重启</p>
<p><code>shutdown -h +15 ‘the system will be rebooted!!&#39;</code>     //    15min以后系统重启，并发送设定的信息给登陆到本机的各用户</p>
<p><code>Ifconfig 网卡名 IP地址</code>     //配置网卡的IP地址</p>
<blockquote>
<p>tip：如果两台主机之间网络通信出现问题，可以使用ping从一台主机去ping另一台，如果ping不通，可能是因为另一台主机开启了防火墙。可以通过另一台主机去pint当前这一台，来排出这种可能性。</p>
</blockquote>
<p>远程登录到linux，以前采用telnet，但该方式的数据以明文传输不安全。现在主要采用SSH，默认端口号TCP22</p>
<p>远程登录使用的工具： XShell、SecureCRT、PuTTY</p>
<h1 id="文件管理和目录管理"><a href="#文件管理和目录管理" class="headerlink" title="文件管理和目录管理"></a>文件管理和目录管理</h1><p>Linux中一切皆文件：数据、其他资源（包括硬件设备）以文件的形式组织起来。例如，硬盘以及硬盘中的每个分区在Linux中都被视为一个文件。用户可以像使用普通文件那样对设备进行操作。</p>
<p>Linux使用纯文本保存配置信息：无论是Linux系统本身还是应用程序，他们的配置信息往往都保存在一个纯文本的配置文件中。如果需要改动系统或者应用程序中的某项功能，那么只需要编辑相应的配置文件。</p>
<h3 id="目录管理"><a href="#目录管理" class="headerlink" title="目录管理"></a>目录管理</h3><p>Linux系统使用“/”进行分隔路径中目录的分隔（window使用“\”）</p>
<p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20221205000555.png" alt="image-20210501004927526"></p>
<blockquote>
<p>/mnt    一般是空的，用来临时挂载存储设备</p>
<p>/proc    存储系统内核和进程的相关信息</p>
<p>/run      存放进程产生的临时文件，系统重启后会消失</p>
<p>/lost+found   存放系统意外崩溃或者关机时产生的文件碎片</p>
</blockquote>
<p><code>pwd</code>         //打印当前目录</p>
<p><code>cd - </code>        //在最近工作过的两个目录之间切换</p>
<h4 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h4><p><code>ls</code>  or <code>ls 文件或目录名</code>             //目录内容列表展示，结果：蓝色——目录，灰色——通文件，绿色——可执行文件，红色——压缩文件，浅蓝色——链接文件</p>
<p><code>ls -a</code>      //显示所有文件，包含隐藏文件</p>
<p><code>ls -l</code>     //显示美国文件的详细信息<img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20221205000605.png" alt="image-20210501112709908"></p>
<ul>
<li><p>drwxr-xr-x: </p>
<ul>
<li>第一个字符：d——文件夹，- ——普通文件，l——链接文件，【<strong>硬件设备</strong> c——字符设备，b——块设备】</li>
<li>其余六个代表文件的权限</li>
</ul>
<blockquote>
<p>设备文件分为块设备和字符设备，块设备支持随机访问，而字符设备则只能线性访问。键盘是字符设备，硬盘是块设备。</p>
</blockquote>
</li>
<li><p>2： 被硬链接的次数，文件默认为1，目录默认为2。（linux中的链接文件类似于window中的快捷方式）</p>
</li>
<li><p>lifeisbinary： 文件的所有者</p>
</li>
<li><p>lifeisbinary:  文件所属的组</p>
</li>
<li><p>4096：文件的大小，对于目录只显示目录本身的大小，不显示目录所包含内容的大小</p>
</li>
<li><p>6月 12 2020：文件被创建或者最近一次修改的时间</p>
</li>
<li><p>Desktop：文件名</p>
</li>
</ul>
<p><code>ls -ld 目录</code> 显示目录本身的信息而不是，目录内部的信息</p>
<p><code>ls -lh  </code>  文件的容量用 KB、 MB、GB等单位显示</p>
<h4 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h4><p><code>touch newfile</code>         //创建新文件</p>
<h4 id="mkdir-和-rmdir"><a href="#mkdir-和-rmdir" class="headerlink" title="mkdir 和 rmdir"></a>mkdir 和 rmdir</h4><p><code>mkdir newDirectory</code>     //创建文件夹</p>
<p><code>mkdir a b c</code>            //创建多个文件夹</p>
<p><code>mkdir -p ~/newfilm/HKfilm</code>             //创建嵌套的多级目录结构</p>
<h4 id="cp、mv和rm"><a href="#cp、mv和rm" class="headerlink" title="cp、mv和rm"></a>cp、mv和rm</h4><p>cp 复制文件</p>
<p>​        <code>cp /etc/network.conf /home/ </code>             //复制到指定的文件夹</p>
<p>​        <code>cp /etc/network.conf /home/newnetwork.conf</code>              //复制到指定文件夹并重新命名</p>
<p>cp 复制文件夹</p>
<p>​        <code>cp -r /home/film/  /home/newfile/</code>              // -r 递归复制所有文件和目录</p>
<p>​        <code>cp -p</code>         // -p 在复制中保证文件和目录的属性（所有者和所属组）不发生变化</p>
<p>mv 移动文件或者重新命名</p>
<p><code>mv /home/film/china.txt /home/film/china/</code>     //移动文件</p>
<p><code>mv /home/film/china.txt /home/film/currentFilm.txt</code>   //文件重新命名</p>
<blockquote>
<p>mv 在移动文件夹时不需要添加像cp命令一样的-r选项，就可以直接移动文件夹</p>
</blockquote>
<p>rm 文件删除、目录删除</p>
<p><code>rm newfile.txt</code>    //文件删除</p>
<p><code>rm -f newfile.txt</code>    //文件删除，跳过询问确认</p>
<p><code>rm -rf film/</code>        //文件夹删除</p>
<blockquote>
<p>在生产环境中，为了安全起见一般不是使用 rm -rf。如果要删除某文件或者目录，使用mv将其移动到一个专门设置的回收目录，过一段时间之后，确认不再需要这些文件或目录，再用rm命令将其彻底删除。</p>
</blockquote>
<h4 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h4><p>通过特殊的符号，对多个文件进行批量的选择，并用shell命令处理</p>
<p><code>*</code>：匹配任意数量的任意字符</p>
<p>​    eg：<code>ls -d /etc/pa*</code>    //列出etc目录下所有以pa开头的目录或者文件</p>
<p>​            <code>rm -f /tmp/*.txt</code>    //删除/tmp目录下的所有txt文件</p>
<p><code>?</code>：配置任意单个字符</p>
<p>​    eg：<code>ls -lh /dev/sd?</code>    //列出/dev目录下所有以sd开头只有<strong>三个字符</strong>的文件信息</p>
<p><code>[]</code>：配置指定范围的任意单个字符</p>
<p>​    eg：<code>ls /dev/[df]??</code>    //    列出/dev目录下所有以“d“和”f“开头并且文件名为三的文件</p>
<p>​            <code>ls /dev/[a-c]*</code>    //    列出/dev目录下所有一个“a”、“b”和“c“开头的文件</p>
<p>​            <code>ls /dev/???[0-9]*</code>    //     列出/dev目录下文件名的第四个字符是数字的文件</p>
<p>​    在<code>[]</code>中还可以使用<code>!</code>指定不再选择范围的字符</p>
<p>​    eg：<code>ls /dev/[!fhi]*</code>    //    列出/dev目录下不以“f”、“h”和”i“开头的文件</p>
<h4 id="扩展符"><a href="#扩展符" class="headerlink" title="扩展符"></a>扩展符</h4><p><code>&#123;&#125;</code>中可以包含一个以逗号分隔的列表，并将其自动展开为多个路径或文件名。</p>
<p>eg：<code>mkdir /tmp/&#123;a,b,c&#125;</code>    //一次性创建/tmp/a、/tmp/b和/tmp/c三个目录</p>
<p>​        <code>touch /tmp/test&#123;1..10&#125;.txt</code>    //在/tmp目录下一次性创建 test1.txt , … , test10.txt共10个文件 </p>
<h3 id="文件内容操作"><a href="#文件内容操作" class="headerlink" title="文件内容操作"></a>文件内容操作</h3><h4 id="cat——小文件查看"><a href="#cat——小文件查看" class="headerlink" title="cat——小文件查看"></a>cat——小文件查看</h4><p><code>cat -n /etc/passwd</code>     //显示文本文件的内容，-n显示行号</p>
<blockquote>
<p>cat会一次显示完所有的文件内容，并且只保留最后一页在屏幕上，<strong>不方便查看长文件</strong>。</p>
</blockquote>
<h4 id="less-and-more-——长文件查看"><a href="#less-and-more-——长文件查看" class="headerlink" title="less and more ——长文件查看"></a>less and more ——长文件查看</h4><p><code>less -N /etc/passwd</code></p>
<p><code>more -N /etc/passwd</code></p>
<blockquote>
<p>less,more 命令适合与长文件阅读</p>
<p>less具有翻页功能,到文件末尾需要手动退出——适合查看长文件</p>
<p>more只能向后翻页，并且到文件末尾自动退出——与其他命令结合使用</p>
</blockquote>
<h4 id="tail-and-head-——-文件部分查看"><a href="#tail-and-head-——-文件部分查看" class="headerlink" title="tail and head —— 文件部分查看"></a>tail and head —— 文件部分查看</h4><p>head and tail 默认只显示10行内容</p>
<p><code>head -2 /etc/passwd</code>    //查看文件的前两行内容</p>
<p><code>tail -2 /etc/passwd</code>    //查看文件的后两行内容</p>
<p><code>tail -f /var/log/messages</code>    //查看系统公共日志文件messages的最后10行内容，并在末尾跟踪显示该文件中实时更新的内容。</p>
<blockquote>
<p>tail命令更多的被用于查看系统日志文件，以便观察相关的网络访问、服务调试信息。配合-f选项可以用于跟踪日志文件末尾的内容变化，实时显示更新的日志内容。</p>
</blockquote>
<h4 id="wc——文件内容统计"><a href="#wc——文件内容统计" class="headerlink" title="wc——文件内容统计"></a>wc——文件内容统计</h4><p><code>wc /etc/passwd</code>    //输出passwd文件的 行数、单词数、字节数</p>
<h4 id="echo——输出指定的内容"><a href="#echo——输出指定的内容" class="headerlink" title="echo——输出指定的内容"></a>echo——输出指定的内容</h4><p>输出字符串</p>
<p>​    <code>echo &quot;Hello world!&quot;</code></p>
<p>输出变量</p>
<p>​    <code>    echo $SHELL</code></p>
<p>​    <code>    echo $day</code>     //自定义变量 <code>day = &quot;&quot;Sunday</code>前提下</p>
<p>echo命令常与&gt;和&gt;&gt;重定向符结合，将内容保存或者追加到文件中</p>
<p><code>echo &#39;hello world&#39; &gt; test.txt</code>    //覆盖</p>
<p><code>echo &#39;good bye world&#39; &gt;&gt; test.txt </code>    //追加</p>
<blockquote>
<p>echo的输出会默认换行，添加 -n 后可以不产生换行效果</p>
</blockquote>
<h4 id="文件内容查找——grep"><a href="#文件内容查找——grep" class="headerlink" title="文件内容查找——grep"></a>文件内容查找——grep</h4><p>grep:    在文件中查找并显示指定字符串的所有行。</p>
<p><code>grep [选项] 查找条件 目标文件</code></p>
<p><code>grep &quot;root&quot; /etc/passwd</code>    //在/etc/passwd文件中查找包含“root”字符串的行</p>
<blockquote>
<p><strong>grep命令在设置查找条件时，不支持“ * ”和“  ？”等通配符，而是使用正则表达式设置条件。</strong></p>
</blockquote>
<p><code>grep &quot;^root&quot; /etc/passwd</code>    //查找以root开头的行</p>
<p><code>grep &quot;^$&quot; /etc/passwd</code>        //查找空白行</p>
<blockquote>
<p>-n：输出行的行号</p>
<p>-v：找出不符合查找条件的行</p>
<p>-i：查找条件不区分大小写</p>
<p>-w：精确匹配<strong>单词</strong>（含有这个单词的其他单词不会被显示）</p>
</blockquote>
<h4 id="文件内容对比——diff"><a href="#文件内容对比——diff" class="headerlink" title="文件内容对比——diff"></a>文件内容对比——diff</h4><p>diff命令用于比较多个文本文件之间的差异，这在系统安全防范中非常重要。例如，在黑客入侵系统后，往往会修改一些系统配置文件，从而留下“后门”。作为运维人员，最好事先将一些重要文件备份，然后定期执行diff命令进行对比，从而发现文件是否被改动过。</p>
<p>在进行如下操作后</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[lifeisbinary@centos-linux ~]$ cp .bashrc .bashrc.bak  #文件备份</span><br><span class="line">[lifeisbinary@centos-linux ~]$ echo &quot;cd /tmp&quot; &gt;&gt; .bashrc  #在.bashrc文件的末尾增加一行</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>进行比较<img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20221205000617.png" alt="image-20210505164955600"></p>
<p>12d11：</p>
<p>​    文件1(.bashrc)的第12行在文件2(.bashrc.bak)中被删除了（d代表删除）</p>
<p>&lt; cd /tmp</p>
<p>​    以&lt;开始的行属于文件1（.bashrc）,以&gt;开始的行属于文件2（.bashrc.bak）</p>
<p>​    cd /tmp 为被删除的行</p>
<p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20221205000622.png" alt="image-20210505165722660"></p>
<h3 id="时间和日期相关命令"><a href="#时间和日期相关命令" class="headerlink" title="时间和日期相关命令"></a>时间和日期相关命令</h3><h4 id="Date——打印、修改日期"><a href="#Date——打印、修改日期" class="headerlink" title="Date——打印、修改日期"></a>Date——打印、修改日期</h4><p><code>date</code>     //按照系统默认的格式显示日期和时间</p>
<p><code>date +%F</code>    //只显示日期</p>
<p><code>date +%T</code>    //只显示时间</p>
<p><code>date 050517002021</code>      //将当前日期修改为2021年5月5日17:00</p>
<h4 id="hwclock——显示或修改硬件时钟"><a href="#hwclock——显示或修改硬件时钟" class="headerlink" title="hwclock——显示或修改硬件时钟"></a>hwclock——显示或修改硬件时钟</h4><p>在linux系统中存在两套时钟系统：date命令查看的系统时间    和    记录计算机BIOS中的硬件时钟。两套时钟所显示的时间可能会不一致。</p>
<p>由于没次重启系统的时候，系统都会重新从BIOS中将时间读取出来，所以要修改日期和时间，单单执行date命令还不够，还必须再用hwclock命令来更新硬件时钟。</p>
<p>如果发现两者不一致:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hwclock -w <span class="comment">#将系统时钟写入硬件时钟</span></span><br><span class="line">hwclock -s <span class="comment">#将硬件时钟写入系统时钟</span></span><br></pre></td></tr></table></figure>



<h4 id="文件元数据查看——stat"><a href="#文件元数据查看——stat" class="headerlink" title="文件元数据查看——stat"></a>文件元数据查看——stat</h4><p>linux系统中文件包含两部分：</p>
<ul>
<li>文件内容（cat、more、less等查看的内容）</li>
<li>文件元数据，用于描述文件本身的属性，文件大小、存储位置、访问权限及时间戳等。</li>
</ul>
<p>查看 /etc/passwd的元数据：</p>
<p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20221205000627.png" alt="image-20210505172235873"></p>
<p><strong>最近更改时间</strong>指的是<strong>文件内容的变化</strong>，最近改动时间指的是文件元数据的变化。而内容的变化会引起文件大小的变化，即内容变化会导致文件最近更改时间和最近改动时间的同时变化。</p>
<p>文件元数据单个变化包括：权限修改操作、重新命名等。</p>
<blockquote>
<p>linux避免频繁对磁盘进行写入操作，一般文件的最近访问时间不会实时变化。</p>
</blockquote>
<h3 id="文件查找命令"><a href="#文件查找命令" class="headerlink" title="文件查找命令"></a>文件查找命令</h3><h4 id="简单快速查找——locate"><a href="#简单快速查找——locate" class="headerlink" title="简单快速查找——locate"></a>简单快速查找——locate</h4><p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20221205000645.png" alt="image-20210505172915923"></p>
<p>无需给定查找的起始路径，查找速度快。</p>
<p>locate只能实现模糊查找，如查找passwd文件，会出现很多结果。因为它会将所有的名字甚至路径中包含“passwd”的目录和文件全部查出来。</p>
<p>另外，它是基于实现构建的索引数据库，该数据库定期更新。因而lacate无法查找刚刚新建的文件。</p>
<h4 id="强大的文件查找命令——find"><a href="#强大的文件查找命令——find" class="headerlink" title="强大的文件查找命令——find"></a>强大的文件查找命令——find</h4><p>能够实现精确的查找</p>
<p><code>find [查找路径] [选项] [查找条件] [处理动作]</code></p>
<ul>
<li><p>查找条件：可以根据文件名、文件大小、文件类型、从属关系和权限等进行设置</p>
</li>
<li><p>处理动作：对查到的文件要执行的操作。如复制、删除等。</p>
</li>
</ul>
<h5 id="查找条件设置："><a href="#查找条件设置：" class="headerlink" title="查找条件设置："></a>查找条件设置：</h5><p>​        <code>find /etc -name &quot;net*.conf&quot;</code>     //按名称查找，允许使用通配符</p>
<p>​        <code>find /etc/ -iname &quot;*net*&quot;</code>        //按名称查找，不区分大小写</p>
<p>​        <code>find / -empty</code>            //查找空文件和空目录</p>
<p>​        </p>
<p>​        <code>find /etc -type l -ls </code>     //查找链接文件，并显示其详细信息</p>
<p>​        <code>find /etc -size +1M</code>    //查找大小在1M以上的文件</p>
<p>​        <code>find /etc -size -10K</code>    //查找大小在10K一下的文件</p>
<p>​        </p>
<p>​        <code>find /boot -not -type f -ls</code>     //查找所有文件类型不是普通文件的文件，并显示其详细信息</p>
<p>​        <code>find /tmp -atime +7 -type f</code>     //查找7天内没有被访问过的文件</p>
<p>​        <code>find /etc -mtime -1 -type f </code>    //查找最近一天之内被改动过的文件</p>
<p>​        <code>find /etc -cmin -180 -type f</code>     //查找最近3</p>
<p>小时内被修改过状态信息的文件</p>
<blockquote>
<p>-atime, -mtime , -ctime        —— 访问时间，更改时间，改动时间</p>
<p>-amin, -mmin, -cmin类似</p>
</blockquote>
<p>-exec ,对查到的结果进一步处理</p>
<p><code>find /boot -name &quot;init*&quot; -exec cp &#123;&#125; /tmp \</code></p>
<p>“{}”：表示find查询到的结果</p>
<p>“\“：命令结束的标志</p>
<p>同时指定多个查询条件</p>
<p><code>find /boot -size +1024K -name &quot;init*&quot;</code></p>
<h5 id="find的辅助命令——xargs"><a href="#find的辅助命令——xargs" class="headerlink" title="find的辅助命令——xargs"></a>find的辅助命令——xargs</h5><p>find查询后的结果可能很多，如果都送入exec的执行命令中，可能由于结果太多，命令无法处理这么多的参数。因此<strong>使用xargs分批将结果传给后续的命令进行处理</strong>。</p>
<p><code>find /tmp -name &quot;*.txt&quot; -exec cp &#123;&#125; /root \ </code></p>
<p><code>find /tmp -name &quot;*.txt&quot; | xargs -i cp &#123;&#125; /root</code></p>
<blockquote>
<p>如果 -exec命令不满足要求时，使用xargs命令。</p>
</blockquote>
<h3 id="linux内部命令和外部命令"><a href="#linux内部命令和外部命令" class="headerlink" title="linux内部命令和外部命令"></a>linux内部命令和外部命令</h3><p><strong>内部命令</strong>：集成在shell中的命令，只要shell被执行，内部命令就</p>
<p>自动载入内存，用户可以直接使用。</p>
<p><strong>外部命令</strong>：考虑到运行效率等原因，不可能把所有的命令都集成在Shell中，更多的linux命令是独立于Shell之外的，这些命令成为外部命令。</p>
<blockquote>
<p>使用<code>type 命令名</code>可以查看命令是外部命令还是内部命令</p>
</blockquote>
<p><strong>linux中的大部分命令属于外部命令，而每个外部命令都对应了系统中一个可以执行的二进制文件</strong>，这些二进制文件主要存放在下列目录中：</p>
<ul>
<li>普通命令： /bin,   /usr/bin 和 /usr/local/bin</li>
<li>管理员命令(root权限执行)： /sbin ,   /usr/sbin   和 usr/local/sbin</li>
</ul>
<blockquote>
<p>使用<code>which 命令名</code>可以查看外部命令对应的程序文件，which的搜索范围由环境变量PATH决定。</p>
</blockquote>
<p><strong>Linux系统默认将外部命令文件的存放路径保存在一个名为PATH的环境变量中。</strong></p>
<p>当用户输入命令并执行时，Shell首先会检查命令是否是内部命令，若不是，Shell就会从PATH变量所保存的这些路径中寻找命令所对应的程序文件。如果把一个外部命令对应的程序文件删除，或者存放外部命令程序文件的目录没有被添加到PATH变量中，这会导致外部命令无法正常执行。</p>
<p>Linux会将用户执行过的外部命令的程序文件路径缓存下来，这样再次执行时，就不需要去PATH中查找。使用<code>hash</code>命令可以查看当前Shell所缓存的命令程序文件路径。</p>
<h3 id="常用命令设置别名——alias"><a href="#常用命令设置别名——alias" class="headerlink" title="常用命令设置别名——alias"></a>常用命令设置别名——alias</h3><p><code>alias</code>    //查看当前系统中存在的别名</p>
<p><code>alias cpd=&#39;cat /etc/passwd&#39;</code>    //设置查看密码文件的命令别名</p>
<p><code>unalias cpd</code>    //删除别名</p>
<blockquote>
<p>注意：设置的别名只在当前Shell有效。      如果需要在每次用户登录后都有效，需要将该命令写入到配置文件中。</p>
<p>希望对所有用户有效，写入全局配置文件    /etc/bashrc </p>
<p>希望对指定用户有效，写入相应用户的家目录中 ~/.bashrc</p>
<p>修改完配置文件后，需要通过 source 配置文件，才能够立即生效</p>
</blockquote>
<h3 id="查看执行命令的历史记录——history"><a href="#查看执行命令的历史记录——history" class="headerlink" title="查看执行命令的历史记录——history"></a>查看执行命令的历史记录——history</h3><p><code>history 3</code>    //列出最近执行过的三条历史命令</p>
<p><code>history !16</code>    //把第16条历史命令重新执行一遍</p>
<p><code>history -d 16</code>    //删除第16条历史命令</p>
<p><code>history -c</code>    //删除缓存中的历史命令</p>
<h3 id="查看命令帮助信息——help"><a href="#查看命令帮助信息——help" class="headerlink" title="查看命令帮助信息——help"></a>查看命令帮助信息——help</h3><p>内部命令帮助信息查看——<code>help 命令名</code></p>
<p>外部命令帮助信息查看——<code>命令名 --help</code></p>
<blockquote>
<p>help查看的帮助信息较为简略，如果要查看更为详尽的帮助信息，可以使用<code>man 命令名</code>命令。</p>
<p>无论是外部命令还是内部命令，都可以使用man</p>
</blockquote>
<h3 id="清屏——clear"><a href="#清屏——clear" class="headerlink" title="清屏——clear"></a>清屏——clear</h3><p>快捷键——ctrl + L</p>
<h3 id="标准输入输出"><a href="#标准输入输出" class="headerlink" title="标准输入输出"></a>标准输入输出</h3><p>linux系统中一切皆文件，因此负责输入和输出的硬件设备也被视为系统中的一个文件。用户在通过操作biotin给处理信息的过程中，包含一下三类交互设备：</p>
<ul>
<li>标准输入（stdin）：默认是键盘，文件描述符为0。从标准输入文件中读取数据</li>
<li>标注输出（stdout)： 默认是显示器，文件描述符为1。输出数据到标准输出文件中。</li>
<li>标准错误（stderr）：默认是显示器，文件描述符为2。输出错误信息到标准错误文件中。</li>
</ul>
<p>一个linux程序通常从标准输入中得到输入数据，并将正常数据输出到标准输出，将错误信息输出到标准错误。</p>
<p>在某些情况，我们可能希望从键盘以外的其他设备读取数据，或者将数据送到显示器以外的其他输出设备，这种情况就成为<strong>重定向</strong>。</p>
<p>Shell中，输入重定向能够把文件导入命令中，输出重定向能够把原本输出到屏幕的信息写入指定文件中。</p>
<p>管道则为输入和输出重定向的结合，一个程序向管道的一端发送数据，而另一个程序从管道的另一端读取数据，即“把前一个命令原本要输出到屏幕的数据当作后一个命令的标准输入”。管道为不同命令的协同工作提供了一种机制。</p>
<h5 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h5><ol>
<li><p>标准输出重定向</p>
<p><code>cat /etc/passwd &gt; pass.txt</code>    //输出重定向 （覆盖）</p>
<p><code>tail -3 /etc/shadow &gt;&gt;pass.txt</code>    //输出重定向（追加）</p>
<p><code>cat 1.txt 2.txt &gt; 3.txt</code>    //两个文本合并到一个文本</p>
<p><code>cat 1.txt &gt; 2.txt</code>    //将文本的内容复制到另一个文本（覆盖）</p>
<p><code>cat 1.txt &gt; 2.txt</code>    //将文本的内容追加到另一个文本</p>
</li>
<li><p>标准输入重定向</p>
<p>将命令接受输入的途径从默认的键盘改为指定的文件</p>
<p><code>cat &gt;test.txt &lt;&lt;EOF</code>     //将一段连续输入的信息保存至指定文档。通过EOF结束连续的输入，结束标记必须要在最后一行的行首顶格书写。</p>
</li>
<li><p>标准错误重定向</p>
<p>将命令执行过程中的错误信息重定向并保存到指定的文件中</p>
<p><code>find / -user student 2&gt; find.txt</code>    //将错误信息保存到find文件中， “2&gt;”中，2是标准错误输出的文件描述符。</p>
<p><code>find / -user student &amp;&gt; find.txt</code>   //将程序运行的结果（正确执行的信息或错误信息）保存到find中 ，“&amp;&gt;”用来合并正常输出和错误输出。</p>
<p>linux系统中提供了一个特殊的设备文件/dev/null，被称为“黑洞”设备文件，进入该设备的数据将被“吞并”而丢失。</p>
<p>在有些命令执行过程中会产生一些错误信息，而我们不关心这些错误信息，只想看到正常执行的结果，可以通过标准错误重定向到/dev/null,来过滤这些错误信息。</p>
<p><code>find / -user student 2&gt; /dev/null</code>    //过滤错误信息</p>
<p><code>cat /dev/null &gt; test.txt</code>    //    利用黑洞设备文件清空一个文件内容</p>
</li>
<li><p>管道符 |</p>
<p>可以把多个命令连接起来实现复杂的功能</p>
<p>管道符左侧命令的结果将作为右侧命令的输入</p>
<p><code>ls -lh /etc | grep net</code>    列出/etc目录下包含net关键字的目录和文件</p>
<p><code>head /etc/passwd | tail -1</code>    从paawd文件中取出第10行</p>
</li>
</ol>
<h3 id="Vi文本编辑器"><a href="#Vi文本编辑器" class="headerlink" title="Vi文本编辑器"></a>Vi文本编辑器</h3><p>Visual Interface</p>
<p>vim是vi的增强版</p>
<p><code>vim [filename]</code></p>
<ol>
<li>vi编辑器的三种模式：<ul>
<li>命令模式：启动后默认进入命令模式，主要完成光标移动、字符串查找、删除、复制和粘贴等操作。<strong>无论用户处于何种模式，通过<ESC>键都可以进入命令模式</strong></li>
<li>插入模式：在命令模式下，输入 i可以切换到插入模式。该模式主要就是文本内容编辑，修改、删除或添加。<strong>处于插入模式时，vi编辑器的最后一行会出现“–INSERT–“的状态提示信息</strong>。</li>
<li> 末行模式：在命令模式下，输入：即可进入末行模式，可以保存文件、退出文件编辑，对文件内容进行查找、替换等。<strong>当处于末行模式时，vi编辑器的最后一行会显示：提示符</strong></li>
</ul>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20221205000759.png" alt="image-20210523174519623"></p>
<ol start="2">
<li><p>vi的常用命令</p>
<h6 id="命令模式下"><a href="#命令模式下" class="headerlink" title="命令模式下"></a>命令模式下</h6><ul>
<li><p>光标移动： </p>
<ul>
<li><p>翻页： Ctrl+F （向下翻页）     Ctrl+B（向上翻页）</p>
</li>
<li><p><strong>行内跳转</strong>：  </p>
<p> 0 或者 ^（跳转至行首）         $ (跳转至行尾)    </p>
<p> 6 右方向键 （向右移动6个字符） 6 左方向键 （向左移动6个字符）</p>
</li>
<li><p>行间跳转：</p>
<p>gg 跳转至首行            G跳转至尾行</p>
<p>6G 跳转至第6行</p>
</li>
<li><p>行号显示： :set nu(vi中显示行号)      :set none (vi中取消行号)</p>
</li>
</ul>
</li>
<li><p>复制、粘贴和删除</p>
<ul>
<li>x 删除光标处的单个字符       dd 删除光标所在的行</li>
<li>yy 复制当前光标所在行的内容  p 粘贴内容到光标所在行之后</li>
</ul>
</li>
<li><p>文件内容查找</p>
<ul>
<li>/xxx 自上而下查找字符串     ?xxx 自下而上查找字符串 （n 定位下一个搜索匹配的结果，N定位上一个搜索匹配的结果）</li>
</ul>
</li>
<li><p>撤销编辑： <strong>u 撤销最近的一次操作</strong>，默认情况最多可以撤销50次         Ctrl+R 恢复最近一次的操作</p>
</li>
</ul>
<h6 id="末行模式下"><a href="#末行模式下" class="headerlink" title="末行模式下"></a>末行模式下</h6><ul>
<li><p>保存文件：  :w保存          :w ~/Desktop/newfile 另存为其他文件</p>
</li>
<li><p>退出： :q未修改退出          :q! 放弃修改退出</p>
</li>
<li><p>保存并退出：     :wq</p>
</li>
<li><p>文件内容替换：     :% s/旧内容/新内容【/gc】 </p>
<p>g每行的所有匹配结果都替换，默认只替换每行匹配的第一个结果    c表示每次替换都进行询问</p>
</li>
</ul>
<h6 id="vi的可视模式"><a href="#vi的可视模式" class="headerlink" title="vi的可视模式"></a>vi的可视模式</h6><p>在命令模式下 ，v 进入按字符选定内容，y进行复制，d进行删除，p进行粘贴。可视模式提供了一种更加简便的对部分字符进行复制、删除等操作的处理方式。</p>
<blockquote>
<p>vi编辑器提供的官方联系教程，命令行输入 <code>vimtutor</code></p>
</blockquote>
</li>
</ol>
<h1 id="软件包管理"><a href="#软件包管理" class="headerlink" title="软件包管理"></a>软件包管理</h1><p>linux的软件安装主要分为:</p>
<ul>
<li><p>源码安装方式：</p>
<p><strong>困难且耗时的方式</strong>。在取得源码后，需要编译并解决软件依赖关系。在安装和卸载时，需要考虑软件与其他程序、库的依赖关系，操作难度较大。</p>
<p>源码安装的优势：</p>
<ul>
<li>可移植性好。可以安装到任何linux中使用，而RPM包只能用于某些Linux</li>
<li>可以灵活定制软件，运行效率高（编译过程可以更好的适应安装主机的系统环境，运行效率和优化程度强于使用RPM包安装）。</li>
<li>版本新。代码总是最先发布</li>
</ul>
</li>
<li><p>RPM安装方式：</p>
<p>源码安装方式复杂耗时，RedHat公司设计了一种软件包管理系统RPM（RedHat Packet Manager）。</p>
<p><strong>RPM是一种已经编译好并封装好的软件包</strong>（软件包中会封装程序、配置文件和帮助手册等），用户可以直接安装。RPM软件包是CentOS系统中软件的基本组成单位，每个软件都是由一个或多个RPM软件包组成。通过RPM，用户可以轻松的管理系统中的所有软件。</p>
<p>RPM软件包只能用于采用RPM机制的Linux系统上（RHEL、CentOS、Fedora、SUSE等）。RPM相较于其他的包管理机制，基本已经成为Linux系统中软件包管理事实上的标准。</p>
<p>RPM的一大<strong>缺点是：RPM软件包之间的依赖复杂</strong>。如安装A包需要B包的支持，而安装B包又需要C包的支持。因此，在安装A之前，必须先安装C，再安装B，最后才能安装A包。如此<strong>复杂的依赖关系都要由用户自行来解决。</strong></p>
</li>
<li><p>YUM安装方式：</p>
<p>YUM在RPM的基础上，解决了RPM软件包之间的依赖问题，从而更加轻松地管理Linux系统中的软件。</p>
<p>从RHEL 5时代起，RedHat就推荐使用YUM软件安装方式。</p>
</li>
</ul>
<p>linux上下载的软件安装包，一般都是 .gz、.tar.gz 和 .tgz之类的压缩文件，需要先进行解压缩。</p>
<h3 id="tar命令——文件打包和压缩"><a href="#tar命令——文件打包和压缩" class="headerlink" title="tar命令——文件打包和压缩"></a>tar命令——文件打包和压缩</h3><p>linux中打包和压缩是两个分开的操作。</p>
<p>打包命令：tar</p>
<p>压缩命令：gzip、bzip2、xz</p>
<p>通常先进行打包，后调用某种压缩工作进行压缩。如文件名后缀为 .tar.gz 、 .tgz的文件就属于这种先打包再压缩的文件。</p>
<blockquote>
<p>在实际使用中，一般通过tar命令来调用gzip进行压缩或解压，而很少单独使用这些压缩命令。</p>
</blockquote>
<ol>
<li>打包并压缩：</li>
</ol>
<p><code>tar -zcvf newfile.tar.gz  directory </code>  //将directory目录打包并压缩保存为newfile.tar.gz文件</p>
<ul>
<li>-c： 创建 .tar格式的文件，不会进行压缩</li>
<li>-v： 显示打包的过程</li>
<li>-f： 指定打包或者解包的文件名，必须在选型的最后一位</li>
<li>-z： 指定的压缩方式为gzip</li>
</ul>
<ol start="2">
<li><p>解包和解压缩</p>
<p><code>tar -xf【 压缩文件】 -C 【解压后的目录】</code></p>
<ul>
<li>-x： 解开tar格式的包文件</li>
<li>-f：指定解包的文件</li>
<li>-C：指定解压后文件存放的位置</li>
</ul>
<blockquote>
<p>此命令不需要指定调用那种压缩工作，系统会分析压缩文件的格式，自动调用相应的压缩工具进行解压。</p>
</blockquote>
</li>
</ol>
<h3 id="使用YUM进行软件安装"><a href="#使用YUM进行软件安装" class="headerlink" title="使用YUM进行软件安装"></a>使用YUM进行软件安装</h3><ol>
<li><p>配置yum源</p>
<p>yum源就是存放大量RPM软件包的远程仓库</p>
<p>yum源通过文件的方式来配置，存放在 /etc/yum.repos.d/目录中，以.repo为后坠</p>
<p>访问系统本身的默认yum源，比较慢。设置阿里云的yum源。</p>
<p>为了避免系统中同时存在多个yun源而造成混乱，先将系统默认的yum源文件全部删除。<code>rm -f /etc/yum.repos.d/*</code>。</p>
<p>然后从阿里云镜像网站下载yum配置文件，并将其存放到系统指定的目录。<code>wget http://mirros.aliyun.com/repo/Centos-7.repo -O /etc/yum.repos.d/Centos-7.repo</code></p>
<p>通过yum list 列出当前系统已经安装和未安装的软件包。名字前有@符号的是已经安装过的软件包。</p>
<p><code>yum list xxx</code>    查看yum源中是否有该软件包</p>
<p><code>yum repolist</code>    查看当前系统中可用的yun源，也可以用于检测yum源是否配置好</p>
</li>
<li><p>常用的yum命令</p>
<p><code>yum info xxx </code>: 查看软件包的信息（版本，软件功能）。如果软件包已经安装，则会显示已经安装的软件包。如果未安装，则会显示可安装的软件包。</p>
<p><code>yum install xxx</code> 安装软件包，安装过程中如果该软件包依赖的其他包未安装，则会询问用户是否安装该软件包需要的依赖包。</p>
<p><code>yum install xxx -y    </code> 当安装过程中进行询问时，自动确认</p>
<p><code>yum remove xxx</code>     卸载软件。<strong>yum remove在卸载一个软件时同时会将所有依赖于该软件的其他软件包一同卸载</strong>。例如，<code>yum remove cpp</code>，cpp是安装gcc时作为依赖包被一通安装的，因而在卸载cpp时会提示将要gcc也一同卸载。因为如果cpp被卸载了，那么gcc肯定也无法正常使用。但是这也就会导致新的问题出现，比如gcc又是别的软件的依赖包，那么将会导致这些软件也无法正常使用。因此，如果这些被一同卸载的软件正好是其他软件或者系统本身运行需要的，就容易造成问题甚至系统奔溃。<strong>因而在使用yum remove命令卸载软件时一定要慎重。</strong></p>
</li>
</ol>
<p>​        <code>yum clean all</code> 清除本地缓存，yum会自动创建本地缓存，一条yum执行效率。yum默认优先使用yun缓存来获取软件相关信息。如果发现yum运行不正常，也许就是由于yum缓存造成的。此时就需要清空yum缓存。</p>
<h3 id="yum故障排查"><a href="#yum故障排查" class="headerlink" title="yum故障排查"></a>yum故障排查</h3><ol>
<li>确认：yum源的定义文件是否存在错误</li>
<li>检查是否还有别的yum源定义文件，linux允许系统配置并启用多个yum源，但是必须要保证这些yum源都正确，如果其中一个出现错误，那么都会导致无法正常安装软件</li>
<li>yum clean all 清空缓存</li>
<li>yum list 检测是否能正确list出yum源中的软件包</li>
</ol>
<h3 id="RPM进行软件包管理"><a href="#RPM进行软件包管理" class="headerlink" title="RPM进行软件包管理"></a>RPM进行软件包管理</h3><p>rpm命令在linux中主要用于查询，查询软件是否安装、查询软件包信息</p>
<p>RPM机制封装的软件包拥有约定俗成的命令格式： 软件名称-版本号-发布号.硬件平台.rpm</p>
<p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20221205000900.png" alt="image-20210523231450303"></p>
<ul>
<li>发布号：RPM软件包是由CentOS组织封装的，因而软件包的发布号（RedHat更新）与软件版本号（开发者更新）是两回事。</li>
<li>硬件平台：<ul>
<li>x86_64： 64位PC架构</li>
<li>i386 / i686 : 32位PC架构</li>
<li>noarch: 不区分硬件架构</li>
</ul>
</li>
</ul>
<h6 id="安装-卸载软件"><a href="#安装-卸载软件" class="headerlink" title="安装/卸载软件"></a>安装/卸载软件</h6><p><code>rpm -ivh rpm包的路径</code>  安装软件包</p>
<ul>
<li>-i： 安装软件</li>
<li>-v： 显示安装过程</li>
<li>-h： 显示安装进度</li>
</ul>
<p><code>rpm -e xxx</code>  卸载软件包</p>
<h6 id="查询软件包"><a href="#查询软件包" class="headerlink" title="查询软件包"></a>查询软件包</h6><p><code>rpm -qa | grep ssh</code>  查看是否安装ssh</p>
<blockquote>
<p>ssh 不是软件的完成名称，因此才通过 rpm -qa列出所有已经安装的软件包，再通过内容查找其返回的结果</p>
<p>q: qurey</p>
</blockquote>
<p><code>rpm -qi xxx</code> 查询<strong>已安装的软件包</strong>的信息</p>
<p><code>rpm -ql xxx</code>    查看软件包在系统中安装的文件</p>
<p>一个典型的linux应用的组成：</p>
<ul>
<li>普通的可执行文件，保存在 /usr/bin，普通用户可执行</li>
<li>管理程序文件，保存在 /usr/sbin，管理员权限执行</li>
<li>配置文件，保存在 /etc下，配置文件较多时，会建立子目录</li>
<li>日志文件，保存在 /var/log</li>
<li>程序的参考文档，保存在 /usr/share/doc</li>
<li>可执行文件以及配置文件的man手册， 保存在 /usr/share/man</li>
</ul>
<p><code>rpm -gc xxx</code>    查看软件包安装的配置文件</p>
<p><code>rpm -qf 文件</code>    查询某个文件所属的软件包</p>
<p><code>which find</code> + <code>rpm -qf /usr/bin/find</code>  查询find命令来自哪个软件包，如果误删了find命令文件，可以通过安装该软件包进行修复</p>
<h3 id="利用源码编译安装软件"><a href="#利用源码编译安装软件" class="headerlink" title="利用源码编译安装软件"></a>利用源码编译安装软件</h3><p>源码安装需要<strong>主机具备编译环境</strong>，C语言是Linux的标准程序语言，常见的源码包一般是用C语言开发。常用的C语言编译器是GCC。</p>
<p>软件在编译或者执行期间，需要依赖其他的软件或者链接库。大部分软件开发者会在README或者INSTALL文件中告知需要准备哪些软件。</p>
<h6 id="源码安装的流程"><a href="#源码安装的流程" class="headerlink" title="源码安装的流程"></a>源码安装的流程</h6><p>解包—-配置—-编译—安装</p>
<p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20221205000909.png" alt="image-20210523235013026"></p>
<p>在生产环境中，将本地的软件包传到服务器中：</p>
<p>在linux服务器中安装lrzsz软件，在本地的XShell中执行rz命令，这时会打开一个Windows窗口，直接选择要上传的文件即可，文件默认会被上传到当前工作目录下。</p>
<h6 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h6><p>一般建议将各种软件的源码统一保存到 /usr/src/  /usr/local/src/ 或 /temp/目录中，以便于集中管理。</p>
<h6 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h6><p>编译软件前，必须先设置好编译的参数。配置工作通常由源码中的configure脚本来完成，具体的配置参数可以在源码目录中执行 ./configure –help 进行查看</p>
<p>配置中有一个 –prefix参数，指定软件包安装的目标目录。源码编译安装会将软件中所有文件安装到指定的目录<code>./configure --prefix=/usr/local/xxx</code>。这样将来卸载软件只需要安装目录删除，而无须担心误删其他软件。</p>
<p>配置结果会保存到源码目录中的makefile文件中</p>
<h6 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h6><p>编译的过程就是根据makefile文件中的配置信息，将源码编译并连接成可执行程序。</p>
<p><code>make</code></p>
<p><code>make test</code>对make的结果进行检查，保证没有错误de</p>
<h6 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h6><p><code>make install</code> 安装过程是将软件的执行文件、配置文件等相关文件复制到linux系统的相应位置。</p>
<p>安装完成后，进入安装目录下的bin/sbin目录中，执行相应的程序，就可以使用安装好的软件了。</p>
<h1 id="进程和服务管理"><a href="#进程和服务管理" class="headerlink" title="进程和服务管理"></a>进程和服务管理</h1><p>进程：系统中正在运行的程序。</p>
<p>服务：系统启动后<strong>自动在后台运行的程序</strong></p>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>在系统运维过程中经常设计对进程的管理操作。</p>
<p>进程是正在运行的程序，占用CPU和内存等资源。</p>
<p>进程是分配和调度操作系统资源的基本单位。</p>
<h6 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h6><p>进程在启动后不一定立马开始运行，因而进程存在多种状态 </p>
<ol>
<li>理论上进程的状态</li>
</ol>
<p><strong>运行态</strong>：值当前进行已经分配CPU，正在处理器上执行。运行态的进程不能超过cpu的数量。</p>
<p><strong>就绪态</strong>：已经具备运行的条件，但是当前的CPU被其他程序占用，等待分配CPU状态。</p>
<p><strong>阻塞态</strong>：进程因等待某种事情的发生（IO输入输出完成），而不能运行。即使CPU空闲，阻塞态的该进程也不能运行。当阻塞态进程等待的时间发生之后，就会进入就绪态。</p>
<p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20221205000924.png" alt="image-20210524151948444"></p>
<ol>
<li><p>Linux系统中进程的状态</p>
</li>
<li><p>可运行状态<strong>（R）</strong>： 该状态的进程，要么正在运行，要么正准备运行。理论上，运行态和就绪态的进程，在linux系统中都被视为可运行状态。</p>
</li>
<li><p>睡眠状态： 进程处于阻塞状态，一旦等待的事情完成，就会变为就绪态。</p>
<ul>
<li>可中断睡眠状态 <strong>（S）</strong></li>
<li><strong>不可中断</strong>睡眠状态<strong>（D）</strong>：处于该状态的进程对于中断信号不作出响应</li>
</ul>
</li>
<li><p>僵尸状态<strong>（Z）</strong>：进程执行结束，但是进程所占用的系统资源未释放。一般情况下，子进程由父进程结束，并释放其所占用的系统资源。当某个进程已经运行结束，但是它的父进程还没有释放其系统资源时，该进程就处于僵尸状态。</p>
</li>
<li><p>停止状态<strong>（T</strong>）: 进程暂停于内存中，不会被调度，等待某种特殊处理。</p>
</li>
</ol>
<h6 id="父进程和子进程"><a href="#父进程和子进程" class="headerlink" title="父进程和子进程"></a>父进程和子进程</h6><p><strong>除初始化进程systemd之外，Linux中的每个进程都必须由已经运行的进程来创建</strong>，这就就构成了父进程和子进程的关系。</p>
<p>systemd是Linux启动的第一个进程，系统中其他所有进程都是systemd进程的子进程。<strong>除了systemd之外，每一个进程都必须有一个父进程。</strong>父进程和子进程之间的关系是管理和被管理的关系。<strong>当父进程终止时，子进程也随之而终止</strong>，但子进程终止，父进程并不一定终止。</p>
<p>如果<strong>父进程在子进程结束之前就退出</strong>，那么它的子进程就变成了“孤儿”进程。如果没有相应的处理机制的话，“孤儿”<strong>进程就会一直处于僵尸状态</strong>，资源无法释放。<strong>此时解决的办法是在已启动的进程中寻找一个进程来作为这些“孤儿”进程的父进程，或者直接让systemd进程作为它们的父进程，进而释放“孤儿”进程占用的资源。</strong></p>
<h6 id="进程的属性"><a href="#进程的属性" class="headerlink" title="进程的属性"></a>进程的属性</h6><p>进程在启动后，系统会为每个进程分配一个唯一的进程标示符，称为进程ID（PID）</p>
<p><code>pidof sshd</code> 查看sshd进程的PID</p>
<p>除了systemd进程的PID固定为1，其他的进程的PID都是不固定的。当进程启动时，系统会自动为其分配一个PID，当进程结束时，系统会回收这个PID。</p>
<p>其他属性： </p>
<ul>
<li>父进程的ID （PPID）</li>
<li>启动进程的用户名 （UID）</li>
<li>进程的状态</li>
<li>进程的执行优先级</li>
<li>进程所在的终端名</li>
<li>进程占用的资源大小</li>
</ul>
<h6 id="进程的分类"><a href="#进程的分类" class="headerlink" title="进程的分类"></a>进程的分类</h6><p>系统进程： 能执行内存资源分配和进程切换工作，这些进程不受用户的干预，<strong>root用户也不能干预系统进程的运行</strong></p>
<p>用户进程： 执行应用程序或内核之外的系统程序而产生的进程。此类进程可以在用户的控制下运行或关闭。<strong>我们管理的主要是这类用户进程</strong>。用户进程又可以分为：守护进程和交互进程</p>
<ul>
<li>守护进程：<strong>由运行各种服务所产生的进程，一般在系统后台运行</strong>，而且通常会随Linux系统的启动而启动，在系统关闭的同时终止。守护进程始终是运行着的，一般其所处的状态是等待处理请求任务。例如，无乱是否有人访问Web服务器上的网页，该服务器上的httpd服务都是一直在运行。</li>
<li>交互进程：通过终端命令启动的进程，可以运行在前台也可以运行在后台。</li>
</ul>
<h6 id="进程状态查询——ps-（process-state）"><a href="#进程状态查询——ps-（process-state）" class="headerlink" title="进程状态查询——ps （process state）"></a>进程状态查询——ps （process state）</h6><p>ps  显示<strong>当前用户在当前终端</strong>所启动的进程</p>
<ul>
<li>TTY：为终端。每个终端都有相应的编号，tty 可以查看当前用户所在的终端。 <code>echo hello &gt; /dev/pts/5</code></li>
<li>TIME: 只进程占用额CPU时间，通常很小，显示为0</li>
</ul>
<p>ps aux</p>
<p>参数：</p>
<ul>
<li><p>a：显示与当前终端有关的所有进程，包括其他用户的进程</p>
</li>
<li><p>u：显示与当前终端无关的所有进程，a和u一起使用，显示系统中的所有进程。</p>
</li>
<li><p>x：以面向用户的格式显示进程信息</p>
</li>
</ul>
<p>执行结果：</p>
<ul>
<li>USER：启动该进程的用户。存在一些进程的启动者是专门的程序用户。</li>
<li>VSZ：进程占用的虚拟内存集的大小，单位是KB</li>
<li>RSS：进程常驻内存集的大小，单位是KB</li>
<li>TTY：启动进程的终端，<strong>如果显示？，表示该进程由系统内核启动，与终端无关。</strong></li>
<li>STAT：进程的状态。 有很多辅助表示进程状态的符号： + ——前台进程，l——多线程进程，N——低优先级进程，&lt;——高优先级进程，s——该进程是绘画领导者，如果这样的进程关闭，那么由该进程所派生出来的子进程也将被关闭。</li>
<li>TIME：进程从启动以来占用CPU的总时间</li>
<li>COMAMDN：启动该进程的命令。如果名称带有中括号，则表示该进程由系统内核启动</li>
</ul>
<p>因为ps aux 显示的内容多一般与more连用</p>
<p><code>ps -ef</code></p>
<ul>
<li>-e：显示系统中所有进程的信息</li>
<li>-f：显示进程的所有信息</li>
</ul>
<p>结果：</p>
<ul>
<li>C：进程所占用的CPU百分比</li>
</ul>
<blockquote>
<p>该命令，可以显示进程的父进程ID</p>
</blockquote>
<h6 id="top——查看进程的动态信息"><a href="#top——查看进程的动态信息" class="headerlink" title="top——查看进程的动态信息"></a>top——查看进程的动态信息</h6><p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20221205000945.png" alt="image-20210524170528539"></p>
<p>top命令结果：</p>
<p>第一行：系统时间，系统启动的时间，当前登录系统的用户个数，CPU的负载情况：过去1min，过去5min，过去15min</p>
<p>第二行：进程总数，各状态的进程数</p>
<p>第3～5：cpu的使用情况、内存使用情况，交换分区使用情况</p>
<blockquote>
<p>在top命令执行期间，可以对显示的结果进程排序。</p>
<p>P键——按占CPU的百分比排序（默认）</p>
<p>M键——按占内存的百分比排序</p>
<p>T键——按占用CPU的时间排序</p>
<p>N键——按进程启动时间排序</p>
</blockquote>
<h6 id="伪文件系统——-proc"><a href="#伪文件系统——-proc" class="headerlink" title="伪文件系统—— /proc"></a>伪文件系统—— /proc</h6><p>/proc被称为伪文件系统，因为该目录存放的并不是传统意义上的硬盘中的文件或目录，<strong>而是内存中正在运行的数据</strong>。</p>
<p>系统中所有进程的状态信息以文件的形式被存放在该目录中。</p>
<p>/proc目录中有很多以数字命令的目录,这些数字其实是进程PID，每个进程的信息都保存在对应的目录中。ps 和 top 命令都是从/proc目录获取进程的状态信息</p>
<h6 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h6><p>在shell命令行中执行某条命令，启动的进程默认情况下属于前台进程。执行过程中产生的相关信息会显示在终端上，进程执行过程中会占用当前终端，进程没结束，用户不能在当前终端执行其他操作。</p>
<p>在要执行的命令后面加上&amp;符号，则此进程转到当前终端后台运行。后台启动适合那些运行期间不需要用户干预或执行时间较长的程序。</p>
<p><code>jobs -l</code> // 查看当前终端中正在后台运行的进程任务</p>
<p>进程的前后台执行切换：</p>
<ol>
<li><p>后台进程切换到前台</p>
<p>fg(frontground)命令，将后台进程切换到前台</p>
<p><code>fg 1</code> 将任务编号为1的后台进程切换为前台执行</p>
</li>
<li><p>前台进程切换到后台</p>
<p>Ctrl + Z 切换到后台，进程处于停止状态</p>
<p>bg(background)命令，让后台挂起的进程继续执行</p>
</li>
</ol>
<p>通过shell运行的进程，无论是后台进程还是前台进程都与当前终端有关。如果关闭终端，那么该终端所有的进程也会关闭。这所以这样，是因为<strong>当前终端是所有其中运行的进程的父进程，它是一个回话的领导者，所以只要关闭它，终端中所有的子进程自然也会被关闭。</strong></p>
<p>通过nohop命令可以解除要执行的命令与当前终端之间的关系，使启动的进程为系统的后台进程。</p>
<p><code>nohop nc -lp 9527</code></p>
<h6 id="终止进程"><a href="#终止进程" class="headerlink" title="终止进程"></a>终止进程</h6><p>前台进程——Ctrl+C </p>
<p>后台进程——fg 切换到前台——Ctrl+C</p>
<p>其他终端或系统后台运行的进程——kill命令</p>
<p><strong>kill命令</strong>：</p>
<p>​    <code>kill PID</code></p>
<p>​    kill命令通过向进程发送终止信号使其退出运行。</p>
<p>​    kill可以发送的信号有多种，每个信号都有一个编号。其中默认使用的是15号信号SIGTERM。若进程已经无法响应终止信号，那么可以发送9号信号SIGKILL，强行将进程终止（<code>kill -9 PID</code>）。</p>
<p><strong>killall命令</strong>终止一组进程，通过程序的名字，直接结束所有进程。</p>
<p><code>killall sshd</code> 客户端与服务器之间的所有连接都将被断开。</p>
<h6 id="lsof（list-open-files）"><a href="#lsof（list-open-files）" class="headerlink" title="lsof（list open files）"></a>lsof（list open files）</h6><h6 id="查看当前系统文件的工具。在linux环境下，任何事物都以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。如传输控制协议-TCP-和用户数据报协议-UDP-套接字等，系统在后台都为该应用程序分配了一个文件描述符，该文件描述符提供了大量关于这个应用程序本身的信息。"><a href="#查看当前系统文件的工具。在linux环境下，任何事物都以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。如传输控制协议-TCP-和用户数据报协议-UDP-套接字等，系统在后台都为该应用程序分配了一个文件描述符，该文件描述符提供了大量关于这个应用程序本身的信息。" class="headerlink" title="查看当前系统文件的工具。在linux环境下，任何事物都以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。如传输控制协议 (TCP) 和用户数据报协议 (UDP) 套接字等，系统在后台都为该应用程序分配了一个文件描述符，该文件描述符提供了大量关于这个应用程序本身的信息。"></a>查看当前系统文件的工具。在linux环境下，任何事物都以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。如传输控制协议 (TCP) 和用户数据报协议 (UDP) 套接字等，系统在后台都为该应用程序分配了一个文件描述符，该文件描述符提供了大量关于这个应用程序本身的信息。</h6><p>lsof -i:端口号 //查看占用某端口的进程</p>
<h3 id="查看用户登录信息"><a href="#查看用户登录信息" class="headerlink" title="查看用户登录信息"></a>查看用户登录信息</h3><p>linux是一个多用户的操作系统，在同一时间可能会有多个用户同时登录使用系统，可以通过users、who或者w命令查看当前有哪些用户正在登录系统</p>
<p><code>users</code> //列出当前所有登录该系统的<strong>用户名</strong></p>
<p><code>who</code> //列出当前所有登录该系统的<strong>用户信息</strong>（用户名、终端、登录时间以及源IP地址）</p>
<p><code>w</code>  //who命令的增加版，除了who命令列出的信息，还可以列出用户正在执行的命令</p>
<p><code>last</code>   //查看系统的登录记录，哪些人以什么身份在什么终端上登录本机。<strong>由于last命令是通过查询日志文件来获取登录信息，而日志文件又容易被黑客篡改，因此不能单纯以该命令的输出信息来判断系统有无被恶意入侵</strong>。</p>
<h6 id="踢出可疑用户"><a href="#踢出可疑用户" class="headerlink" title="踢出可疑用户"></a>踢出可疑用户</h6><p>通过<code>who</code>查到用户的终端——通过<code>ps aux | grep pts/0</code>查到终端进程的PID——通过<code>kill -9 PID</code>强制终止该进程</p>
<h3 id="查看系统占用的资源情况"><a href="#查看系统占用的资源情况" class="headerlink" title="查看系统占用的资源情况"></a>查看系统占用的资源情况</h3><p><code>cat /proc/cpuinfo</code>    //查看系统CPU硬件信息</p>
<p><code>uptime</code>     //查看CPU使用情况, top命令的第一行信息</p>
<p><code>free -h -s 10</code>  //查看内存使用情况，-h：人性化显示内存容量单位，-s 动态刷新信息的时间频率，秒为单位 </p>
<blockquote>
<p>avilabel表示的系统可用内存大于free的值，是因为加入了buff/cache的部分可以回收的内存空间</p>
</blockquote>
<p><code>du -hs [directory]</code> //查看某个目录的大小</p>
<h3 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h3><h6 id="服务："><a href="#服务：" class="headerlink" title="服务："></a>服务：</h6><p>​        在系统后台运行，等待用户或其他软件调用的一类特殊程序。无论在哪个终端上运行服务，该服务所产生的进程都与终端无关，也就是说，将终端关闭之后，这些服务进程仍然会在系统后台自动运行。</p>
<p>​        Linux系统中服务名称的最后一般带有字母d，如vsftpd、httpd、sshd等，d是英文单词daemon的缩写，表示这是一种守护进程。</p>
<h6 id="系统初始化进程"><a href="#系统初始化进程" class="headerlink" title="系统初始化进程"></a>系统初始化进程</h6><p>​        初始化进程是Linux系统启动时第一个被执行的进程，它负责启动并管理其他各种服务，完成系统的初始化工作。</p>
<p>​        CentOS 7 的初始化进程是systemd。sytemd由系统自动在后台运行，所以也是一种典型的服务，一般也称systemd服务。systemd的PID永远为1。systemd进程启动后将陆续运行系统中的其他程序，不断生成新的进程。这些进程称为systemd的子进程，这些子进程可以进一步生成各自的子进程，最终构成一颗进程数。因此，<strong>systemd进程是维持整个Linux系统运行的所有进程的基础，该进程是不允许轻易终止的。</strong></p>
<p><code>pstree</code>    可以显示系统的进程数。</p>
<blockquote>
<p>在CentOS 7之前的版本中，采用的初始化进程是init，从CentOS 7开始采用systemd初始化进程。systemd相比于init的优势：</p>
<ol>
<li>开机速度变快。在系统开机的时候，systemd可以并发启动一些没有依赖的服务。不需要向init那样，让服务一个一个的排队，一个一个启动。</li>
<li>systemd提供按需启动服务的功能。在init初始化的时候，会将所有可能用到的服务全部启动起来，系统必须等待所有服务都启动就绪后，才允许用户登录。systemd只有在某个服务被真正请求的时候才启动它，当该服务结束时，可以动态关闭它，等待下次需要时才会再启动。</li>
</ol>
</blockquote>
<p>systemd中有一个核心的概念unit，systemd的系统管理功能主要就是通过各种unit来实现的。每中unit都有一个相应的配置文件对其进程标识和配置。这些配置文件主要存放在 /usr/lib/systemd/system/ 和 /etc/systemd/sytem/目录下。</p>
<ul>
<li>对服务进程管理的单元<strong>Service unit</strong>：以.service结尾。系统中每一种服务都会有一个与之对应的服务单元。</li>
<li>目标单元<strong>Target unit</strong>：以.target结尾。用于模拟实现系统运行级别。</li>
<li>设备单元<strong>Device unit</strong>：定义系统内核需要识别的设备</li>
<li>挂载单元<strong>Mount unit</strong>：定义文件系统的挂载点</li>
</ul>
<h6 id="使用systemctl命令管理服务"><a href="#使用systemctl命令管理服务" class="headerlink" title="使用systemctl命令管理服务"></a>使用systemctl命令管理服务</h6><p>Linux系统中提供了很多服务，从功能上可以分为：系统服务和网络服务。我们要管理的主要是网络服务（提供远程登录的sshd服务，提供网站浏览的httpd服务）。</p>
<blockquote>
<p>CentOS 5和CentOS 6系统中，对服务的管理主要是通过service和chkconfig命令完成，在CentOS 7中则主要是通过systemctl，systemctl是systemd提供的一个重要管理工具。</p>
</blockquote>
<p><code>systemctl start|stop|status|restart|reload 服务名</code></p>
<p>systemd将系统中的每个服务都看作一个服务单元（Service unit），在服务的名称后面加上.service作为后缀。在利用systemctl命令对服务进行管理时，服务名称后面加不加.service后缀均可。</p>
<p><code>system status xxx   </code></p>
<p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20221205000959.png" alt="image-20210528091402592"></p>
<p>结果解释：</p>
<p>第二行：表示服务已经被加载，该服务的Service unit配置文件位置，<strong>enabled表示服务已经被设为开机自动启动</strong>，vendor preset：enabled 表示该服务在系统中默认被预设为开机自动启动。</p>
<p><strong>在服务的配置管理中，如果修改了某项服务的设置，那么必须将服务重启，才能使得修改后的配置生效。</strong></p>
<p><code>systemctl restart xxx</code></p>
<blockquote>
<p>restart的重启方式会使服务产生暂时的中断，<strong>如果需要在不中断服务的前提下使得修改后的配置设置生效，需要使用reload方式重新加载服务。</strong>但对于某些服务配置所做的修改，必须重启才能生效，比如修改服务的端口号等网络配置，就无法通过reload方式重新加载。</p>
</blockquote>
<p><code>systemctl list-units --type service</code>  查看系统中所有正在运行的服务</p>
<p><code>systemctl list-units --type service --all</code> 列出系统中所有的服务</p>
<p><code>systemctl enable|disable|is-enabled 服务名</code></p>
<ul>
<li>enable 设置服务为开机自动启动</li>
<li>disable 表示禁止服务开机自动启动</li>
<li>is-enabled 查看服务的启动状态</li>
</ul>
<p><code>systemctl list-unit-files --type service</code> 查看系统中所有服务的开机启动状态</p>
<p>Linux上安装并使用一个服务的基本操作：</p>
<ol>
<li>查询系统中是否安装该服务 <code>rpm -qa | grep xxx</code></li>
<li>安装该服务 <code>yum install xxx -y</code></li>
<li>启动服务 <code>systemctl start xxx</code></li>
<li>设置开机自动启动 <code>systemctl enable xxx</code></li>
</ol>
<h6 id="管理系统的运行级别"><a href="#管理系统的运行级别" class="headerlink" title="管理系统的运行级别"></a>管理系统的运行级别</h6><p>Window中，正常启动模式和安全模式下，所能够运行的程序有所不同。正常模式下，所有被设为开机自动运行的服务或程序都会被自动启动，但如果进入安全模式，那么就只会启动系统基本的程序以及微软官方的服务。Linux中也有类似的机制，它将在系统运行时启动的各种程序服务互相组合以构成不同的搭配关系，满足不同的系统需求。这种搭配关系称为“运行级别”。总共有7种运行级别（0～6）。</p>
<p>不同的运行级别代表系统不同的运行状态，每种运行级别下所运行的服务或者程序会有所区别。</p>
<p>常用的运行级别时3和5，代表字符模式和图形模式。在选择相应的运行级别后，系统在启动时运行的服务就会有所区别。</p>
<p>将运行级别设置为3，系统启动时将会自动进入字符模式，所有与图像界面相关的服务都不会运行。</p>
<p>将系统级别设置为5，系统启动时会自动进入图形模式，自动运行与图形模式相关的服务。系统安装了图形界面，默认运行级别是5。</p>
<blockquote>
<p>在CentOS 5 和 CentOS 6系统中对运行级别进行管理，主要是借助runlevel 和 init 命令，CentOS 7也支持这两种命令。但是更加推荐使用systemctl命令。</p>
</blockquote>
<p><code>systemctl get-default</code>  查看系统的默认运行级别</p>
<p><code>runlevel</code> 查看系统的运行级别，结果会显示，上次切换前的系统（如果为N 表示之前未切换过运行级别）级别 和当前的系统级别</p>
<p><code>init 3</code>     切换到运行级别3模式，字符模式</p>
<p><code>init 0</code>    关闭系统</p>
<p><code>init 6</code>    重启系统</p>
<p>以上的方式切换系统级别只是临时的，当系统重启后，还是会进入默认的运行级别。</p>
<p><code>systemctl set-default multi-user.target</code>     //        设置系统的默认运行级别为3</p>
<p><code>systemctl set-default graphical.target</code>     //    设置系统默认运行级别为5</p>
<h6 id="重置root密码"><a href="#重置root密码" class="headerlink" title="重置root密码"></a>重置root密码</h6><p>Window系统重置管理员密码： </p>
<ol>
<li>用引导盘启动系统并进入WinPE</li>
<li>利用WinPE中提供的密码修改工具</li>
</ol>
<p>Linux系统：</p>
<p>CentOS 5 和 CentOS 6:</p>
<ol>
<li>启动系统进入单用户模式（运行级别1），此时无需密码即可以root身份登录系统</li>
<li>然后修改root用户密码</li>
</ol>
<p>CentOS 7:</p>
<pre><code>1. 进入救援模式，类似WinPE
2. 密码重置
</code></pre>
<blockquote>
<p>无论是单用户模式还是救援模式，都只能在系统本地登录才能使用，而无法通过网络远程操作，这样设计的目的很明显是处于安全的考虑。</p>
</blockquote>
<h6 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h6><p>计划任务可以让系统<strong>在指定的时间自动执行预先计划好的管理任务</strong>，因而计划任务是实现Linux系统自动化运维的重要途径。</p>
<p>通过计划任务来执行需要在指定时间或周期性执行的操作。</p>
<p>对于那些比较费时间而且占用资源较多的操作，可以通过设置计划任务，将它们安排在深夜由系统自动运行，从而避免影响正常服务的运行。</p>
<p>Linux系统听过两种计划任务：只会执行一次的at计划任务   和    可以周期执行的cron任务</p>
<ol>
<li><p>执行一次的at计划任务</p>
<p>在确认atd服务已经运行的情况下，<code>at 计划的时间</code>命令进入交互模式，一次输入准备执行的命令，最后按Ctrl+D保存。</p>
<p>计划时间的格式：</p>
<ul>
<li>HH:MM [YYYY-mm-dd]:  <code>at 10:05</code> 或 <code>at 10:05 2018-12-28</code></li>
<li>tomorrow: <code>at 10:05 tomorrow</code></li>
</ul>
<p>到时间后，系统会自动执行计划任务中的相关命令，并将执行结果以邮件的形式发送给用户。用户再此登录时，会看到友新邮件提示，执行mailx命令可以查看邮件。</p>
<p><code>at -l</code>     查看等待执行的计划任务</p>
<p><code>at -c 2</code>     查看编号为2的计划任务的具体内容</p>
<p><code>at -d 2</code>     删除编号为2的计划任务</p>
</li>
</ol>
<blockquote>
<p>通过非交互方式创建计划任务，<code>echo &#39;systemctl restart http&#39; | at 23:00</code></p>
</blockquote>
<ol start="2">
<li><p>配置cron周期性计划任务</p>
<p>更多情况下，我们可能需要周期性地执行某项操作，比如每天凌晨2:00自动将/etc目录进行打包备份。</p>
<p>crontab命令用来设置用户的周期性计划，执行该命令会生成一个以用户名命名的配置文件，存放在/var/spool/cron目录中。</p>
<p><code>crontab -e</code>    编辑计划任务列表，打开一个任务编辑的界面。每一行代表一个记录，每个记录包括六个字段。</p>
<p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20221205001046.png" alt="image-20210528111637394"></p>
</li>
</ol>
<p>在时间周期设置中，没有设置的位置要用*号占位。</p>
<p>在配置计划任务时，命令建议使用绝对路径，因为当前系统执行计划任务中的操作时，无法获取环境变量PATH中保存的路径。关于命令的绝对路径，可以使用which查看</p>
<p>配置计划中的重点和难点是时间周期的设置</p>
<p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20221205001056.png" alt="image-20210528111757978"></p>
<p><code>0 23 */5 * * /usr/bin/rm -rf /var/ftp/pub/*</code>     每隔5天，在23:00清空一次FTP服务器公共目录 /var/ftp/pub中的数据</p>
<p><code>30 17 * * 1,3,5 /usr/bin/tar -zcf httpd.tar.gz /etc/httpd </code>    每周1，3，5的17:30，使用tar自动备份/etc/httpd目录</p>
<p><code>crontab -e -u lifeisbinary </code>     为lifeisbinary用户设置计划任务</p>
<p><code>crontab -l</code>  查看用户计划任务</p>
<p><code>crontab -l -u lifeisbinary</code></p>
<p><code>crontab -r -u lifeisbinary</code>      删除用户lifesibinary的计划任务</p>
<p>删除单条任务使用 crontab -e </p>
<p>使用 crontab 命令设置的是用户计划任务，除此之外，用户还可以通过编辑/etc/crontab文件，设置系统计划任务。</p>
<p>配置系统任务时，应遵循“分钟 小时 天 月 星期 <strong>用户</strong> 命令“的格式。</p>
<p><code>0 */3 * * * root /usr/bin/echo &quot;hello world&quot;</code></p>
<h1 id="磁盘和文件系统管理"><a href="#磁盘和文件系统管理" class="headerlink" title="磁盘和文件系统管理"></a>磁盘和文件系统管理</h1><h3 id="磁盘分区和格式化"><a href="#磁盘分区和格式化" class="headerlink" title="磁盘分区和格式化"></a>磁盘分区和格式化</h3><h6 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h6><p>传统的磁盘分区包括：主分区、扩展分区、逻辑分区3中。</p>
<p>硬盘的主引导扇区（MBR）中用来存放分区信息的空间只有64个字节（主引导扇区一共只有512字节空间），而每个分区的信息要占16个字节，因而理论上一块磁盘最多只有4个分区，这四个分区都是主分区。</p>
<p>硬盘越来越大，4个分区远远不够，引入扩展分区的概念。<strong>扩展分区也是主分区。但它不能直接使用，相当于一个容器</strong>。在扩展分区中可以创建新的分区，这些分区被称为逻辑分区。逻辑分区的数量不再受主引导扇区空间大小的限制，想SCSI或SATA接口的磁盘在Linux系统中最多可以创建12个逻辑分区。</p>
<p><strong>Linux系统中，所有磁盘和磁盘中的每个分区都是用文件的形式来表示。</strong>例如，在计算机中有一块硬盘，硬盘上划分了3个分区，那么在Linux系统中就会有相对应的4个设备文件，一个是硬盘的设备文件，另外每个分区也有一个设备文件，所有的设备文件都统一存放在/dev目录。</p>
<p>不同类型硬盘和分区的设备文件都有统一的命名规则。</p>
<ul>
<li>硬盘：对于SATA或SCSI接口的硬盘设备，采用“sdX”的文件名,其中X为a,b,c,d等字母序号。例如，系统中的第一块硬盘表示为“sda”。</li>
<li>分区：以硬盘设备的文件名作为基础，在后边添加该分区对应的数字序号。例如，第一块硬盘中的第一个分区表示为“sda1”。</li>
</ul>
<blockquote>
<p>主分区数目最多为4，因此主分区和扩展分区的序号限制为1～4。逻辑分区的序号将从5开始。第一个逻辑分区的序号为“sda5”。</p>
</blockquote>
<h6 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h6><p>文件系统，决定了磁盘分区中存放、读取文件数据的方式和效率。</p>
<p>对于一块新的磁盘，在向其存放数据之前，必须先创建文件系统。文件系统是在对磁盘分区进程高级格式化时被创建的，在系统中会存在很多<strong>不同类型的文件系统</strong>。</p>
<p>Windows下，磁盘分区通常采用FAT32或NTFS。</p>
<p>Linux下，常用EXT系列和XFS文件系统。在CentOS 7之前，采用EXT系列，从CentOS 7开始转向更适合大数据环境的XFS。</p>
<blockquote>
<p>Linux系统也可以支持Windows中的FAT32文件系统，在Linux中该文件系统名称换为VFAT。</p>
<p>Linux系统不支持NTFS，在Linux上使用NTFS硬盘，需要额外安装NTFS-3G软件包。</p>
</blockquote>
<p>文件/etc/filesystems中存放了系统支持的所有文件系统类型。</p>
<p>Linux中有一个swap类型文件系统——交换分区。类似于Windows的虚拟内存。</p>
<h6 id="分区管理"><a href="#分区管理" class="headerlink" title="分区管理"></a>分区管理</h6><p>Linux中，磁盘分区管理工具是fdisk。</p>
<p><code>fdisk -l</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20221205001105.png" alt="image-20210528153202001"></p>
<ul>
<li>Boot: 是否是引导分区，* 表示引导分区</li>
<li>Id：表示分区类型的ID标记号，对于XFS分区，其为83，对于LVM分区，其为8e</li>
<li>System：表示分区类型，Linux代表XFS文件系统，Linux LVM代表逻辑卷</li>
</ul>
<h6 id="添加新硬盘给机器"><a href="#添加新硬盘给机器" class="headerlink" title="添加新硬盘给机器"></a>添加新硬盘给机器</h6><p><code>fdisk -l</code>    </p>
<p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20221205001112.png" alt="image-20210528153941487"></p>
<p>新加的硬盘为初始化，名称没有有效信息</p>
<ol>
<li><p>分区：</p>
<p><code>fdisk /dev/sdb</code>    进入磁盘分区的交互界面。</p>
<p>在创建逻辑分区前，需要先创建其容器扩建分区。</p>
<p>分区删除可以在fdisk交互界面中使用d。</p>
</li>
</ol>
<ol start="2">
<li><p>格式化分区：</p>
<p>格式化的主要目的是在分区中创建文件系统，同时格式化也会清空所有数据。</p>
<p><code>mkfs -t 指定的文件系统 分区设备文件名</code> </p>
<p><code>mkfs -t xfs /dev/sdb1</code></p>
</li>
<li><p>挂载</p>
<p>Linux系统与Windows系统在存储设备操作方式上的一个非常重要的区别就是挂载。</p>
<p>在Linux系统中，核心系统虽然可以通过设备文件操作各种设备，但是对用户来说，还需要通过挂载，才能想正常访问目录一样访问存储设备中的资源。</p>
<p><strong>挂载就是将用户不方便操作的设备文件与系统中的目录绑定起来，这样用户可以通过访问目录，来调用里面的数据。</strong></p>
<blockquote>
<p>作为挂载点的目录必须事先存在，挂载点目录最好为空目录，否则挂载之后，目录原有的内容会被暂时隐藏。</p>
</blockquote>
<p><code>mount 设备文件 挂载点目录</code></p>
<p><code>umount 挂载点目录</code>   //必须保证此时存储设备不能处于busy状态，常见的错误是在挂载点下进行卸载操作。</p>
<p>Linux系统提供了两个默认的挂载点目录：/media 和 /mnt</p>
<ul>
<li>/media 系统自动挂载点，在图形界面下，插入U盘或光盘时，系统会将它们自动挂载到/media下</li>
<li>/mnt 用户手动挂载点，不建议将设备直接挂载到/mnt目录之下，而应该先在其中创建子目录，然后分别将不同设备挂载到相应的子目录中。</li>
</ul>
<p>自动挂载，mount挂载的设备在系统重启或关系时都会被自动卸载，这些开机后又需要手动挂载一遍。<strong>Linux系统可以通过修改/etc/fstab文件来完成存储设备的自动挂载。</strong></p>
<blockquote>
<p>一般linux下，修改系统文件的方式进行设置，需要重启才能生效。</p>
<p>可以通过 mount -a让系统自动挂载配置文件中的所有文件系统，而无需重启系统。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20221205001121.png" alt="image-20210528164441972"></p>
<ul>
<li><p>第一个字段：需要挂载的设备文件名。可以使用UUID</p>
<p>UUID（Universally Unique Identifier,全局唯一标识符）</p>
<p>通过设备文件名，可能每次插入的移动设备分配的名称会有变化，而UUID是不会变的。</p>
<p><code>blikid 设备文件</code>      查看设备文件的UUID</p>
</li>
<li><p>第二个字段：挂载点</p>
</li>
<li><p>第三个字段：文件系统类型</p>
</li>
<li><p>第四个字段：挂载选项 ，一般采用“defaults”</p>
</li>
<li><p>第五个字段：存储设备是否需要dump备份，0表示忽略，1表示备份。</p>
</li>
<li><p>第六个字段：系统启动是是否检测这个存储设备，以及检测顺序。0表示不检测，1标识的设备检测完会检测2标识的设备</p>
</li>
</ul>
</li>
<li><p>查看挂载的的情况</p>
<p><code>df -hT</code></p>
<ul>
<li>df (disk free)</li>
<li>h:人性化显示</li>
<li>T：显示文件系统类型</li>
</ul>
<p>结果中会有很多类型为tmpfs的文件系统，这些都是Linux中的临时文件系统，一般可以忽略。<code>df -hT | grep -v tmpfs</code>过滤临时文件系统。</p>
<p>如今ISO镜像使用的频率越来越高，因为光驱已经逐渐淘汰。在Linux系统中，可以将ISO镜像直接挂载使用。Linux系统将ISO镜像视为一种特殊的“回环”文件系统，因此在挂载时需要添加“-o loop“选项。</p>
<p><code>mount -o loop xxx.iso mnt/cdrom</code>    将ISO文件挂载到/mnt/cdrom目录</p>
</li>
</ol>
<h3 id="磁盘配额管理"><a href="#磁盘配额管理" class="headerlink" title="磁盘配额管理"></a>磁盘配额管理</h3><p>略</p>
<h3 id="磁盘阵列管理"><a href="#磁盘阵列管理" class="headerlink" title="磁盘阵列管理"></a>磁盘阵列管理</h3><p>传统机械硬盘性能提升缓慢，固态硬盘可靠性较低。</p>
<p>q: 如何提高硬盘性能，又增强数据存储安全性（备份）？</p>
<p>a: 多块硬盘组成RAID</p>
<h6 id="RAID"><a href="#RAID" class="headerlink" title="RAID"></a>RAID</h6><p>RAID（Redundant Array of Independent Disks，独立冗余磁盘阵列），<strong>简称磁盘阵列</strong>。把<strong>多块独立的硬盘</strong>按照不同方式<strong>组合</strong>起来<strong>形成一个硬盘组</strong>。提供比单个硬盘更高的存储性能和数据备份能力。</p>
<p>从用户的角度看，组成的硬盘组就像一个硬盘，用户可以对它进行分区、格式化等，对磁盘阵列的操作与对单个硬盘基本一样。不同的是，磁盘阵列的<strong>读写速度要比单个硬盘高很多</strong>，而且可以<strong>提供自动数据备份</strong>功能。</p>
<p>RAID技术的两大特点：速度、安全。</p>
<p>有时我们希望提高硬盘的工作速度，有时希望提高数据的安全性，更多的时候希望二者兼得。因此，按照不同的用户需求，RAID提供了很多种不同的组合方式，这些组成磁盘阵列的不同方式就称为RAID级别。</p>
<p>常用的RAID级别：RAID0、RAID1、RAID10（RAID1 + RAID0） 和 RAID5</p>
<ol>
<li><p>RAID0——提升硬盘读写速度</p>
<p>组建RAID0至少需要两块硬盘。</p>
<p>数据将分成数据块存储在不同的硬盘上。进行数据读写操作时，对于多块硬盘同时操作，从而大幅度提高硬盘工作性能。</p>
<p>所有RAID机级别中，RAID0存取速度最快，磁盘利用率最高。但是没有冗余，数据没有备份。</p>
<p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20221205001130.png" alt="image-20210528194516742"></p>
</li>
<li><p>RAID1——数据备份</p>
<p><strong>只需两块硬盘构成</strong>，将用户写入其中一块盘的数据原样地自动复制到另一块盘。读取数据时，先从源盘读取，如果读取失败，则转读备份盘。</p>
<p>RAID1提供了很高的数据安全保障，但写入速率低，使用一半的空间来存储备份数据，存储成本高。</p>
</li>
<li><p>RAID10——将RAID1和RAID0组合</p>
<p>四块硬盘实现，将四块硬盘分为两组，组成RAID1，以保证数据安全。然后将两个RAID1硬盘组成组RAID0，以提高读写速度。</p>
<p>读写性能出色，又具有非常高的安全性。但存储成本高，磁盘空间利用率只有50%。<strong>由于大部分情况下相比硬盘的价格，我们更加在乎数据的价值，因此RAID10在生产环境中被广泛应用。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20221205001140.png" alt="image-20210528194448287"></p>
</li>
<li><p>RAID5——将奇偶校验信息和数据较差起来进程存储</p>
<p>至少需要三块盘，将数据分布于不同的硬盘上，硬盘上交叉存储数据与校验信息。</p>
<p>这样任何一块盘损坏，都可以通过其他硬盘将其中数据恢复回来。</p>
<p>RAID5，存储数据相对较安全，数据读取速率较高，但写入速率较低；磁盘利用率为（n-1）/ n。</p>
<p><strong>相比RAID10,是一种妥协的方案，兼顾存储性能、数据安全和储存成本，因而在生产环境中也被广泛采用。</strong></p>
</li>
</ol>
<h6 id="RAID实现方式"><a href="#RAID实现方式" class="headerlink" title="RAID实现方式"></a>RAID实现方式</h6><p>软件RAID：占用一定系统资源，受操作系统稳定性影响。</p>
<p>硬件RAID：通过独立的RAID硬件显卡，目前大多数服务器配置了RAID卡或主板上集成了RAID控制芯片。不占用其他硬件资源，稳定性和速度都比软件RAID好。</p>
<h3 id="逻辑卷管理（LVM）"><a href="#逻辑卷管理（LVM）" class="headerlink" title="逻辑卷管理（LVM）"></a>逻辑卷管理（LVM）</h3><p>逻辑卷管理是Linux系统中比较重要的一种磁盘管理机制，管理员利用LVM可以在磁盘不用重新分区的情况下动态调整文件系统的大小，并且利用LVM管理的文件系统可以跨越磁盘。</p>
<p>例如，系统中的sda1分区原先分配的容量，在使用一段时间后，发现容量不够用。</p>
<p>如果采用传统的磁盘管理机制，只能将sda硬盘重新分区，并给sda1分区分配更大的空间，但这样不可避免地会造成数据丢失，影响服务器的正常使用。</p>
<p>如果采用LVM机制，就可以在保证系统正常运行的前提下，随时为sda1分区增大空间，而且即使该分区所在的硬盘sda没有多余的空间可用，也可以随时为服务器添加新的硬盘，并将新的硬盘上的空间扩展到sda1分区中。当然，这里采用sda和sda1的方式进行描述，只是为了方便理解。<strong>当采用LVM机制后，传统意义上的硬盘会被组合成卷组（VG），然后从卷组中划分出逻辑卷（LV）来使用，逻辑卷就相当于传统意义上的磁盘分区。</strong></p>
<p><strong>LVM为我们提供了逻辑概念上的磁盘，使得文件系统不再关心底层物理磁盘的概念。LVM的出现实现了磁盘空间的动态调整和按需分配。</strong></p>
<p>LVM是建立在物理磁盘和分区智商的一个逻辑层，通过它可以将若干个磁盘分区组合为一个整体的卷组，形成一个存储池。在卷组中可以任意创建逻辑卷，并进一步在逻辑卷上创建文件系统，最终在系统中挂载使用的就是逻辑卷。逻辑卷的使用方法和普通的磁盘分区完全一样。</p>
<p>重要概念：</p>
<ul>
<li><p>物理卷（Physical Volume，PV ）是构建LVM的基础，通常就是指磁盘或磁盘分区。实现LVM的第一步，将原先的磁盘或磁盘分区转换为LVM物理卷。</p>
</li>
<li><p>卷组（Volume Group，VG）是一个存储池，是LVM逻辑概念上的磁盘设备，可以将多个物理卷组合成一个卷组。</p>
</li>
<li><p>逻辑卷（Logical Volume，LV）是LVM逻辑概念上的磁盘分区，可以从指定卷组中提取指定的容量来创建逻辑卷，最后对逻辑卷进程格式化和挂载使用。</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20221205001152.png" alt="image-20210528203349470"></p>
<blockquote>
<p>由于/boot目录用于存放系统引导文件，因此不能应用LVM机制。</p>
</blockquote>
<p>逻辑卷的设备文件可以采用“/dev/卷组名/逻辑卷名“的方式。</p>
<p>CentOS 7安装过程中，自动分区采用LVM机制（除/boot）</p>
<p><code>pvs</code>      查看系统中的已有物理卷</p>
<p><code>vgs</code>      查看系统中的已有卷组</p>
<p><code>lvs</code>      查看系统中的已有逻辑卷</p>
<p>1.创建物理卷pv</p>
<p>​    <code>pvcreate /dev/sd&#123;b,c&#125;</code>    将硬盘sdb、sdc转换为物理卷</p>
<p>​    <code>pvdisplay /dev/sdb</code>     查看置顶的pv：dev/sdb的信息</p>
<p>2.创建VG</p>
<p>​    <code>vgcreate wgroup /dev/sd&#123;b,c&#125;</code>     使用物理卷/dev/sdb，/dev/sdc创建名为wgroup的卷组</p>
<p>​    <code>vgdisplay wgroup</code>    查看指定卷组信息</p>
<p>3.创建逻辑卷LV</p>
<p>​    <code>lvcreate -L 容量 -n 逻辑卷名 卷组名</code></p>
<p>​    <code>lvcreate -L 39G -n ftp wgroup</code>    从wgroup卷组中创建大小为39G的逻辑卷ftp。创建好的逻辑卷设备文件为/dev/wgroup/ftp</p>
<p>​    <code>lvdisplay /dev/wgroup/ftp</code>     查看逻辑卷信息</p>
<p>4.使用逻辑卷</p>
<p>​    <code>mkfs -t xfs /dev/wgroup/ftp</code>    格式化</p>
<p>​    <code>mount /dev/wgroup/ftp /var/ftp</code></p>
<pre><code> 修改 /ect/fstab文件实现自动挂载
</code></pre>
<p>5.扩展逻辑卷空间</p>
<p>由于逻辑卷位于物理磁盘和分区之上的逻辑层，因此逻辑卷可以跨越物理磁盘。</p>
<p>当需要扩充逻辑卷的空间时，首先应保证它所在的卷组有可以分配的空余空间。我们可以按照以前的步骤，先添加一块盘，将其初始化物理卷之后，再加入卷组，这样就可以任意地调整逻辑卷的容量。</p>
<p>在调整容量之前先卸载设备和挂载点的关联 <code>umount /var/ftp</code></p>
<p>将新的磁盘转换为物理卷 <code>pvcreate /dev/sd&#123;d,e&#125;</code></p>
<p>将新的物理卷加入到卷组中 <code>vgextend wgroup /dev/sd&#123;d,e&#125;</code></p>
<p>扩展逻辑卷的空间 </p>
<ul>
<li><code>vlextend -L +10G /dev/wgroup/ftp</code>     在原有基础上增加10G空间</li>
<li><code>vlextend -L 10G /dev/wgroup/ftp</code>       将原有空间扩展到10G</li>
</ul>
<p>以上完成了对逻辑卷物理边界的扩大，还需要扩大逻辑边界，也就是要更新文件系统的大小。这样，才能使逻辑卷的容量真正发生变化。</p>
<p>不同类型文件系统使用的命令不同：</p>
<ul>
<li>xfs： <code>xfs_growfs 扩展的逻辑卷</code></li>
<li>EXT系列：<code>resize2fs 扩展的逻辑卷</code></li>
</ul>
<p>6.删除LVM分区</p>
<p>卸载挂载点—删除逻辑卷—删除卷组—删除物理卷</p>
<p><code>umount /var/ftp</code></p>
<p><code>lvremove /dev/wgroup/ftp</code></p>
<p><code>vgremove wgroup</code></p>
<p><code>pvremove /dev/sd&#123;b,c,d,e&#125;</code></p>
<p>在卸载挂载点时注意删除 /etc/fstab相应的条目</p>
<h1 id="用户和权限管理"><a href="#用户和权限管理" class="headerlink" title="用户和权限管理"></a>用户和权限管理</h1><p><code>useradd username</code>    添加用户</p>
<p><code>passwd username</code>      设置用户的登录密码</p>
<p><code>su username</code>             切换当前的登录的用户</p>
<h6 id="权限与归属"><a href="#权限与归属" class="headerlink" title="权限与归属"></a>权限与归属</h6><p>Linux系统中的每个文件或者目录都有两种属性：访问权限（读、写、执行）和文件归属（拥有文件的用户，拥有文件的组）</p>
<p><code>ls -l xxx    </code>查看文件的权限和归属</p>
<p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20221205001203.png" alt="image-20210528213617203"></p>
<ul>
<li><p>第一列：文件类型+访问权限（所有者的权限+所属组的权限+其他用户的权限）</p>
</li>
<li><p>第二列：所有者</p>
</li>
<li><p>第三列：所属组</p>
</li>
</ul>
<blockquote>
<p>用户只要有有对目录的写入权限，就可以删除文件夹下的子目录和文件，而不用管这些文件或子目录是否属于该用户。</p>
</blockquote>
<h6 id="chmod修改文件的权限"><a href="#chmod修改文件的权限" class="headerlink" title="chmod修改文件的权限"></a>chmod修改文件的权限</h6><p>chmod(change mode)，只有root用户或者文件的所有者才有权限用chmod命令改变文件或目录的访问权限。</p>
<p>chmod两种修改文件权限的方式：</p>
<p>1.字符形式的chmod命令</p>
<p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20221205001208.png" alt="image-20210528221846415"></p>
<p><code>chmod o+w 文件</code></p>
<p>2.数字形式的chmod命令</p>
<p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20221205001215.png" alt="image-20210528222630258"></p>
<p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20221205001233.png" alt="image-20210528222642134"></p>
<p><code>chmod 775 /tep/test</code></p>
<h6 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h6><p>允许<strong>经过授权的个别普通用户</strong>以root权限执行一些<strong>授权使用的管理命令</strong></p>
<blockquote>
<p>sudo运行后，输入的是当前用户的密码，而不是root密码</p>
</blockquote>
<p>![image-20210528223217118](/Users/lifeisbinary/Library/Application Support/typora-user-images/image-20210528223217118.png)</p>
<p>archer用户使用sudo命令也无法创建用户，因为在Linux系统中只有被授权的用户才能执行sudo命令，而且使用sudo也只能执行那些被授权的命令。</p>
<p>因此要使用sudo命令必须先经过管理员的授权设置，修改配置文件/etc/sudoers</p>
<p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20221205001252.png" alt="image-20210528223923016"></p>
<p><code>archer ALL=ALL</code>    可以以sudo执行所有命令</p>
<p><code>archer ALL=/usr/sbin/useradd,/usr/sbin/userdel,/usr/bin/passwd</code></p>
<p>执行部分命令</p>
<p><code>archer ALL=NOPASSWD:/usr/sbin/useradd,/usr/sbin/userdel</code></p>
<p>执行后不需要输入密码</p>
<p><code>archer ALL=NOPASSWD:/usr/sbin/useradd,!/usr/bin/passwd root</code>  通过！阻止用户执行指定的命令（阻止修改root的密码，😄）</p>
<h1 id="Shell脚本"><a href="#Shell脚本" class="headerlink" title="Shell脚本"></a>Shell脚本</h1><p>编译型编程语言：程序转换为二进制代码，计算机直接读取编译后的目标代码（object code），目标代码非常接近计算机底层，所有执行效率高。</p>
<p>解释型语言：又叫脚本语言，解释器一行为单位，将每行代码一次转换为二进制代码。每次执行程序都多了解释的过程，效率有所下降。</p>
<p><strong>Shell更加类似于Windows系统中的批处理程序，是一些命令的集合。编写Shell脚本的目的是批量执行一系列系统命令，并通过选择、循环等程序结构加以控制。</strong></p>
<p>参考资料：<a target="_blank" rel="noopener" href="https://book.douban.com/subject/34838376/">https://book.douban.com/subject/34838376/</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Alfred</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lifeisbinary.space/2022/12/05/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E4%B8%8E%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/">https://lifeisbinary.space/2022/12/05/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E4%B8%8E%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lifeisbinary.space" target="_blank">Life Is Binary</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%88%E7%8E%87/">效率</a><a class="post-meta__tags" href="/tags/Linux/">Linux</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20221205001616.png" data-sites="wechat,weibo,qq,douban"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2022/12/04/Mac-%E7%9A%84%E6%93%8D%E4%BD%9C-%E4%B8%8E-tip/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20221204234833.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Mac 的操作 与 tip</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/12/04/Mac-的操作-与-tip/" title="Mac 的操作 与 tip"><img class="cover" src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20221204234833.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-04</div><div class="title">Mac 的操作 与 tip</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/weiChatIcon.JPG" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Alfred</div><div class="author-info__description">Pligram</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">26</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/LifeIsBinary"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/LifeIsBinary" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:lifeisbinary@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">一些笔记～</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux"><span class="toc-number">1.</span> <span class="toc-text">Linux</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#linux%E7%9A%84%E5%8E%86%E5%8F%B2"><span class="toc-number">1.1.</span> <span class="toc-text">linux的历史</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#linux%E7%9A%84%E5%86%85%E6%A0%B8%E2%80%94%E2%80%94kernel"><span class="toc-number">1.2.</span> <span class="toc-text">linux的内核——kernel</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#linux%E7%9A%84%E5%8F%91%E5%9E%8B%E7%89%88%E6%9C%AC"><span class="toc-number">1.3.</span> <span class="toc-text">linux的发型版本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#VMware"><span class="toc-number">1.4.</span> <span class="toc-text">VMware</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E6%9E%B6%E6%9E%84"><span class="toc-number">1.4.1.</span> <span class="toc-text">虚拟机的架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E7%BD%91%E7%BB%9C"><span class="toc-number">1.4.2.</span> <span class="toc-text">虚拟机的网络</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Shell"><span class="toc-number">1.5.</span> <span class="toc-text">Shell</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E6%8F%90%E7%A4%BA%E7%AC%A6"><span class="toc-number">1.5.1.</span> <span class="toc-text">命令提示符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Shell%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.5.2.</span> <span class="toc-text">Shell的格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E6%9C%BA%E5%92%8C%E9%87%8D%E5%90%AF%E5%91%BD%E4%BB%A4"><span class="toc-number">1.5.3.</span> <span class="toc-text">关机和重启命令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E5%92%8C%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">文件管理和目录管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86"><span class="toc-number">2.0.1.</span> <span class="toc-text">目录管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ls"><span class="toc-number">2.0.1.1.</span> <span class="toc-text">ls</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#touch"><span class="toc-number">2.0.1.2.</span> <span class="toc-text">touch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mkdir-%E5%92%8C-rmdir"><span class="toc-number">2.0.1.3.</span> <span class="toc-text">mkdir 和 rmdir</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cp%E3%80%81mv%E5%92%8Crm"><span class="toc-number">2.0.1.4.</span> <span class="toc-text">cp、mv和rm</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-number">2.0.1.5.</span> <span class="toc-text">通配符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E7%AC%A6"><span class="toc-number">2.0.1.6.</span> <span class="toc-text">扩展符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E6%93%8D%E4%BD%9C"><span class="toc-number">2.0.2.</span> <span class="toc-text">文件内容操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#cat%E2%80%94%E2%80%94%E5%B0%8F%E6%96%87%E4%BB%B6%E6%9F%A5%E7%9C%8B"><span class="toc-number">2.0.2.1.</span> <span class="toc-text">cat——小文件查看</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#less-and-more-%E2%80%94%E2%80%94%E9%95%BF%E6%96%87%E4%BB%B6%E6%9F%A5%E7%9C%8B"><span class="toc-number">2.0.2.2.</span> <span class="toc-text">less and more ——长文件查看</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tail-and-head-%E2%80%94%E2%80%94-%E6%96%87%E4%BB%B6%E9%83%A8%E5%88%86%E6%9F%A5%E7%9C%8B"><span class="toc-number">2.0.2.3.</span> <span class="toc-text">tail and head —— 文件部分查看</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#wc%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E7%BB%9F%E8%AE%A1"><span class="toc-number">2.0.2.4.</span> <span class="toc-text">wc——文件内容统计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#echo%E2%80%94%E2%80%94%E8%BE%93%E5%87%BA%E6%8C%87%E5%AE%9A%E7%9A%84%E5%86%85%E5%AE%B9"><span class="toc-number">2.0.2.5.</span> <span class="toc-text">echo——输出指定的内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E6%9F%A5%E6%89%BE%E2%80%94%E2%80%94grep"><span class="toc-number">2.0.2.6.</span> <span class="toc-text">文件内容查找——grep</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E5%AF%B9%E6%AF%94%E2%80%94%E2%80%94diff"><span class="toc-number">2.0.2.7.</span> <span class="toc-text">文件内容对比——diff</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%92%8C%E6%97%A5%E6%9C%9F%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4"><span class="toc-number">2.0.3.</span> <span class="toc-text">时间和日期相关命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Date%E2%80%94%E2%80%94%E6%89%93%E5%8D%B0%E3%80%81%E4%BF%AE%E6%94%B9%E6%97%A5%E6%9C%9F"><span class="toc-number">2.0.3.1.</span> <span class="toc-text">Date——打印、修改日期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hwclock%E2%80%94%E2%80%94%E6%98%BE%E7%A4%BA%E6%88%96%E4%BF%AE%E6%94%B9%E7%A1%AC%E4%BB%B6%E6%97%B6%E9%92%9F"><span class="toc-number">2.0.3.2.</span> <span class="toc-text">hwclock——显示或修改硬件时钟</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%85%83%E6%95%B0%E6%8D%AE%E6%9F%A5%E7%9C%8B%E2%80%94%E2%80%94stat"><span class="toc-number">2.0.3.3.</span> <span class="toc-text">文件元数据查看——stat</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE%E5%91%BD%E4%BB%A4"><span class="toc-number">2.0.4.</span> <span class="toc-text">文件查找命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%BF%AB%E9%80%9F%E6%9F%A5%E6%89%BE%E2%80%94%E2%80%94locate"><span class="toc-number">2.0.4.1.</span> <span class="toc-text">简单快速查找——locate</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%BA%E5%A4%A7%E7%9A%84%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE%E5%91%BD%E4%BB%A4%E2%80%94%E2%80%94find"><span class="toc-number">2.0.4.2.</span> <span class="toc-text">强大的文件查找命令——find</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E6%9D%A1%E4%BB%B6%E8%AE%BE%E7%BD%AE%EF%BC%9A"><span class="toc-number">2.0.4.2.1.</span> <span class="toc-text">查找条件设置：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#find%E7%9A%84%E8%BE%85%E5%8A%A9%E5%91%BD%E4%BB%A4%E2%80%94%E2%80%94xargs"><span class="toc-number">2.0.4.2.2.</span> <span class="toc-text">find的辅助命令——xargs</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#linux%E5%86%85%E9%83%A8%E5%91%BD%E4%BB%A4%E5%92%8C%E5%A4%96%E9%83%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">2.0.5.</span> <span class="toc-text">linux内部命令和外部命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%AE%BE%E7%BD%AE%E5%88%AB%E5%90%8D%E2%80%94%E2%80%94alias"><span class="toc-number">2.0.6.</span> <span class="toc-text">常用命令设置别名——alias</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%E7%9A%84%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95%E2%80%94%E2%80%94history"><span class="toc-number">2.0.7.</span> <span class="toc-text">查看执行命令的历史记录——history</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%91%BD%E4%BB%A4%E5%B8%AE%E5%8A%A9%E4%BF%A1%E6%81%AF%E2%80%94%E2%80%94help"><span class="toc-number">2.0.8.</span> <span class="toc-text">查看命令帮助信息——help</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%85%E5%B1%8F%E2%80%94%E2%80%94clear"><span class="toc-number">2.0.9.</span> <span class="toc-text">清屏——clear</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="toc-number">2.0.10.</span> <span class="toc-text">标准输入输出</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-number">2.0.10.0.1.</span> <span class="toc-text">重定向</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vi%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8"><span class="toc-number">2.0.11.</span> <span class="toc-text">Vi文本编辑器</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E4%B8%8B"><span class="toc-number">2.0.11.0.0.1.</span> <span class="toc-text">命令模式下</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9C%AB%E8%A1%8C%E6%A8%A1%E5%BC%8F%E4%B8%8B"><span class="toc-number">2.0.11.0.0.2.</span> <span class="toc-text">末行模式下</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#vi%E7%9A%84%E5%8F%AF%E8%A7%86%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.0.11.0.0.3.</span> <span class="toc-text">vi的可视模式</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">软件包管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#tar%E5%91%BD%E4%BB%A4%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85%E5%92%8C%E5%8E%8B%E7%BC%A9"><span class="toc-number">3.0.1.</span> <span class="toc-text">tar命令——文件打包和压缩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8YUM%E8%BF%9B%E8%A1%8C%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85"><span class="toc-number">3.0.2.</span> <span class="toc-text">使用YUM进行软件安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#yum%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5"><span class="toc-number">3.0.3.</span> <span class="toc-text">yum故障排查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RPM%E8%BF%9B%E8%A1%8C%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86"><span class="toc-number">3.0.4.</span> <span class="toc-text">RPM进行软件包管理</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AE%89%E8%A3%85-%E5%8D%B8%E8%BD%BD%E8%BD%AF%E4%BB%B6"><span class="toc-number">3.0.4.0.0.1.</span> <span class="toc-text">安装&#x2F;卸载软件</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E8%BD%AF%E4%BB%B6%E5%8C%85"><span class="toc-number">3.0.4.0.0.2.</span> <span class="toc-text">查询软件包</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6"><span class="toc-number">3.0.5.</span> <span class="toc-text">利用源码编译安装软件</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">3.0.5.0.0.1.</span> <span class="toc-text">源码安装的流程</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%A7%A3%E5%8E%8B"><span class="toc-number">3.0.5.0.0.2.</span> <span class="toc-text">解压</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE"><span class="toc-number">3.0.5.0.0.3.</span> <span class="toc-text">配置</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BC%96%E8%AF%91"><span class="toc-number">3.0.5.0.0.4.</span> <span class="toc-text">编译</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AE%89%E8%A3%85"><span class="toc-number">3.0.5.0.0.5.</span> <span class="toc-text">安装</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">进程和服务管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-number">4.0.1.</span> <span class="toc-text">进程</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">4.0.1.0.0.1.</span> <span class="toc-text">进程的状态</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%88%B6%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%AD%90%E8%BF%9B%E7%A8%8B"><span class="toc-number">4.0.1.0.0.2.</span> <span class="toc-text">父进程和子进程</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">4.0.1.0.0.3.</span> <span class="toc-text">进程的属性</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">4.0.1.0.0.4.</span> <span class="toc-text">进程的分类</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E6%9F%A5%E8%AF%A2%E2%80%94%E2%80%94ps-%EF%BC%88process-state%EF%BC%89"><span class="toc-number">4.0.1.0.0.5.</span> <span class="toc-text">进程状态查询——ps （process state）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#top%E2%80%94%E2%80%94%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8A%A8%E6%80%81%E4%BF%A1%E6%81%AF"><span class="toc-number">4.0.1.0.0.6.</span> <span class="toc-text">top——查看进程的动态信息</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BC%AA%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94-proc"><span class="toc-number">4.0.1.0.0.7.</span> <span class="toc-text">伪文件系统—— &#x2F;proc</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">4.0.1.0.0.8.</span> <span class="toc-text">进程控制</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BB%88%E6%AD%A2%E8%BF%9B%E7%A8%8B"><span class="toc-number">4.0.1.0.0.9.</span> <span class="toc-text">终止进程</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#lsof%EF%BC%88list-open-files%EF%BC%89"><span class="toc-number">4.0.1.0.0.10.</span> <span class="toc-text">lsof（list open files）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E7%9A%84%E5%B7%A5%E5%85%B7%E3%80%82%E5%9C%A8linux%E7%8E%AF%E5%A2%83%E4%B8%8B%EF%BC%8C%E4%BB%BB%E4%BD%95%E4%BA%8B%E7%89%A9%E9%83%BD%E4%BB%A5%E6%96%87%E4%BB%B6%E7%9A%84%E5%BD%A2%E5%BC%8F%E5%AD%98%E5%9C%A8%EF%BC%8C%E9%80%9A%E8%BF%87%E6%96%87%E4%BB%B6%E4%B8%8D%E4%BB%85%E4%BB%85%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AE%E5%B8%B8%E8%A7%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E8%BF%98%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AE%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%A1%AC%E4%BB%B6%E3%80%82%E5%A6%82%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE-TCP-%E5%92%8C%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE-UDP-%E5%A5%97%E6%8E%A5%E5%AD%97%E7%AD%89%EF%BC%8C%E7%B3%BB%E7%BB%9F%E5%9C%A8%E5%90%8E%E5%8F%B0%E9%83%BD%E4%B8%BA%E8%AF%A5%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%88%86%E9%85%8D%E4%BA%86%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%EF%BC%8C%E8%AF%A5%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E6%8F%90%E4%BE%9B%E4%BA%86%E5%A4%A7%E9%87%8F%E5%85%B3%E4%BA%8E%E8%BF%99%E4%B8%AA%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%9C%AC%E8%BA%AB%E7%9A%84%E4%BF%A1%E6%81%AF%E3%80%82"><span class="toc-number">4.0.1.0.0.11.</span> <span class="toc-text">查看当前系统文件的工具。在linux环境下，任何事物都以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。如传输控制协议 (TCP) 和用户数据报协议 (UDP) 套接字等，系统在后台都为该应用程序分配了一个文件描述符，该文件描述符提供了大量关于这个应用程序本身的信息。</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E4%BF%A1%E6%81%AF"><span class="toc-number">4.0.2.</span> <span class="toc-text">查看用户登录信息</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%B8%A2%E5%87%BA%E5%8F%AF%E7%96%91%E7%94%A8%E6%88%B7"><span class="toc-number">4.0.2.0.0.1.</span> <span class="toc-text">踢出可疑用户</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E5%8D%A0%E7%94%A8%E7%9A%84%E8%B5%84%E6%BA%90%E6%83%85%E5%86%B5"><span class="toc-number">4.0.3.</span> <span class="toc-text">查看系统占用的资源情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1"><span class="toc-number">4.0.4.</span> <span class="toc-text">服务</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%EF%BC%9A"><span class="toc-number">4.0.4.0.0.1.</span> <span class="toc-text">服务：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%9B%E7%A8%8B"><span class="toc-number">4.0.4.0.0.2.</span> <span class="toc-text">系统初始化进程</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8systemctl%E5%91%BD%E4%BB%A4%E7%AE%A1%E7%90%86%E6%9C%8D%E5%8A%A1"><span class="toc-number">4.0.4.0.0.3.</span> <span class="toc-text">使用systemctl命令管理服务</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%90%E8%A1%8C%E7%BA%A7%E5%88%AB"><span class="toc-number">4.0.4.0.0.4.</span> <span class="toc-text">管理系统的运行级别</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%87%8D%E7%BD%AEroot%E5%AF%86%E7%A0%81"><span class="toc-number">4.0.4.0.0.5.</span> <span class="toc-text">重置root密码</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1"><span class="toc-number">4.0.4.0.0.6.</span> <span class="toc-text">计划任务</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E5%92%8C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86"><span class="toc-number">5.</span> <span class="toc-text">磁盘和文件系统管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA%E5%92%8C%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="toc-number">5.0.1.</span> <span class="toc-text">磁盘分区和格式化</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA"><span class="toc-number">5.0.1.0.0.1.</span> <span class="toc-text">磁盘分区</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">5.0.1.0.0.2.</span> <span class="toc-text">文件系统</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E7%AE%A1%E7%90%86"><span class="toc-number">5.0.1.0.0.3.</span> <span class="toc-text">分区管理</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E6%96%B0%E7%A1%AC%E7%9B%98%E7%BB%99%E6%9C%BA%E5%99%A8"><span class="toc-number">5.0.1.0.0.4.</span> <span class="toc-text">添加新硬盘给机器</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E9%85%8D%E9%A2%9D%E7%AE%A1%E7%90%86"><span class="toc-number">5.0.2.</span> <span class="toc-text">磁盘配额管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97%E7%AE%A1%E7%90%86"><span class="toc-number">5.0.3.</span> <span class="toc-text">磁盘阵列管理</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#RAID"><span class="toc-number">5.0.3.0.0.1.</span> <span class="toc-text">RAID</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#RAID%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">5.0.3.0.0.2.</span> <span class="toc-text">RAID实现方式</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E5%8D%B7%E7%AE%A1%E7%90%86%EF%BC%88LVM%EF%BC%89"><span class="toc-number">5.0.4.</span> <span class="toc-text">逻辑卷管理（LVM）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E5%92%8C%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86"><span class="toc-number">6.</span> <span class="toc-text">用户和权限管理</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9D%83%E9%99%90%E4%B8%8E%E5%BD%92%E5%B1%9E"><span class="toc-number">6.0.0.0.0.1.</span> <span class="toc-text">权限与归属</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#chmod%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E7%9A%84%E6%9D%83%E9%99%90"><span class="toc-number">6.0.0.0.0.2.</span> <span class="toc-text">chmod修改文件的权限</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#sudo"><span class="toc-number">6.0.0.0.0.3.</span> <span class="toc-text">sudo</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Shell%E8%84%9A%E6%9C%AC"><span class="toc-number">7.</span> <span class="toc-text">Shell脚本</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/12/05/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E4%B8%8E%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/" title="Linux 系统管理与常用指令"><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20221205001616.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux 系统管理与常用指令"/></a><div class="content"><a class="title" href="/2022/12/05/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E4%B8%8E%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/" title="Linux 系统管理与常用指令">Linux 系统管理与常用指令</a><time datetime="2022-12-04T16:14:07.000Z" title="发表于 2022-12-05 00:14:07">2022-12-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/04/Mac-%E7%9A%84%E6%93%8D%E4%BD%9C-%E4%B8%8E-tip/" title="Mac 的操作 与 tip"><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20221204234833.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Mac 的操作 与 tip"/></a><div class="content"><a class="title" href="/2022/12/04/Mac-%E7%9A%84%E6%93%8D%E4%BD%9C-%E4%B8%8E-tip/" title="Mac 的操作 与 tip">Mac 的操作 与 tip</a><time datetime="2022-12-04T14:49:35.000Z" title="发表于 2022-12-04 22:49:35">2022-12-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/08/14/%E2%80%9Cpython2%E4%B8%8B%E5%AE%89%E8%A3%85qi%E5%92%8Calmath%E5%BA%93import%E5%87%BA%E9%94%99%E2%80%9D%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/" title="“python2下安装qi和almath库import出错”问题解决"><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20210814141831.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="“python2下安装qi和almath库import出错”问题解决"/></a><div class="content"><a class="title" href="/2021/08/14/%E2%80%9Cpython2%E4%B8%8B%E5%AE%89%E8%A3%85qi%E5%92%8Calmath%E5%BA%93import%E5%87%BA%E9%94%99%E2%80%9D%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/" title="“python2下安装qi和almath库import出错”问题解决">“python2下安装qi和almath库import出错”问题解决</a><time datetime="2021-08-14T06:07:40.000Z" title="发表于 2021-08-14 14:07:40">2021-08-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/08/14/%E5%AE%85%E5%9C%A8%E5%AE%B6%E7%B3%BB%E5%88%97Tips%E2%80%94%E2%80%94%E7%85%AE%E9%A5%BA%E5%AD%90%E7%AC%94%E8%AE%B0/" title="宅在家系列Tips——煮饺子笔记"><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20210814124617.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="宅在家系列Tips——煮饺子笔记"/></a><div class="content"><a class="title" href="/2021/08/14/%E5%AE%85%E5%9C%A8%E5%AE%B6%E7%B3%BB%E5%88%97Tips%E2%80%94%E2%80%94%E7%85%AE%E9%A5%BA%E5%AD%90%E7%AC%94%E8%AE%B0/" title="宅在家系列Tips——煮饺子笔记">宅在家系列Tips——煮饺子笔记</a><time datetime="2021-08-14T04:40:09.000Z" title="发表于 2021-08-14 12:40:09">2021-08-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/08/11/Hexo%E5%8D%9A%E5%AE%A2%E8%87%AA%E5%AE%9A%E4%B9%89Live2d%E6%8C%82%E4%BB%B6/" title="Hexo博客自定义Live2d挂件"><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20210811192458.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hexo博客自定义Live2d挂件"/></a><div class="content"><a class="title" href="/2021/08/11/Hexo%E5%8D%9A%E5%AE%A2%E8%87%AA%E5%AE%9A%E4%B9%89Live2d%E6%8C%82%E4%BB%B6/" title="Hexo博客自定义Live2d挂件">Hexo博客自定义Live2d挂件</a><time datetime="2021-08-11T11:14:16.000Z" title="发表于 2021-08-11 19:14:16">2021-08-11</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20221205001616.png')"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By Alfred</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"scale":1,"jsonPath":"/live2dw/assets/Violet.model.json"},"display":{"position":"right","hOffset":5,"vOffset":-20},"mobile":{"show":false,"scale":0.5},"react":{"opacity":1},"log":false});</script></body></html>