<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>国防科技大学周宗潭教授——“基于机器人操作系统（ROS）的脑机接口实现”</title>
      <link href="/2021/08/14/%E5%9B%BD%E9%98%B2%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E5%91%A8%E5%AE%97%E6%BD%AD%E6%95%99%E6%8E%88%E2%80%94%E2%80%94%E2%80%9C%E5%9F%BA%E4%BA%8E%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88ROS%EF%BC%89%E7%9A%84%E8%84%91%E6%9C%BA%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E2%80%9D/"/>
      <url>/2021/08/14/%E5%9B%BD%E9%98%B2%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E5%91%A8%E5%AE%97%E6%BD%AD%E6%95%99%E6%8E%88%E2%80%94%E2%80%94%E2%80%9C%E5%9F%BA%E4%BA%8E%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88ROS%EF%BC%89%E7%9A%84%E8%84%91%E6%9C%BA%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E2%80%9D/</url>
      
        <content type="html"><![CDATA[<div class="news_content" id="objId">     <p style="white-space: normal; text-align: justify; line.height: 1.75em;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;">&nbsp; &nbsp; &nbsp; &nbsp;2020年12月19日，第二届智慧医疗与康复大会暨第五届脑机接口论坛在江苏省昆山举行。大会指导单位为中国生物医学工程学会、中国电子学会，由华东理工大学信息科学与工程学院、西安交通大学人工智能学院、智能医学工程教育部工程研究中心、上海脑科学与类脑研究中心等单位主办。国防科技大学周宗潭教授在脑机交互与控制分会场作“基于机器人操作系统（ROS）的脑机接口实现”的学术报告。</span></p><p style="white-space: normal; text-align: center; line.height: 1.75em;"><img src="http://www.scholat.com/resources/p_picture/fwang8_1609566324579/img/word/media/image1.png" width="700" height="207.2378pt" style="width: 700px; height: 406px;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;">&nbsp;<br></span></p><p style="white-space: normal; text-align: center; line.height: 1.75em;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;">图1&nbsp; “基于机器人操作系统（ROS）的脑机接口实现”学术汇报</span></p><p style="white-space: normal; text-align: center; line.height: 1.75em;"><img src="http://www.scholat.com/resources/p_picture/fwang8_1609566324579/img/word/media/image2.png" width="700" height="747" border="0" hspace="0" vspace="0" title="" style="width: 700px; height: 747px;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;">&nbsp;<br></span></p><p style="white-space: normal; text-align: center; line.height: 1.75em;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;">图2&nbsp; 第五届脑机接口论坛——脑机交互与控制大会演讲题目</span></p><p style="white-space: normal; text-indent: 21pt; text-align: justify; line.height: 1.75em;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;">&nbsp;在脑机交互与控制大会上，国防科技大学胡德文教授、清华大学高小榕教授以及复旦大学王守岩教授讲述脑机接口理论科学研究的最新进展和面临的挑战，是为学术研究中的“学”。作为最后一位演讲者，周教授则以学术研究中的“术”为核心，从动机（构建脑机接口综合应用平台）、动手（设计脑机接口机器人操作系统）、动起来（设计集成多技术的康复车）三个方面进行脑机接口实现的报告<span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; Georgia, Georgia, &quot;Times New Roman&quot;, Times, &quot;Microsoft YaHei&quot;, SimSun, SimHei, serif; color: rgb(51, 51, 51);">。</span></span></p><p style="white-space: normal; line.height: 1.75em;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;"><strong>&nbsp;&nbsp;&nbsp;&nbsp;1. 动机——构建脑机接口综合平台</strong></span></p><p style="white-space: normal; text-align: center; line.height: 1.75em;"><img src="http://www.scholat.com/resources/p_picture/fwang8_1609566324579/img/word/media/image3.png" width="700" height="406" border="0" hspace="0" vspace="0" title="" style="width: 700px; height: 406px;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;">&nbsp;<br></span></p><p style="white-space: normal; text-align: center; line.height: 1.75em;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;">图3&nbsp; 脑机接口系统存在的问题</span></p><p style="white-space: normal; text-align: justify; line.height: 1.75em;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;">&nbsp; &nbsp; &nbsp; &nbsp; 针对目前脑机接口系统存在的三个问题：系统集成有限、运行效率低、使用方便性差，周教授构建了一套脑机接口综合应用平台，通过脑电信号控制康复车运动导航和车上集成机械臂抓取物体，实现了残疾人“去想去的地方，做想做的事”的最低要求。该系统将人的判断、决策和规划能力与推荐算法结合，融入脑机接口中以提高系统工作效率，实现了人类智慧与机器智能的融合。同时，对传统BCI系统接触式测量不便的问题，提出以脑磁为代表的非接触式神经活动信号测量的方案。</span></p><p style="white-space: normal; text-align: center; line.height: 1.75em;"><img src="http://www.scholat.com/resources/p_picture/fwang8_1609566324579/img/word/media/image4.png" width="700" height="406" border="0" hspace="0" vspace="0" title="" style="width: 700px; height: 406px;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;">&nbsp;<br></span></p><p style="white-space: normal; text-align: center; line.height: 1.75em;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;">图4&nbsp; 脑控康复车抓取物体</span></p><p style="white-space: normal; line.height: 1.75em;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;"><strong>&nbsp;&nbsp;&nbsp;&nbsp;2. 动手——设计脑机接口机器人操作系统</strong></span></p><p style="white-space: normal; text-align: justify; line.height: 1.75em;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; Georgia, Georgia, &quot;Times New Roman&quot;, Times, &quot;Microsoft YaHei&quot;, SimSun, SimHei, serif;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;脑机接口机器人操作系统（BCIROS）由脑机接口（BCI）软件框架和机器人操作系统（ROS）两个部分构成。在软件框架方面，现有的脑机接口软件框架主要有BCI2000、OpenVibe、Tobi、BCILab和XBCI等，其中行业内使用最多的是BCI2000。BCI2000框架中各个模块间的采用TCP的方式通信，支持跨平台部署，并且可以使用C++、Python等多种程序设计语言进行开发。但其软件框架与应用分离，无法实现BCI系统与其他系统的深度融合，且软件平台封闭，所使用的私有协议使得扩展开发困难。ROS是用于编写机器人软件程序的一种高度灵活性软件架构，它提供了广泛的库文件实现以机动性、操作控制、感知为主的机器人功能。依托强大的社区，ROS提供了一套“一站式”的方法使得用户得以搜索并使用来自全球开发者数以千计的ROS程序包，其中就包括脑机接口相关程序包。ROS中虚拟仿真平台gazebo，能够通过相关的机器人模型和场景建模，与BCI系统连接实现BCI控制仿真实验。&nbsp;&nbsp;</span></p><p style="white-space: normal; text-align: center; line.height: 1.75em;"><img src="http://www.scholat.com/resources/p_picture/fwang8_1609566324579/img/word/media/image5.png" width="700" height="406" border="0" hspace="0" vspace="0" title="" style="width: 700px; height: 406px;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;">&nbsp;<br></span></p><p style="white-space: normal; text-align: center; line.height: 1.75em;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;">图5&nbsp; 脑机接口软件框架</span></p><p style="white-space: normal; text-align: center; line.height: 1.75em;"><img src="http://www.scholat.com/resources/p_picture/fwang8_1609566324579/img/word/media/image6.png" width="700" height="406" border="0" hspace="0" vspace="0" title="" style="width: 700px; height: 406px;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;">&nbsp;<br></span></p><p style="white-space: normal; text-align: center; line.height: 1.75em;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;">图6&nbsp; 机器人操作系统（ROS）</span></p><p style="white-space: normal; text-align: center; line.height: 1.75em;"><img src="http://www.scholat.com/resources/p_picture/fwang8_1609566324579/img/word/media/image7.png" width="700" height="406" border="0" hspace="0" vspace="0" title="" style="width: 700px; height: 406px;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;">&nbsp;<br></span></p><p style="white-space: normal; text-align: center; line.height: 1.75em;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;">图7&nbsp; gazebo对<span class="a a3" style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; Georgia, Georgia, &quot;Times New Roman&quot;, Times, &quot;Microsoft YaHei&quot;, SimSun, SimHei, serif; color: rgb(77, 77, 77);"></span>机器人模型和室内场景建模</span></p><p style="white-space: normal; text-align: justify; line.height: 1.75em;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;">&nbsp; &nbsp; &nbsp; &nbsp; 周教授团队在ROS最小化系统roscore的基础上，开发集成脑电信号源采集、存储、可视化与信号分析模块的BCI软件框架。设计包含主控逻辑和控制状态的切换的有限状态机，用于实现人机交互和机器人控制功能。并通过SSVEP控制ROS中虚拟小乌龟实体的实验，验证了该系统的可行性。</span></p><p style="white-space: normal; text-align: center; line.height: 1.75em;"><img src="http://www.scholat.com/resources/p_picture/fwang8_1609566324579/img/word/media/image8.png" width="700" height="406" border="0" hspace="0" vspace="0" title="" style="width: 700px; height: 406px;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;">&nbsp;<br></span></p><p style="white-space: normal; text-align: center; line.height: 1.75em;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;">图8&nbsp; 脑机接口机器人操作系统架构图</span></p><p style="white-space: normal; text-align: center; line.height: 1.75em;"><img src="http://www.scholat.com/resources/p_picture/fwang8_1609566324579/img/word/media/image9.png" width="700" height="406" border="0" hspace="0" vspace="0" title="" style="width: 700px; height: 406px;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;">&nbsp;<br></span></p><p style="white-space: normal; text-align: center; line.height: 1.75em;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;">图9&nbsp; SSVEP控制ROS系统下的虚拟目标——小乌龟</span></p><p style="white-space: normal; text-align: justify; line.height: 1.75em;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;"><strong>&nbsp;&nbsp;&nbsp;&nbsp;3. 动起来——设计集成多项技术的康复车</strong></span></p><ol class="custom_num1 list-paddingleft-1" style="width: 763.797px; white-space: normal;"><li class="list-num-2-1 list-num1-paddingleft-1"><p style="text-align: justify; line.height: 1.75em;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;">（1）设计小型化脑电采集模块</span></p></li></ol><p style="white-space: normal; text-align: justify; line.height: 1.75em;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;">&nbsp; &nbsp; &nbsp; &nbsp; 周教授基于国产芯片ESP32设计了一套小型化、低成本（200元左右）的脑电信号采集模块，集成便携式脑电信号模块与干式电极帽，实现了“即戴即用”的脑电信号采集。</span></p><ol class="custom_num1 list-paddingleft-1" style="width: 763.797px; white-space: normal;"><li class="list-num-2-1 list-num1-paddingleft-1"><p style="text-align: justify; line.height: 1.75em;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;">（2）实现脑控康复车</span></p></li></ol><p style="white-space: normal; text-align: justify; line.height: 1.75em;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;">&nbsp; &nbsp; &nbsp; &nbsp; 康复车的主要硬件构成是集成全向轮的底盘、机械臂和深度摄像头。软件部分由主控制系统、基于图像点云的视觉感知系统和目标规划和导航系统构成，其中涉及到环境理解（YOLO）、目标定位（Kinect）和用户辅助决策(基于历史信息的贝叶斯推荐系统)等功能。</span></p><p style="white-space: normal; text-align: center; line.height: 1.75em;"><img src="http://www.scholat.com/resources/p_picture/fwang8_1609566324579/img/word/media/image10.png" width="700" height="406" border="0" hspace="0" vspace="0" title="" style="width: 700px; height: 406px;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;">&nbsp;<br></span></p><p style="white-space: normal; text-align: center; line.height: 1.75em;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;">图10&nbsp; 脑控康复车系统构成</span></p><p style="white-space: normal; text-align: center; line.height: 1.75em;"><img src="http://www.scholat.com/resources/p_picture/fwang8_1609566324579/img/word/media/image11.png" width="700" height="406" border="0" hspace="0" vspace="0" title="" style="width: 700px; height: 406px;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;">&nbsp;<br></span></p><p style="white-space: normal; text-align: center; line.height: 1.75em;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;">图11&nbsp; 脑控康复车功能</span></p><ol class="custom_num1 list-paddingleft-1" style="width: 763.797px; white-space: normal;"><li class="list-num-2-1 list-num1-paddingleft-1"><p style="text-align: justify; line.height: 1.75em;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;">（3）康复车实地测试</span></p></li></ol><p style="white-space: normal; text-align: justify; line.height: 1.75em;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;">&nbsp; &nbsp; &nbsp; &nbsp; 康复车在湖南长沙湘雅医院进行了实地测试，选择10个高位截瘫的患者，操控康复车到达指定的位置，使用机械臂完成的喝水动作，实验中，10名患者都能成功地通过康复车完成该任务。</span></p><p style="white-space: normal; text-align: center; line.height: 1.75em;"><img src="http://www.scholat.com/resources/p_picture/fwang8_1609566324579/img/word/media/image12.png" width="700" height="406" border="0" hspace="0" vspace="0" title="" style="width: 700px; height: 406px;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;">&nbsp;<br></span></p><p style="white-space: normal; text-align: center; line.height: 1.75em;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;">图12&nbsp; 高位截瘫患者控制康复车完成喝水任务</span></p><p style="white-space: normal; text-align: justify; line.height: 1.75em;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;">&nbsp; &nbsp; &nbsp; &nbsp; 报告的最后，周教授表示BCI技术与ROS的结合将有助提高残疾人的生活水平，未来更多新技术的集成，将会使得脑机接口机器人操作系统更加完善，并产生更加广阔的应用前景。</span></p><p style="white-space: normal; line.height: 1.75em;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;"><br></span></p><p style="white-space: normal; line.height: 1.75em;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;"><br></span></p><p style="white-space: normal; text-align: justify; line.height: 1.75em;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;"><strong>周宗潭，国防科学技术大学智能科学院教授、博士生导师。主要从事模式识别与智能系统，脑科学与认知科学，脑机接口方面的研究工作。在Brain, NeuroImage, IEEE T. PAMI, JNE等杂志上发表SCI论文30多篇；获得国家发明和国防专利授权6项；参编专著3本，译著1本。在国际脑机接口竞赛和国际视觉竞赛中多次获得优异成绩。获国家自然科学二等奖、教育部自然科学一等奖、省部级科技进步一等奖1项，二等奖2项，入选教育部新世纪人才支持计划。主持和完成国家科学基金重点项目2项、面上项目1项， 973子项目1项，863项目1项。</strong></span></p><p style="white-space: normal;"><br></p><p class="a a7" style="white-space: normal;"><br></p><p style="white-space: normal; padding: 0px; line.height: 1.75em;"><span style="padding: 0px; font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;">撰稿人：lifeisbinary</span></p><p style="white-space: normal; padding: 0px; line.height: 1.75em;"><span style="padding: 0px; font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;"><br></span></p><p style="white-space: normal; padding: 0px; line.height: 1.75em;"><span style="padding: 0px; font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;"><br></span></p><p style="white-space: normal; padding: 0px; line.height: 1.75em;"><span style="color: rgb(51, 51, 51); text-indent: 32px; padding: 0px; font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;">参考链接：</span></p><p style="white-space: normal; padding: 0px; line.height: 1.75em;"><span style="color: rgb(51, 51, 51); text-indent: 32px; padding: 0px; font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;">1.&nbsp;&nbsp;<a href="http://daxue.cn-healthcare.com/detail/2019" _src="http://daxue.cn-healthcare.com/detail/2019" target="_blank">http://daxue.cn-healthcare.com/detail/2019</a></span></p><p style="white-space: normal; padding: 0px; line.height: 1.75em;"><span style="padding: 0px; font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;">2.&nbsp;<a href="https://baike.baidu.com/item/ros/4710560" _src="https://baike.baidu.com/item/ros/4710560" target="_blank">https://baike.baidu.com/item/ros/4710560</a></span></p><p style="line.height: 1.75em;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;"><br></span></p> </div>]]></content>
      
      
      <categories>
          
          <category> 脑机接口 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BCI </tag>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>“python2下安装qi和almath库import出错”问题解决</title>
      <link href="/2021/08/14/%E2%80%9Cpython2%E4%B8%8B%E5%AE%89%E8%A3%85qi%E5%92%8Calmath%E5%BA%93import%E5%87%BA%E9%94%99%E2%80%9D%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
      <url>/2021/08/14/%E2%80%9Cpython2%E4%B8%8B%E5%AE%89%E8%A3%85qi%E5%92%8Calmath%E5%BA%93import%E5%87%BA%E9%94%99%E2%80%9D%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="出现的问题"><a href="#出现的问题" class="headerlink" title="出现的问题"></a>出现的问题</h2><p>在Pycharm虚拟环境python2.7下，安装Softbank公司Nao机器人库：qi 和 almath 失败</p><h3 id="import-qi"><a href="#import-qi" class="headerlink" title="import qi"></a>import qi</h3><p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20210814141153.png" alt="image-20210622214642779"></p><h3 id="import-almath"><a href="#import-almath" class="headerlink" title="import almath"></a>import almath</h3><p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20210814141203.png" alt="image-20210622214732844"></p><blockquote><p>出现这种错误是因为，python2.7下almath版本太高，需要安装低版本almath=1.6.6。</p></blockquote><p>安装低版本后，又出现新错误</p><p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20210814141210.png" alt="image-20210622214928535"></p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>使用系统自带的python解释器，不要用虚拟环境。</p><blockquote><p>Softbank官方在python库安装的时候已经说了要使用系统自带的python解释器（<a href="http://doc.aldebaran.com/2-5/dev/python/install_guide.html%EF%BC%89">http://doc.aldebaran.com/2-5/dev/python/install_guide.html）</a></p><p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20210814141222.png" alt="image-20210622215254682"></p></blockquote><h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>太不仔细了，我的项目之前在python3虚拟环境下没有问题。所以，想着python2继续用虚拟环境，结果被SoftBank官方教训了，卡了我好久，哈哈。</p>]]></content>
      
      
      <categories>
          
          <category> Nao开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -qi -almath </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>宅在家系列Tips——煮饺子笔记</title>
      <link href="/2021/08/14/%E5%AE%85%E5%9C%A8%E5%AE%B6%E7%B3%BB%E5%88%97Tips%E2%80%94%E2%80%94%E7%85%AE%E9%A5%BA%E5%AD%90%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/08/14/%E5%AE%85%E5%9C%A8%E5%AE%B6%E7%B3%BB%E5%88%97Tips%E2%80%94%E2%80%94%E7%85%AE%E9%A5%BA%E5%AD%90%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>广东这边的饺子，蘸料真不习惯。没有辣椒，醋也不带劲。所以准备些料，平时自己做蘸料。简单记一下，方便以后忘记怎么做了会看，毕竟有食堂和外卖吃，一般不动手。</p><h2 id="煮"><a href="#煮" class="headerlink" title="煮"></a>煮</h2><h3 id="速冻饺子"><a href="#速冻饺子" class="headerlink" title="速冻饺子"></a>速冻饺子</h3><p>凉水下锅，这样可以保证水开后，饺子内部和外部的温度接近，里面的馅熟的更快。不会容易出现开水煮时的皮熟馅不熟的情况。</p><h3 id="现包饺子"><a href="#现包饺子" class="headerlink" title="现包饺子"></a>现包饺子</h3><p>沸水下锅，这样皮不容易糊。</p><h3 id="煮时候不粘不破皮的方法"><a href="#煮时候不粘不破皮的方法" class="headerlink" title="煮时候不粘不破皮的方法"></a>煮时候不粘不破皮的方法</h3><ul><li><p>首先，水开后，加入一勺 食盐，使饺子皮有韧度，不易破。</p></li><li><p>然后，放入饺子，轻轻搅动，防止粘锅或粘连再一起。</p></li><li><p>接着， 盖上锅盖，等待煮开。煮开后，加入一碗凉水（使饺子里外受热均匀，面皮劲道，肉馅 口感更好，防止饺子一直滚水，碰撞皮破裂） ，再次盖上锅盖，等待开过再加凉水烧开，一般加三次冷水，就煮好了。（三开三点水） </p></li></ul><p>参考：</p><iframe width="656" height="369" src="https://www.youtube.com/embed/AE8sCbusjdM" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><h2 id="饺子的蘸料"><a href="#饺子的蘸料" class="headerlink" title="饺子的蘸料"></a>饺子的蘸料</h2><p>备料： </p><p>​    小葱、小米椒、大蒜、</p><p>​    盐、鸡精、糖、生抽、陈醋、油泼辣子、香油</p><p>做法：</p><ol><li><p>小葱和小米椒切成圈</p></li><li><p>大蒜拍碎并剁成蒜末</p></li><li><p>碗中放入小米椒、小葱和大蒜末， 泠上适量热油，搅拌均匀</p></li><li><p>加入适量 盐、鸡精、糖，搅拌均匀。加入两勺生抽，两勺陈醋，一勺油泼辣子，适量香油。</p></li></ol><p>参考</p><iframe width="656" height="369" src="https://www.youtube.com/embed/r3CqpIsQaSE" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>]]></content>
      
      
      <categories>
          
          <category> 简餐 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 饺子 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客自定义Live2d挂件</title>
      <link href="/2021/08/11/Hexo%E5%8D%9A%E5%AE%A2%E8%87%AA%E5%AE%9A%E4%B9%89Live2d%E6%8C%82%E4%BB%B6/"/>
      <url>/2021/08/11/Hexo%E5%8D%9A%E5%AE%A2%E8%87%AA%E5%AE%9A%E4%B9%89Live2d%E6%8C%82%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>想给自己搭建好的博客，设置Live2d挂件是比较简单的。</p><p>如下：</p><h3 id="配置live2d模型库提供的模型"><a href="#配置live2d模型库提供的模型" class="headerlink" title="配置live2d模型库提供的模型"></a>配置live2d模型库提供的模型</h3><ol><li><p>安装 hexo helper live2d插件</p><p><code>npm install --save hexo-helper-live2d</code></p></li><li><p>下载live2d仓库中的模型 (下面下载的是<strong>hibiki</strong>模型)</p><p><code>npm install live2d-widget-model-hibiki</code></p><p>如何知道模型库中的模型是效果? 这里给出<a href="https://github.com/xiazeyu/live2d-widget-models">模型库</a>，并提供该库中模型的<a href="https://huaji8.top/post/live2d-plugin-2.0/">在线浏览的网址</a>，方便自己选择。</p></li><li><p>在hexo博客中添加配置信息，使用你下载的模型。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">live2d:</span></span><br><span class="line"><span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">scriptFrom:</span> <span class="string">local</span></span><br><span class="line"><span class="attr">model:</span> </span><br><span class="line"><span class="attr">use:</span> <span class="string">live2d-widget-model-hibiki</span> <span class="comment">#模型选择</span></span><br><span class="line"><span class="attr">display:</span> </span><br><span class="line"><span class="attr">position:</span> <span class="string">right</span>  <span class="comment">#模型位置</span></span><br><span class="line"><span class="attr">width:</span> <span class="number">150</span>       <span class="comment">#模型宽度</span></span><br><span class="line"><span class="attr">height:</span> <span class="number">300</span>      <span class="comment">#模型高度</span></span><br><span class="line"><span class="attr">mobile:</span> </span><br><span class="line"><span class="attr">show:</span> <span class="literal">false</span>      <span class="comment">#是否在手机端显示</span></span><br><span class="line">  <span class="attr">react:</span></span><br><span class="line"><span class="attr">opacity:</span> <span class="number">1</span> <span class="comment"># 透明度设置（1为不透明）</span></span><br></pre></td></tr></table></figure><p>然后hexo s 。就可以看到挂件在博客中的效果了。<img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20210811191634.png" alt="image-20210808235427984"></p></li></ol><p>但是，你可能觉得上面提供可以直接下载的模型比较少，像找一些其他人提供的模型，下载，然后配置进去。这就是本文要说明的情况。</p><h2 id="配置自己下载的模型"><a href="#配置自己下载的模型" class="headerlink" title="配置自己下载的模型"></a>配置自己下载的模型</h2><ol><li><p>下载自己喜欢的模型（目前hexo中的live2d是Live2d Cubism 2 ，Live2d Cubism 3的模型不支持）</p><p>这里提供一个<a href="https://github.com/imuncle/live2d">模型库</a></p></li></ol><ol start="2"><li><p>将自己下载好的模型配置到博客中</p><p>a. 在博客根目录下新建 live2d_models目录</p><p>b. 将下载好的模型解压，丢到live2d_models目录中，同时保证模型的文件夹名和模型目录下的.model.json文件名一致<img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20210811191634.png" alt="image-20210809001404469"></p><p>c. 设置博客配置文件_config中live2d配置下的use的值为模型文件夹名。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">live2d:</span></span><br><span class="line"><span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">scriptFrom:</span> <span class="string">local</span></span><br><span class="line"><span class="attr">model:</span> </span><br><span class="line"><span class="attr">use:</span> <span class="string">Violet</span> <span class="comment">#模型选择</span></span><br><span class="line"><span class="attr">display:</span> </span><br><span class="line"><span class="attr">position:</span> <span class="string">right</span>  <span class="comment">#模型位置</span></span><br><span class="line"><span class="attr">width:</span> <span class="number">150</span>       <span class="comment">#模型宽度</span></span><br><span class="line"><span class="attr">height:</span> <span class="number">300</span>      <span class="comment">#模型高度</span></span><br><span class="line"><span class="attr">mobile:</span> </span><br><span class="line"><span class="attr">show:</span> <span class="literal">false</span>      <span class="comment">#是否在手机端显示</span></span><br><span class="line">  <span class="attr">react:</span></span><br><span class="line"><span class="attr">opacity:</span> <span class="number">1</span> <span class="comment"># 透明度设置（1为不透明）</span></span><br></pre></td></tr></table></figure></li><li><p>hexo s。即可在本地查看效果<img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20210809002410.png" alt="image-20210809002410227"></p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 博客美化 </tag>
            
            <tag> live2d </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Webots2019a revision1下naoqisim连接Nao</title>
      <link href="/2021/08/10/webots2019a-revision1%E4%B8%8Bnaoqisim%E8%BF%9E%E6%8E%A5Nao/"/>
      <url>/2021/08/10/webots2019a-revision1%E4%B8%8Bnaoqisim%E8%BF%9E%E6%8E%A5Nao/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前我在Webots7.4.3上进行过Nao的仿真。（具体如何构建此仿真环境可以参考<a href="https://www.codenong.com/cs105901615/%EF%BC%89%E3%80%82">https://www.codenong.com/cs105901615/）。</a></p><p>Webots7.4.3上Nao的naoqi版本是1.14.3，走起路容易摔倒，左转、右转也转不到位。所以想试试Webots新版下，会不会优化的好一些，毕竟naoqi升级到了2.1.4。</p><p>结论：</p><p>得益于naoqi大版本的升级，效果还是挺明显的。在同样一个场景下，机器人走路再也没有摔倒过，摇晃也基本没有。左右转、后转比之前有好转，有时能够转到位，有时没有办法转到位，但是比以前到达预期位置的误差角度小多了。</p><hr><p>在Webots 2019a revision 1下，使用Naoqi控制虚拟环境中的Nao机器人。</p><p>平台：windows10</p><h2 id="编译Naoqisim，并导入到Webots中"><a href="#编译Naoqisim，并导入到Webots中" class="headerlink" title="编译Naoqisim，并导入到Webots中"></a>编译Naoqisim，并导入到Webots中</h2><p>naoqisim是Nao机器人在Webots平台上的controller。</p><p>准备材料：</p><ol><li>naoqisim源码</li><li>MSYS2——window下的包管理软件，用来安装一些库或软件（gcc、make等）</li><li>Microsoft Visual Studio C++ 2010 Express</li></ol><blockquote><p>第三个文件不好下载。网上大部分给的都是在线安装的exe，容易出问题退出。</p><p>这里给一个目前（2021年）可以用的下载教程（<a href="https://blog.csdn.net/baojining/article/details/117433410?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-10.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-10.control">Visual c++ 2010 express 学习版离线安装方法</a>）。</p></blockquote><p>步骤：</p><ol><li>首先，使用MYSY2进入下载好的naoqisim根目录下，执行make。脚本会自动下载Nao Simulator SDK并安装。</li><li>然后，使用下载的Visual Studio 2010 打开controllers/naoqisim/naoqisim.sln`,进行编译，这样就得到了naoqisim这个controller。</li><li>接着，将naoqisim根目录下的aldebaran文件夹（其中有SDK）复制到Webots下的<code>projects/robots/softbank/nao/</code>目录中，再将刚才编译的<code>controllers/naoqisim</code>文件夹复制到<code>projects/robots/softbank/nao/controllers/</code>下。</li><li>最后，打开适用于nao机器人的world文件，在场景数中找到Nao机器人元素，设置其中的contorller和naoqi运行的端口（见下图）。<img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20210810001737.png" alt="image-20210810001130466"></li></ol><h2 id="Troubleshooting"><a href="#Troubleshooting" class="headerlink" title="Troubleshooting"></a>Troubleshooting</h2><ol><li><p>MSYS2如何进入到你下载好的naoqisim目录。</p><p>如何你打开MYSY2 console，<code>pwd</code>发现是在<code>/home/[Username]</code>目录。</p><p>写绝对路径，来访问吧。</p><p><code>cd /c/User/[Username]/Downlaods/naoqisim-master</code></p><blockquote><p>注意这里，是linux下的文件分割符“/”，同时盘符前需要加“/”。</p></blockquote></li><li><p>在naoqisim目录下，make。提示command not found；</p><p><code>pacman -S make</code></p><p><code>pacman -S unzip</code>(我系统下这个也没有，make不下去了)</p></li><li><p>再次make，报错</p><p>从错误前的log信息可以看出此时simulator-sdk已经有了。报错主要是应为controller的问题。就是说controlelr中编译有问题。</p><p>naoqisim项目的readme文件，提示我们。有了sdk之后，需要在vs2010中打开项目来编译controller</p></li><li><p>vs2010中打开naoqisim.sln，生成。再次报错 error MSB8008。</p><p>按照这个博客的方法（<a href="https://blog.csdn.net/liuqiyao_01/article/details/38656873%EF%BC%89%EF%BC%8C%E5%B0%86%E5%B9%B3%E5%8F%B0%E5%B7%A5%E4%BD%9C%E9%9B%86%E8%AE%BE%E7%BD%AE%E4%B8%BAv100%EF%BC%8C%E5%8D%B3%E4%BD%BF%E7%94%A8VS2010%E6%89%93%E5%BC%80%E5%B7%A5%E7%A8%8B%E3%80%82">https://blog.csdn.net/liuqiyao_01/article/details/38656873），将平台工作集设置为v100，即使用VS2010打开工程。</a></p></li></ol><h2 id="温馨提示"><a href="#温馨提示" class="headerlink" title="温馨提示"></a>温馨提示</h2><p>choregraphe要装对应版本的，也就是2.1.4，新版本无法连接虚拟环境中的Nao。</p>]]></content>
      
      
      <categories>
          
          <category> Nao开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nao </tag>
            
            <tag> Webots </tag>
            
            <tag> naoqisim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python下包管理与虚拟环境</title>
      <link href="/2021/08/07/python%E4%B8%8B%E5%8C%85%E7%AE%A1%E7%90%86%E4%B8%8E%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"/>
      <url>/2021/08/07/python%E4%B8%8B%E5%8C%85%E7%AE%A1%E7%90%86%E4%B8%8E%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>使用python，我们经常需要安装一些我们库/包，基于这些库提供的函数来构建自己的程序。这个时候就需要知道怎么来安装这些库。</p><p>并且我们在开发过程中，不同的项目用到的python版本不一致，如果直接在系统下安装python环境，在开发不同项目时安装库会因为python的版本问题产生冲突，而常用的方式是为每个项目创建env虚拟环境，在虚拟环境中安装项目需要的python版本和对应版本的库。每个项目使用自己的虚拟环境，自然不会产生冲突。</p><h2 id="包安装"><a href="#包安装" class="headerlink" title="包安装"></a>包安装</h2><blockquote><p>注意python在安装包时需要首先知道python的版本（python2/python3）和位数（32/64位）</p><p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/image-20210625152102894.png" alt="image-20210625152102894"></p><p>包下载之前，先将<code>pip</code>和<code>setuptools</code>包更新到最新，减少包安装过程中的错误。</p></blockquote><h3 id="pip安装"><a href="#pip安装" class="headerlink" title="pip安装"></a>pip安装</h3><p>python安装后默认就带有pip包管理工具</p><h6 id="1-配置pip包的国内源"><a href="#1-配置pip包的国内源" class="headerlink" title="1. 配置pip包的国内源"></a>1. 配置pip包的国内源</h6><p>pip默认的包资源都是通过国外的pip官方网站，国内使用网速不好。因此，使用国内的镜像网站（清华pip源、豆瓣pip源）下载更加高效。</p><p><code>pip config set global.index-url http://mirrors.aliyun.com/pypi/simple</code></p><p><code>pip config set global.trusted-host mirrors.aliyun.com</code></p><p>or</p><p><code>pip config set global.index-url https://mirrors.aliyun.com/pypi/simple</code></p><h6 id="2-pip安装第三方包"><a href="#2-pip安装第三方包" class="headerlink" title="2. pip安装第三方包"></a>2. pip安装第三方包</h6><p>pip search xxx</p><blockquote><p>pip search 命令已被弃用。现在需要安装 pip-search包，使用<code>pip_search xxx</code></p></blockquote><p><code>pip install xxx</code></p><p><code>pip install xxx==1.01</code></p><blockquote><p>pip install 安装python相关包时，常常会由于网络问题，导致超时，下载失败，而且换成国内源的时候，也有可能出现这种情况。这个时候可以通过修改timeout加长download的下载时间，缓解超时的问题：<code>--timeout=100</code></p><p>pip install -i <a href="http://mirrors.aliyun.com/pypi/simple">http://mirrors.aliyun.com/pypi/simple</a> –trusted-host mirrors.aliyun.com 指定镜像源</p></blockquote><p><code>pip list</code>   列出当前已安装的第三方包</p><p><code>pip install --upgrade xxx</code> 更新包</p><p><code>pip  uninstall xxx</code> 卸载包</p><p><code>pip show xxx</code> 查看安装好的包信息</p><p><code>pip -V </code>查看当前使用的pip的版本和位置</p><h3 id="whell安装"><a href="#whell安装" class="headerlink" title="whell安装"></a>whell安装</h3><p>wheel文件本质上就是zip或者rar,只不过它更加方便python的安装以及使用</p><ol><li><p>下载xxx包的压缩文件xxx.whl</p></li><li><p>pip install xxx.whl</p></li></ol><blockquote><p>一般的包的whell文件都有收录在pypi.org中收录，所以从pypi下载即可。</p></blockquote><h3 id="source源码安装"><a href="#source源码安装" class="headerlink" title="source源码安装"></a>source源码安装</h3><ol><li><p>下载xxx包的源码文件</p></li><li><p>python setup.py install</p></li></ol><p><strong>说明</strong>：</p><p>其实当我们使用pip安装时，都是whl和source的安装方式，只不过是pip命令自动帮我们下载whl文件或源码，然后自动安装。可以仔细看一下pip install过程中输入的console信息。</p><h2 id="虚拟环境"><a href="#虚拟环境" class="headerlink" title="虚拟环境"></a>虚拟环境</h2><h3 id="Conda-包管理-虚拟环境"><a href="#Conda-包管理-虚拟环境" class="headerlink" title="Conda: 包管理 + 虚拟环境"></a>Conda: 包管理 + 虚拟环境</h3><h4 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h4><p>配置国内源</p><pre><code>添加：conda config --add channels https://mirrors.aliyun.com/pypi/simple/删除：conda config --remove channels https://mirrors.aliyun.com/pypi/simple/查看源：conda config --show-sourcec</code></pre><ul><li><p>查看安装的包： conda list</p></li><li><p>安装包：</p><p>conda search xxx</p><p>conda install xxx</p></li></ul><h4 id="虚拟环境-1"><a href="#虚拟环境-1" class="headerlink" title="虚拟环境"></a>虚拟环境</h4><p>创建虚拟环境：conda create –name envname python=2.7.10</p><blockquote><p>如何创建不同位数的python环境？</p><p>![image-20210720225219101](/Users/lifeisbinary/Library/Application Support/typora-user-images/image-20210720225219101.png)</p></blockquote><p>进入虚拟环境：conda activate envname</p><p>退出当前虚拟环境：conda deactivate</p><p>查看当前存在的虚拟环境：conda env list</p><p>删除虚拟环境 ：conda env remove -n envname</p><blockquote><p>有些包在conda的虚拟环境中安装后，在导入时会出现<code>SystemError: dynamic module not initialized properly</code>的错误，但是virtualenv创建的环境中却没有问题。如qi库（softbank机器人库），不知道怎么回事</p><p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20210808001202.png" alt="image-20210615005905639"></p></blockquote><p><strong>虚拟环境（env）迁移：</strong></p><p>场景：想将conda创建env环境,copy到另一台同样操作系统的电脑上，方便继续在新电脑上开发。</p><p>首先要明白，迁移的内容是env环境，而env中安装过的库的pkg都在<code>anaconda/pkgs</code>目录下，因此迁移时，需要将env和库的pkg复制到另一台需要创建同样环境的电脑上。</p><blockquote><p>复制pkg后，就不需要在新电脑上重新下载了，会快很多。</p></blockquote><p>步骤如下：</p><ol><li><p>复制 <code>anaconda\envs</code>目录下需要拷贝的虚拟环境文件夹到新电脑上</p></li><li><p>复制<code>anaconda\pkgs</code>目录下的内容到新电脑上的<code>anaconda\pkgs</code>下。</p></li><li><p>通过 拷贝的虚拟环境 来构建新电脑上的虚拟环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create -n 新建虚拟环境名字 --clone path/to/要拷贝的虚拟环境名字 --offline</span><br></pre></td></tr></table></figure></li></ol><h3 id="virtualenv"><a href="#virtualenv" class="headerlink" title="virtualenv"></a>virtualenv</h3><p><code>virtualenv envname</code> 创建</p><p>运行envname\Script\acitvate来激活虚拟环境</p><p><code>deactivate</code> 推出虚拟环境</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://ckfanzhe.github.io/About_conda/">https://ckfanzhe.github.io/About_conda/</a></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 包管理 </tag>
            
            <tag> 虚拟环境 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提升效率的Windows 虚拟桌面（转载）</title>
      <link href="/2021/08/06/%E6%8F%90%E5%8D%87%E6%95%88%E7%8E%87%E7%9A%84Windows-%E8%99%9A%E6%8B%9F%E6%A1%8C%E9%9D%A2%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/"/>
      <url>/2021/08/06/%E6%8F%90%E5%8D%87%E6%95%88%E7%8E%87%E7%9A%84Windows-%E8%99%9A%E6%8B%9F%E6%A1%8C%E9%9D%A2%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>本文转载自少数派作者<a href="https://sspai.com/u/u9vvthsl/updates">火箭君CC</a>的文章，如果喜欢可以去点赞支持。</p><hr><div data-v-3e67f99b="" class="content wangEditor-txt minHeight"><p>Windows 10 发布后，微软终于在自家的操作系统里面内置了<strong>虚拟桌面</strong>功能，而这是 macOS 上早已标配的功能。</p><p>这个功能确实有很强的需求，在没有虚拟桌面之前，对于主力设备是 Windows 的我来说，经常要频繁切换浏览器、日历软件、任务管理软件、聊天软件和邮件客户端……的窗口。窗口之间的重合交叠让人感到「邋遢」和不爽：</p><p></p><figure tabindex="0" class="ss-img-wrapper"><img src="https://cdn.sspai.com/2018/07/27/f5c41ef192c5fdea3d1aeed855cd0573.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="窗口重合交叠的屏幕" title="窗口重合交叠的屏幕" data-original="https://cdn.sspai.com/2018/07/27/f5c41ef192c5fdea3d1aeed855cd0573.png" data-index="0" class="lazyLoadEnd"><figcaption class="ss-image-caption">窗口重合交叠的屏幕</figcaption></figure><p></p><p>虽然说「切换窗口任务」只是按按手指的事情，但是思路却很可能被打断。例如，我正要写一封邮件给 Anna，可能会有以下几件事发生：</p><ol><li>当我想查找之前对话记录时，我要从任务栏的编辑/网页/文件管理器……一堆窗口中挑选一个聊天窗口并点击打开。</li><li>看了聊天后，我突然意识到日程还要定一下，才能通知 Anna，于是再到任务栏的一堆窗口里找日历窗口。</li><li>等我找齐了窗口，弄清了事情，还要重新切换回邮件窗口，等等，我本来想和 Anna 说什么来着？</li></ol><p>一个比较理想的解决方法是：多买几个显示器。这样，你可以把 Windows 桌面扩展到好几个屏幕上。每个屏幕都平铺几个任务窗口备用，扭扭自己的脖子就能「切换」桌面。</p><p>而有了虚拟桌面的功能之后，你也许可以先省下这笔买显示器扩展桌面的预算。</p><h2 id="ss-2-1532922472046" class="ss-hId-1" hid="ss-hId-1">虚拟桌面能干什么？</h2><p>每个虚拟桌面可以被看成是一个独立的工作空间（Workspace）。</p><p>每创建一个虚拟桌面，就像打开了一个新的工作空间。在新的空间中，你能够开启一套完全不同的任务，而不用担心和以前的任务窗口混杂陈列。</p><p></p><figure tabindex="0" class="ss-img-wrapper"><img src="https://cdn.sspai.com/2018/07/10/9a2d8967d19026baf1a5f3fccde00945.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="虚拟桌面的管理界面" title="虚拟桌面的管理界面" data-original="https://cdn.sspai.com/2018/07/10/9a2d8967d19026baf1a5f3fccde00945.png" data-index="1" class="lazyLoadEnd"><figcaption class="ss-image-caption">虚拟桌面的管理界面</figcaption></figure><p></p><p>在使用过程中，我发现三个桌面恰到好处。 我称之为<strong>「三桌面流」 </strong>，这三个桌面分别是：</p><ul><li><strong>工作桌面</strong>：用于放置 开发/创作等编辑器 等软件的窗口</li><li><strong>参考桌面</strong>：用于放置 GTD / 日历 / 参考笔记 等软件的窗口</li><li><strong>通讯桌面</strong>：用于放置 微信 / Slack / 邮件 等软件的窗口</li></ul><p>这样一来，当我要专注创作时，我根本不用关心，也看不到另两个桌面上的窗口内容。当我需要参考信息时直接切换到「参考桌面」即可，上面已经是前次打开状态的参考窗口，不用再去任务栏找窗口了。 想找人微信商量事也一样，直接切换到「通讯桌面」，已经打开的微信窗口，就在那里等着我。</p><p>很大程度上，<strong>避免了频繁最大化、最小化、切换窗口带来的「打断感」</strong>。</p><p></p><figure tabindex="0" class="ss-img-wrapper"><img src="https://cdn.sspai.com/2018/07/12/5faf306b3254fc37ed03d6a5da9f68bb.gif" alt="「三桌面流」的一个例子" title="「三桌面流」的一个例子" data-original="https://cdn.sspai.com/2018/07/12/5faf306b3254fc37ed03d6a5da9f68bb.gif" data-index="2" class="lazyLoadEnd"><figcaption class="ss-image-caption">「三桌面流」的一个例子</figcaption></figure><p></p><h2 id="ss-2-1532922472046" class="ss-hId-2" hid="ss-hId-2">虚拟桌面怎么用？</h2><p>Windows 10 的虚拟桌面虽好，但启动入口略有些隐蔽。以下是几种常用的启动和切换虚拟桌面的方式：</p><h3 id="ss-3-1532922472046" class="ss-hIdChildren-1">可视化入口</h3><p>如果想要启动虚拟桌面的话，最直观的入口就是 <strong>Windows 任务栏上的「任务视图」按钮</strong>。根据我的观察，不同的 Windows10 迭代版本下，这个小按钮会略有不同。</p><ol><li><p>首先，这个按钮需要在 Windows 任务栏上右键呼出菜单，从中选择「显示“任务视图”按钮」才行。</p><p> </p><figure tabindex="0" class="ss-img-wrapper"><img src="https://cdn.sspai.com/2018/07/10/f78c01014a9fee3d1e9533aa274fdd6d.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="打开「任务视图」按钮选项" title="打开「任务视图」按钮选项" width="380" data-original="https://cdn.sspai.com/2018/07/10/f78c01014a9fee3d1e9533aa274fdd6d.png" data-index="3" class="lazyLoadEnd"><figcaption class="ss-image-caption">打开「任务视图」按钮选项</figcaption></figure><p></p></li><li><p>然后，任务栏上会出现这样的图标。</p><p> </p><figure tabindex="0" class="ss-img-wrapper"><img src="https://cdn.sspai.com/2018/07/10/436692fe5affe51b1ac7e189c5f8b14f.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="「任务视图」按钮" title="「任务视图」按钮" width="380" data-original="https://cdn.sspai.com/2018/07/10/436692fe5affe51b1ac7e189c5f8b14f.png" data-index="4" class="lazyLoadEnd"><figcaption class="ss-image-caption">「任务视图」按钮</figcaption></figure><p></p></li><li><p>一旦点击，就会出现「任务视图」，从中就可以切换或创建 「虚拟桌面」了。</p><p> </p><figure tabindex="0" class="ss-img-wrapper"><img src="https://cdn.sspai.com/2018/07/12/79ea65bd16d88f2022420a0af2281118.gif" alt="来自微软官方支持站点的演示" title="来自微软官方支持站点的演示" width="380" data-original="https://cdn.sspai.com/2018/07/12/79ea65bd16d88f2022420a0af2281118.gif" data-index="5" class="lazyLoadEnd"><figcaption class="ss-image-caption">来自微软官方支持站点的演示</figcaption></figure><p></p></li></ol><h3 id="ss-3-1532922472046" class="ss-hIdChildren-2">快捷键入口</h3><p>如果，我正在进行打字编辑类的键盘操作，一般我会采用<strong>快捷键</strong>的方式来切换虚拟桌面。</p><p>快捷键可以让我操作更流畅，双手不会因为「切换」这个动作而随便离开键盘，然后再度返回键盘，造成打断。</p><p>比起可视化入口的操作，以下 5 个「快捷键」可能会实用许多：</p><ol><li><code>Win 键-Tab</code>：打开「任务视图」，相当于点击「可视化入口」。</li><li><code>Win 键-Ctrl-D</code>：创建新的虚拟桌面。</li><li><code>Win 键-Ctrl-F4</code>：删除当前虚拟桌面。</li><li><code>Win 键-Ctrl-左键</code>：切换到相邻左侧的虚拟桌面。</li><li><code>Win 键-Ctrl-右键</code>：切换到相邻右侧的虚拟桌面。</li></ol><p>其中，第 4 和第 5 这两个快捷键尤为实用，几乎相当于传说中的 Boss 键了，如果老板来了，可以让人立刻从「放羊」桌面切换到「工作」桌面。</p><h2 id="ss-2-1532922472047" class="ss-hId-4" hid="ss-hId-4">写在最后</h2><p>相信看到这里，每个人心里都有一套划分自己虚拟桌面创建工作空间（Workspace）的想法。如果没有想法，可以先试试上文中提到的「三桌面流」（即工作桌面、参考桌面、通讯桌面），也许能打开一些思路。</p><p>&gt; 下载 <a href="http://sspai.com/s/nqQk" title="少数派 iOS 客户端">少数派 iOS 客户端</a>、关注 <a href="http://sspai.com/s/KEPQ" title="少数派公众号">少数派公众号</a>，了解更多实用的技巧 💡</p>]]></content>
      
      
      <categories>
          
          <category> 电脑使用tips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> win </tag>
            
            <tag> 虚拟桌面 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac To Win | 不完全迁移体验指北(转载)</title>
      <link href="/2021/08/05/Mac-To-Win-%E4%B8%8D%E5%AE%8C%E5%85%A8%E8%BF%81%E7%A7%BB%E4%BD%93%E9%AA%8C%E6%8C%87%E5%8C%97/"/>
      <url>/2021/08/05/Mac-To-Win-%E4%B8%8D%E5%AE%8C%E5%85%A8%E8%BF%81%E7%A7%BB%E4%BD%93%E9%AA%8C%E6%8C%87%E5%8C%97/</url>
      
        <content type="html"><![CDATA[<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>本文转载自少数派作者<a href="https://sspai.com/u/spencerwoo/updates">SpencerWoo</a>的文章，如果喜欢可以去点赞支持。</p><hr><div data-v-3e67f99b="" class="content wangEditor-txt minHeight"><p>操作系统的变迁，很多人都会遇到：</p><ul><li>学生因为专业软件不适配 macOS，只能使用 Windows；</li><li>上班族由于业务需求，必须从使用多年的 macOS 切换到 Windows；</li><li>……</li></ul><p>最近，我也将自己的全部家当从 macOS 迁移到了 Windows，开始了从一个系统切换到另一个系统的「折腾」。作为曾经的 macOS 用户，我用它完成了很多工作，现在我依然喜欢这个优秀、有设计感的系统。但与此同时，出于对部分专业软件的需求，也为了性能提升和接口兼容，我将服役两年有余的 12 寸 MacBook 淘汰，迁移到了 Windows 平台，开始拥抱 Windows 的生态圈。🐾</p><h2 class="ss-hId-1" hid="ss-hId-1">我怀念 macOS 的哪些功能</h2><p>从 macOS 迁移到 Windows 的过程中，必然有体验上的差别，下面这些在 Apple 生态系统中使用 Mac 的体验让我尤其怀念：</p><ul><li><strong>桌面美学：</strong>macOS 具有设计感的桌面和 Dock</li><li><strong>macOS 系统原生工具的体验：</strong></li><ul><li>空格键「预览（Quicklook）」</li><li>「Handoff」、「Airdrop」等与其他苹果设备的无缝联动</li><li>方便的原生截图、窗口检测与有质感的背景阴影</li></ul>* macOS 上的效率工具：  <ul><li>全局启动器 Alfred（或者原生的 Spotlight）</li><li>类似 iPic 的图床工具</li><li>各路体验优秀的 Markdown 写作工具</li></ul><ul><li><strong>开发环境：</strong>得益于 macOS 类 Unix 系统的属性而有的一套可以媲美 Linux 的开发环境（比如 <code>Homebrew</code> 与原生的 <code>git</code> 和 <code>ssh</code>）</li></ul><p>那么在使用 Windows 与 iPhone 的时候，我能不能找回一些如此顺滑的体验呢？我在 Windows 上做了这样的折腾。 🐟</p><h2 class="ss-hId-2" hid="ss-hId-2">在 Windows 上的折腾</h2><p id="ss-P-1532595188277">针对前面提到的桌面美学、系统工具、效率工具和开发环境这四个方面，我分别针对性地用了不同的工具来尝试性地还原 macOS 上的体验。</p><figure><br><img src="https://cdn.sspai.com/minja/2018-07-24-Wox.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="" data-original="https://cdn.sspai.com/minja/2018-07-24-Wox.png" data-index="0" class="lazyLoadEnd"></figure><h3 class="ss-hIdChildren-1">设计桌面</h3><p>Apple 是一家标榜设计的公司，macOS 的桌面美学确实让包括我在内的很多人赞叹。当然，我在使用 Windows 的这一周以来，发现经过 Fluent Design 重新设计的 Windows 10 也相比之前的老一代 Windows 有着巨大的美学改善。进一步借助下面这些小工具和，我找回了不输 macOS 的美观桌面。</p><figure tabindex="0" draggable="false" class="ss-img-wrapper" contenteditable="false"><img src="https://cdn.sspai.com/minja/2018-07-24-%E6%88%91%E7%9A%84%E6%A1%8C%E9%9D%A2.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="" data-original="https://cdn.sspai.com/minja/2018-07-24-%E6%88%91%E7%9A%84%E6%A1%8C%E9%9D%A2.png" data-index="1" class="lazyLoadEnd"><figcaption class="ss-image-caption">我的桌面</figcaption></figure><h4>① <a href="https://github.com/TranslucentTB/TranslucentTB/">TranslucentTB</a>：开源的任务栏透明工具&nbsp;</h4><p>美化桌面的步骤中，必不可少修改任务栏，改掉它不透明的生硬效果。有人会选择修改注册表，这不仅很危险，还只能将任务栏半透明化，而另外一些如 StarDock 的美化软件又很占内存。这个开源的 TranslucentTB 则不然，既小巧、不占内存、还可以将任务栏透明、半透明、模糊、或是直接显示纯色，可以说是功能全面了。<b>显示效果就像上图那样，能够完整的呈现我们的壁纸而不必担心任务栏挡掉一部分。</b></p><h4>②&nbsp;<a href="https://www.rainmeter.net/" target="_blank" class="insert-link">Rainmeter</a>：Windows 桌面美化插件</h4><p>对于深度美化 Windows 桌面的同学来说，Rainmeter 的重要性可想而知。在 Rainmeter 的 <a href="https://www.rainmeter.net/">官网</a>、<a href="https://forum.rainmeter.net/">官方用户社区</a>、和 <a href="https://www.deviantart.com/rainmeter">DeviantArt 设计站点</a>，都有大量设计精美的 Rainmeter 插件，但是我也并不推荐将插件直接堆砌在桌面上，一团糟的样子不仅不美观，还占用了大量的系统资源。<b>我只小小利用了其桌面时钟、日期的显示。</b></p><figure tabindex="0" draggable="false" class="ss-img-wrapper" contenteditable="false"><img src="https://cdn.sspai.com/minja/2018-07-24-02_Rainmeter.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="" data-original="https://cdn.sspai.com/minja/2018-07-24-02_Rainmeter.png" data-index="2" class="lazyLoadEnd"><figcaption class="ss-image-caption">Rainmeter</figcaption></figure><p>我目前使用的 Rainmeter 主题在这里可以下载到 → <a href="https://www.deviantart.com/lilshizzy/art/Rainmeter-Elegance-2-244373054">Rainmeter Elegance 2.0</a></p><h4>③ <a href="http://simpledesktops.com/browse/">Simple Desktops</a>：壁纸提供站</h4><p>美化桌面方面，壁纸可以说是重中之重。一张简单可爱的壁纸可以奠定整个工作的态度。在 Simple Desktops 里我总能找到可爱的壁纸。</p><figure tabindex="0" draggable="false" class="ss-img-wrapper" contenteditable="false"><img src="https://cdn.sspai.com/minja/2018-07-24-03_Simple%20Desktop.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="" data-original="https://cdn.sspai.com/minja/2018-07-24-03_Simple%20Desktop.png" data-index="3" class="lazyLoadEnd"><figcaption class="ss-image-caption">Simple Desktop</figcaption></figure><p>除此之外，无版权图片社区 <a href="https://unsplash.com">Unsplash</a>、免费图片社区 <a href="https://pixabay.com/zh/">Pixabay</a>、甚至是必应每日壁纸等等都是优秀的壁纸来源。</p><h4>④ 文件管理和日常清理的习惯</h4><p>简洁的文件管理、不复杂凌乱的桌面和常清理的使用习惯自然会让你的 Windows 使用体验蒸蒸日上。💗</p><p>参考：《<a href="https://sspai.com/series/13" target="_blank" class="insert-link">每个人都应该学会正确管理文件</a>》（<span style="font-family: &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif; font-size: 16px;">少数派付费教程</span>）</p><h3 class="ss-hIdChildren-2">系统工具</h3><h4>① <a href="https://github.com/Wox-launcher/Wox">WoX</a>&nbsp;和 <a href="https://www.voidtools.com/">Everything</a>：启动器工具</h4><figure tabindex="0" draggable="false" class="ss-img-wrapper" contenteditable="false"><img src="https://cdn.sspai.com/minja/2018-07-24-Wox.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="" data-original="https://cdn.sspai.com/minja/2018-07-24-Wox.png" data-index="4" class="lazyLoadEnd"><figcaption class="ss-image-caption">Wox</figcaption></figure><p>WoX 是 Windows 上大名鼎鼎的开源启动器，我派对它有详尽的介绍 → 在<a href="https://sspai.com/post/33460">这里</a>。</p><p>WoX 的看家功夫是基于 Everything 的基本文件搜索功能，它能在不到一秒钟的时间内将你想要的文件进行搜索并展现出来，快如闪电，当然这也包括将你要打开的应用快捷方式搜索出来，因而 WoX 可以充当应用程序的快捷启动器。除此之外，WoX 还可以调用计算器、预览颜色、打开控制面板的某项选项、直接调用搜索引擎搜索内容和直接运行 Shell 命令等等，而这些功能都归功于其强大的 Plugin 插件功能。当然 WoX 也提供了外观主题的定制功能。</p><p>WoX 和 Everything 两工具的完美结合，在使用体验上可以媲美 macOS 上的 Spotlight、Alfred 等效率启动器。</p><h4>② QuickLook ：空格键预览工具</h4><figure tabindex="0" draggable="false" class="ss-img-wrapper" contenteditable="false"><img src="https://cdn.sspai.com/minja/2018-07-24-05_QuickLook.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="" data-original="https://cdn.sspai.com/minja/2018-07-24-05_QuickLook.png" data-index="5" class="lazyLoadEnd"><figcaption class="ss-image-caption">QuickLook</figcaption></figure><p>macOS 上的「一指禅」—— 空格预览文件内容，绝对是一个经典、令人印象深刻的功能。在 Windows 上，QuickLook 可以实现空格预览的功能，并且支持的格式也很丰富，能够预览图片、文本、docx 文档、甚至是各种源码等等一系列文件。macOS 一指禅在 Windows 上也能完美践行了。🦄</p><figure tabindex="0" draggable="false" class="ss-img-wrapper" contenteditable="false"><img src="https://cdn.sspai.com/minja/2018-07-24-%E7%A9%BA%E6%A0%BC%E9%A2%84%E8%A7%88%E5%9B%BE%E7%89%87%E3%80%81%E6%96%87%E6%9C%AC%E5%92%8C%20Markdown.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="" data-original="https://cdn.sspai.com/minja/2018-07-24-%E7%A9%BA%E6%A0%BC%E9%A2%84%E8%A7%88%E5%9B%BE%E7%89%87%E3%80%81%E6%96%87%E6%9C%AC%E5%92%8C%20Markdown.png" data-index="6" class="lazyLoadEnd"><figcaption class="ss-image-caption">空格预览图片、文本和 Markdown</figcaption></figure><p>QuickLook 可以直接在 Windows 应用商店免费下载得到。</p><h4>③&nbsp;<a href="http://clipber.com/" target="_blank" class="insert-link">快贴</a>：云剪贴板工具<br></h4><p>快贴是一个免费的跨平台的剪贴板同步工具，能够在多端设备同步剪贴板，并对剪贴板涉密内容进行自动识别、加密传输。</p><figure tabindex="0" draggable="false" class="ss-img-wrapper" contenteditable="false"><img src="https://cdn.sspai.com/minja/2018-07-24-%E5%BF%AB%E8%B4%B4.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="" data-original="https://cdn.sspai.com/minja/2018-07-24-%E5%BF%AB%E8%B4%B4.jpg" data-index="7" class="lazyLoadEnd"><figcaption class="ss-image-caption">快贴</figcaption></figure><p>我在 iOS 和 Windows 端同时下载了快贴，在 iOS 保持后台运行的情况下，我在手机上复制的内容，能够很快的同步到云端，进而在 Windows 端能够粘贴。但是这个过程比 macOS 繁琐的地方在于，我需要通过全局快捷键来手动触发粘贴端的同步，这样的多一步操作虽说影响体验，也肯定不如 macOS 闭源的生态系统好，但是至少我不必用微信、QQ 之流当作我电脑与手机沟通的渠道了。</p><p>参考：<a href="https://sspai.com/post/43775" target="_blank" class="insert-link" style="font-family: &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif; font-size: 16px; font-style: inherit; font-variant-caps: inherit;">好用的全平台剪切板工具，我们为你找到了这&nbsp;3&nbsp;款</a></p><h4>④ <a href="https://send-anywhere.com/file-transfer">Send Anywhere</a>：文件传输工具</h4><p>Send Anywhere 将文件上传到一个 p2p 网络上面，并非其服务器上，接受端通过随机六位接收码进行文件接受。这样的传输方式保证了文件的安全性和完整性，又能有相当的上传、下载和传输速度。Send Anywhere 可以说是全平台 Airdrop 了。</p><figure tabindex="0" draggable="false" class="ss-img-wrapper" contenteditable="false"><img src="https://cdn.sspai.com/minja/2018-07-24-08_Send%20Anywhere.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="" data-original="https://cdn.sspai.com/minja/2018-07-24-08_Send%20Anywhere.jpg" data-index="8" class="lazyLoadEnd"><figcaption class="ss-image-caption">Send Anywhere</figcaption></figure><p>同时 Send Anywhere 有设备记忆功能，在曾经传输过文件的设备上，下一次传输的时候，六位接收码都不必输入。这样的分享文件的特性可以说是跨平台的救命稻草了。我在使用过程中除了在 Windows 平台传输结束之后 Send Anywhere 本身有几次会卡死，其他体验都极佳。</p><p>参考：<a href="https://sspai.com/post/40047" target="_blank" class="insert-link" style="font-family: &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif; font-size: 16px; font-style: inherit; font-variant-caps: inherit;">免费全平台的文件分享利器：SendAnywhere</a></p><h3 class="ss-hIdChildren-3">效率工具</h3><h4>① smpic：sm.ms 图床上传软件</h4><p>我的博客图片全部都放到了第三方的图床上面，这让我需要有一个便捷的图片上传途径。</p><p>smpic 通过 SM.MS 图床的 API 与大名鼎鼎的 AutoHotKey 脚本实现了这样的图片上传利器，我将快捷键绑定为 <code>Ctrl</code> + <code>Alt</code> + <code>U</code>，这样点击图片按下快捷键直接就可以将图片上传至图床，并同时返回相应的图片引用链接，一气呵成。</p><p>smpic 同样，是一款开源、免费的软件，可以在其&nbsp;<a href="https://github.com/kookob/smpic" target="_blank" class="insert-link">Github 页面</a>进行下载。</p><h4>②&nbsp;<a href="https://typora.io/" target="_blank" class="insert-link">Typora</a>： Markdown 编辑器</h4><figure tabindex="0" draggable="false" class="ss-img-wrapper" contenteditable="false"><img src="https://cdn.sspai.com/minja/2018-07-24-09_Typora.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="" data-original="https://cdn.sspai.com/minja/2018-07-24-09_Typora.png" data-index="9" class="lazyLoadEnd"><figcaption class="ss-image-caption">Typora</figcaption></figure><p>Typora&nbsp;不必多说了，基本上是 Windows 上写 Markdown 的必备利器了。我的这篇文章就是在 Windows 的 Typora 上面编写完成的。我派对 Typora 也有详尽的介绍：<a href="https://sspai.com/post/30292">让 Markdown 写作更简单，免费极简编辑器：Typora</a></p><h4>③&nbsp;<a href="https://www.snipaste.com" target="_blank" class="insert-link">Snipaste</a>：截图工具</h4><figure tabindex="0" draggable="false" class="ss-img-wrapper" contenteditable="false"><img src="https://cdn.sspai.com/minja/2018-07-24-10_Snipaste.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="" data-original="https://cdn.sspai.com/minja/2018-07-24-10_Snipaste.png" data-index="10" class="lazyLoadEnd"><figcaption class="ss-image-caption">Snipaste</figcaption></figure><p>Snipaste&nbsp;着实是 Windows 上最好的截图工具。但 Snipaste 除了我们常见的截图标注、窗口检测、全局快捷键等等简朴必备技能，还有贴图、取色等等高阶可玩性。目前 Snipaste 在 Windows 商店就可以下载得到，并且就在最近几天 Snipaste 也发布了 Pro 版本，增加了更多的玩法。</p><figure tabindex="0" draggable="false" class="ss-img-wrapper" contenteditable="false"><img src="https://cdn.sspai.com/minja/2018-07-24-11_Snipaste%20In%20Action.gif" alt="" data-original="https://cdn.sspai.com/minja/2018-07-24-11_Snipaste%20In%20Action.gif" data-index="11" class="lazyLoadEnd"><figcaption class="ss-image-caption">Snipaste In Action</figcaption></figure><p>Snipaste 的开发者对 Snipaste 很是上心，我派单独采访了这位同学，在这里有更加具体的介绍 →&nbsp;<a href="https://sspai.com/post/35097">幕后丨他做了最强免费「截图」工具 Snipaste 后，还有上万字的话想说</a></p><p>上面介绍的工具中，除了 Typora 和图床上传工具 smpic 以外（smpic 因为免安装，所以不支持开机自启动），剩下的都有幸被我加入开机自启动名单。🎉</p><h3 class="ss-hIdChildren-4">开发环境</h3><p>经过近两年的开发，目前 Windows Subsystem For Linux（以下简称 WSL）已经十分完善。我从微软商店下载安装了 Ubuntu 18.04 作为 WSL 的系统，并使用 Ubuntu 下的 <code>aptitude</code> 包管理工具链配置了我的开发环境。安装 WSL 的详细步骤在 →&nbsp;<a href="https://docs.microsoft.com/zh-cn/windows/wsl/install-win10">这里</a>。</p><figure tabindex="0" draggable="false" class="ss-img-wrapper" contenteditable="false"><img src="https://cdn.sspai.com/minja/2018-07-24-12_Ubuntu%20WSL.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="" data-original="https://cdn.sspai.com/minja/2018-07-24-12_Ubuntu%20WSL.png" data-index="12" class="lazyLoadEnd"><figcaption class="ss-image-caption">Ubuntu WSL</figcaption></figure><p>在 WSL 中我安装了我的必备开发工具：</p><ul><li><code>git</code> 代码版本控制</li><li><code>ssh</code> 远程服务器连接 🔗</li><li><code>zsh</code> 与 <code>oh-my-zsh</code> Shell 环境</li></ul><p>在 Windows 中我通过 Hyper 终端环境进行实战。</p><p>Hyper 是一个基于 Election 的终端 Terminal Emulator，是一个插件丰富的、跨平台的终端。我写过一个有关它的详细介绍&nbsp;<a href="https://spencerwoo.com/2018/06/16/Terminal/">HOW TO | 让自己的终端漂亮得不像实力派</a>。在 Windows 下，可以通过 Hyper 调用 WSL 中的 <code>bash.exe</code>，这样就不用面对万恶的小黑框了。😈</p><figure tabindex="0" draggable="false" class="ss-img-wrapper" contenteditable="false"><img src="https://cdn.sspai.com/minja/2018-07-24-13_%C5%92%E2%80%9C%C2%B5%C6%92%C2%B5%C2%B1%C2%AB%E2%88%9E%C3%B8%E2%84%A2%E2%88%91%C2%A2%C2%AA%E2%88%91%C3%A6%E2%89%A5.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="" data-original="https://cdn.sspai.com/minja/2018-07-24-13_%C5%92%E2%80%9C%C2%B5%C6%92%C2%B5%C2%B1%C2%AB%E2%88%9E%C3%B8%E2%84%A2%E2%88%91%C2%A2%C2%AA%E2%88%91%C3%A6%E2%89%A5.png" data-index="13" class="lazyLoadEnd"><figcaption class="ss-image-caption">我当前的开发环境</figcaption></figure><p>这样折腾之后，一套可用的基于命令行的开发环境也处于可用状态了。目前存在的问题是从 Windows 端调用 Linux 内部的指令还是有些问题，比如我在 Visual Studio Code 中试图调用 Linux 环境下的 Python 解释器进行调试就异常麻烦，目前 Visual Studio Code 团队对 C/C++ 和 Node.js 的调试都已经适配完成，至于 Python、Go 等语言，我相信未来的适配也会越来越完善。</p><p>参考：<a href="https://github.com/lloydstubber/my-wsl-setup" target="_blank" class="insert-link" style="font-family: &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif; font-size: 16px; font-style: inherit; font-variant-caps: inherit;">My&nbsp;WSL&nbsp;Setup&nbsp;by&nbsp;lloydstubber</a></p><h2 class="ss-hId-3" hid="ss-hId-3">最后的体验</h2><p>经过这样的折腾，我在 Windows 上面的效率工具和开发环境体验也和 macOS 上的体验已经相差无几，也基本上实现了&nbsp;iPhone&nbsp;和&nbsp;Windows&nbsp;的无缝联动。</p><p>当然，为了习惯去让一个系统无谓地模拟另一个系统的体验是毫无意义的，我找回 macOS 特点的同时也在享受 Windows 的特色功能，比如用 OneDrive 方便地同步我的文件、用手写笔对 PDF 进行标注、在 OneNote 上进行笔记书写，甚至还能用手写笔在 Autodesk SketchBook 中绘画，这些体验都比 macOS 更好。还有一点很重要，Windows 能用上功能完整的 Office 套件。</p><p>现在对我而言，Windows 也有不方便的地方，下载软件开发所需要的依赖就比较麻烦，毕竟它不是原生的 Unix，但综合体验上，无论是美学、还是效率，我给我目前的 Windows 打五星。⭐⭐⭐⭐⭐</p><figure tabindex="0" draggable="false" class="ss-img-wrapper" contenteditable="false"><img src="https://cdn.sspai.com/minja/2018-07-24-14_My%20ThinkPad.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="" data-original="https://cdn.sspai.com/minja/2018-07-24-14_My%20ThinkPad.jpg" data-index="14" class="lazyLoadEnd"><figcaption class="ss-image-caption">我的 ThinkPad</figcaption></figure><p>题图来自 <a href="https://www.freepik.com/free-vector/cloud-storage-concept_1063667.htm">Freepik</a></p><p>&gt; 下载 <a href="https://sspai.com/page/client">少数派客户端</a>、关注 <a href="http://sspai.com/s/KEPQ">少数派公众号</a>，读更多有趣的内容 🎉</p></div>]]></content>
      
      
      <categories>
          
          <category> 电脑使用tips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> win </tag>
            
            <tag> macToWin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器人仿真平台——Webots使用的一些背景信息</title>
      <link href="/2021/08/03/%E6%9C%BA%E5%99%A8%E4%BA%BA%E4%BB%BF%E7%9C%9F%E5%B9%B3%E5%8F%B0%E2%80%94%E2%80%94Webots%E4%BD%BF%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E8%83%8C%E6%99%AF%E4%BF%A1%E6%81%AF/"/>
      <url>/2021/08/03/%E6%9C%BA%E5%99%A8%E4%BA%BA%E4%BB%BF%E7%9C%9F%E5%B9%B3%E5%8F%B0%E2%80%94%E2%80%94Webots%E4%BD%BF%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E8%83%8C%E6%99%AF%E4%BF%A1%E6%81%AF/</url>
      
        <content type="html"><![CDATA[<p>最近做实验，需要使用Webots仿真平台。记录一下Webots中的一些概念和常用的操作。</p><h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><ul><li>world：整个你可以看见的仿真环境，包括机器人和机器人所在的场景，以.wbt为扩展名，存储在world目录中。</li><li>controller：控制仿真环境中虚拟机器人的控制器，可以是C++、python、java、matlab等语言编写，放置在每个Webots项目的“ controllers”子目录中。</li><li>motion：定义的一些列的虚拟机器人动作，比如，前进，后退，左转、右转，握手等等。</li></ul><hr><ul><li><p>场景树：描述整个仿真环境的一种结构,如下图：<img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/image-20210803200917964.png" alt="image-20210803200917964"></p><ul><li>WorldInfo：包含模拟场景的全局参数。</li><li>Viewpoint：定义主要视点相机参数。</li><li>TexturedBackground：定义场景的背景。</li><li>TexturedBackroundLight：定义与上述背景关联的光。</li><li>RectangleArena：定义场景中的方形棋盘。</li><li>WoodBox：定义场景中的三个木箱。</li></ul><p>每个节点都是场景中的元素，可以改元素下的属性(物体的大小、墙体的厚度、物体的位置等)，来调整仿真环境。</p></li></ul><h2 id="world的操作查看方式"><a href="#world的操作查看方式" class="headerlink" title="world的操作查看方式"></a>world的操作查看方式</h2><p>使用鼠标在3D视图中移动视点：</p><ul><li><p>视图旋转：左按钮移动</p></li><li><p>视图平移：右按钮移动</p></li><li><p>视图缩放：滚轮</p></li><li><p>物体位置调整——移动：选中物体，鼠标移动到物体的坐标轴箭头处，可以激活当前该轴向的物体位置调节功能。拖过鼠标可以调节物体位置。<img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/image-20210803202027162.png" alt="image-20210803202027162"></p></li><li><p>物体姿态调整——转动：同理。选中物体，鼠标移动到物体的转动坐标轴处，可激活当前该转轴向的物体姿态调节功能。鼠标拖动可以调节物体姿态。</p></li></ul><p>当然，最方便的还是选中物体，<code>shift+鼠标左键移动</code>来将物体移动到某位置位置，<code>shift+鼠标右键移动</code> 来控制物体的旋转。</p><h2 id="你需要做的事情"><a href="#你需要做的事情" class="headerlink" title="你需要做的事情"></a>你需要做的事情</h2><ol><li>搭建wrold（环境 + 机器人 + 物体等）</li><li>编写控制机器人的控制器controller，来完成你需要实现的机器人行为功能。</li><li>设置机器人的控制器为你写好的controller。设置方式如下图<img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/image-20210803205502071.png" alt="image-20210803205502071"></li></ol><h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><ul><li>修改Webots world保存时，首先要暂停模拟并将其重新加载到初始状态,即主虚拟计时器应显示0：00：00：000。否则，每次保存时，每个3D对象的位置都会累积错误。因此，对wrold的修改都应按以下顺序执行：暂停，重置，修改和保存仿真。</li></ul><h2 id="Webots教程"><a href="#Webots教程" class="headerlink" title="Webots教程"></a>Webots教程</h2><p>推荐csdn博主<a href="https://blog.csdn.net/weixin_41045354/article/details/105072630">“我是。”的教程</a> 和<a href="https://rupingcen.blog.csdn.net/article/details/106396478">“熊猫飞天”的教程</a><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/image-20210803212647750.png" alt="image-20210803212647750"><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/image-20210803214508910.png" alt="image-20210803214508910"></p>]]></content>
      
      
      
        <tags>
            
            <tag> ROS仿真 </tag>
            
            <tag> Webots </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>非侵入式脑机接口落地情况报告</title>
      <link href="/2021/08/01/%E9%9D%9E%E4%BE%B5%E5%85%A5%E5%BC%8F%E8%84%91%E6%9C%BA%E6%8E%A5%E5%8F%A3%E8%90%BD%E5%9C%B0%E6%83%85%E5%86%B5%E6%8A%A5%E5%91%8A/"/>
      <url>/2021/08/01/%E9%9D%9E%E4%BE%B5%E5%85%A5%E5%BC%8F%E8%84%91%E6%9C%BA%E6%8E%A5%E5%8F%A3%E8%90%BD%E5%9C%B0%E6%83%85%E5%86%B5%E6%8A%A5%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<h2 id="写作目的"><a href="#写作目的" class="headerlink" title="写作目的"></a>写作目的</h2><p>&emsp;&emsp;本文梳理了脑机接口技术在各个领域的应用情况。通过各领域的成熟应用案例和当前学术研究进展情况，分析非侵入式脑机接口技术落地情况。</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><h3 id="脑机接口"><a href="#脑机接口" class="headerlink" title="脑机接口"></a>脑机接口</h3><p>&emsp;&emsp;<strong>脑机接口（Brain-computer interface, BCI）是在大脑与外部环境之间建立一种全新的不依赖于外周神经和肌肉的交流与控制通道，从而实现大脑与外部设备的直接交互。</strong>该技术能够在人脑与外部环境之间建立沟通以达到控制设备的目的，进而起到监测、替代、改善/恢复、增强、补充的作用。作为一门多学科交叉的研究领域，涉及神经科学、认知科学、心理学、影像医学、生物医学工程、材料科学、电子工程、信号处理与模式识别等多个学科，是一项复杂的系统工程。</p><p>&emsp;&emsp;构建一个脑机接口系统需要实现四部分功能：<strong>信号采集、信息解码、再编码和反馈。</strong>通过布置在脑部的电极采集脑电信号，经过预处理、特征提取和分类，识别出特定的脑模式。根据应用场景下脑模式或脑模式序列编码的规则，将脑模式特征转译为外部设备可理解的控制信号。用户通过反馈环节获得外部环境和设备的状态信息，形成控制——感知——控制的闭环方式。</p><p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/bci%E6%AD%A5%E9%AA%A4-20210801124547229.jpg"></p><center>图1 BCI系统示意图</center><h3 id="侵入式和非侵入式脑机接口"><a href="#侵入式和非侵入式脑机接口" class="headerlink" title="侵入式和非侵入式脑机接口"></a>侵入式和非侵入式脑机接口</h3><p>&emsp;&emsp;根据脑机接口系统信号采集时电极的布置位置，可分为侵入式脑机接口（大脑皮层或灰质处布置电极）和非侵入式脑机接口（大脑头皮处布置电极）。</p><ul><li>侵入式BCI可以直接记录神经元电活动，信号衰减小，信噪比和空间分辨率高，能够区分。但植入有创伤，技术难度大，存在继发感染的可能性。</li><li>非侵入式BCI通过附着在头皮上的穿戴设备测量大脑的电活动或代谢活动，无需手术，安全无创。其中脑电帽是最常用的非侵入式传感器，可以在头皮上监测到群体神经元的放电活动，时间分辨率高，但空间分辨率低，且受大脑容积导体效应的影响，传递至头皮表面时衰减较大，易被噪声污染，信噪比低。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/image-20210722164811563-20210801124604533.png"></p><center>图2     侵入式与非侵入式BCI电极布置位置</center><p>&emsp;&emsp;目前，非侵入式脑机接口的研究和应用占主导地位。非侵入式BCI根据采用的脑模式又可分为P300-BCI、SSVEP-BCI 和MI-BCI。</p><ul><li><p>P300-BCI：P300 是一种事件相关电位，实验证实当人脑受到小概率新奇事件刺激后300ms 左右脑电信号会出现一个正向波峰。基于P300 信号特征的脑机接口系统具有<strong>目标多、个体差异较少</strong>的优点,已被广泛研究并测试应用，需要注意的是，该类BCI 需要多次重复闪烁,而<strong>长时间的重复闪烁</strong>,会影响患者的使用体验。</p><p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/image-20210722210050859-20210801124622027.png"></p><center>图3     P300电位（红色垂直线代表出现字符w的刺激，绿色和橙色的脑电波分别代表刺激产生后有P300的脑电波和没有P300的脑电波）</center></li><li><p>SSVEP-BCI：SSVEP （视觉稳态诱发电位）是当人眼视网膜受到恒定频率（大于6HZ）的闪光或图形刺激时，会诱发大脑视觉皮层产生可记录到的电位变化，该变化与刺激频率及其谐波频率一致。基于SSVEP 的BCI 特征提取简单、准确率和<strong>信息传输率高</strong>，用户不需要训练。这类BCI 的<strong>控制命令数量受刺激频率及其他因素影响</strong>,特别是当命令数增加时，分类精度下降。</p><p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/image-20210722211214229-20210801124641132.png"></p><center>图4    SSVEP信号特征（红色实心圆圈表示不同频率的刺激源，图中的波形对应注意到刺激后产生的脑电波功率谱）</center></li><li><p>MI-BCI：MI （运动想象）是人在心理感觉一个动作过程但不发生实际运动，是一种内隐性心理活动，<strong>无需外界刺激</strong>。研究表明运动想象会在感觉运动皮层诱发事件相关去同步/同步（ERD/ERS）响应。基于运动想象脑信号特征的脑机接口系统可用于运动障碍康复训练、假肢和轮椅控制等。该类脑机接口系统的用户需要一定量的训练，其性能不仅取决于解码算法，还取决于用户的运动想象表现，此外目前<strong>可辨识的运动想象的模式有限</strong>，只有六种，很难产生数量较多的外部设备控制命令。</p><p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/image-20210722211658567-20210801124658321.png"></p><center>图5  MI信号特征（图中脑部的热力图为不同位置电极在运动想象时的电压幅值对比情况，左手运动想象时左侧脑部的电极电压幅值明显降低，右侧脑补的电极电压幅值变高。出现左侧去同步化，右侧同步化响应的情况。同理右手运动想象时会出现右侧去同步化，左侧同步化的现象）</center></li></ul><h3 id="非侵入式脑机接口应用方向"><a href="#非侵入式脑机接口应用方向" class="headerlink" title="非侵入式脑机接口应用方向"></a>非侵入式脑机接口应用方向</h3><p>脑机接口技术的功效可以归结为如下5 类：</p><ul><li>监测：使用脑机接口系统监测部分人体意识状态。</li><li>替代：脑机接口系统的输出可以取代由于损伤或疾病而丧失的自然输出。</li><li>改善/恢复：主要针对康复领域，改善某种疾病的症状或恢复某种功能。</li><li>增强：主要是针对健康人而言，实现机能的提升和扩展。</li><li>补充：主要针对控制领域，增加脑控方式，作为传统单一控制方法的补充，实现多模态控制。</li></ul><p>围绕上述5 大功效，脑机接口技术的应用方向主要有医疗健康、娱乐、智能家居和其他。</p><ol><li><p>医疗健康</p><p>&emsp;&emsp;医疗健康领域是脑机接口最初、最直接和最主要的应用领域，也是目前最接近商业化的应用领域。医疗健康领域的应用案例主要集在“监测”、“改善/恢复”、“替代”、和“增强”4 大功效上，这些主要是以输出为主狭义BCI 的功效。</p><p>&emsp;&emsp;“监测”是指通过脑机接口系统完成对<strong>人体神经系统状态的实时监控与测量</strong>。例如，脑机接口可应用于陷入深度昏迷等微小意识状态的患者，帮助测量并评定其意识等级。</p><p>&emsp;&emsp;“改善/恢复”方向主要是指可以<strong>针对中风、癫痫等疾病做对应的恢复训练</strong>。例如，对于感觉运动皮层相关部位受损的中风病人，脑机接口可以从受损的皮层区采集信号，然后刺激失能肌肉或控制矫形器，改善手臂运动。癫痫病人的大脑会出现某个区域的神经元异常放电，通过脑机接口技术检测到神经元异常放电后，可以对大脑进行相应的电刺激，从而抑制癫痫发作。</p><p>&emsp;&emsp;“替代”方向主要针对因为损伤或疾病而丧失某种功能的患者。例如，丧失说话能力的人<strong>通过脑机接口输出文字</strong>，或通过语音合成器发声。脊髓侧索硬化症患者、重症肌无力患者、以及因事故导致高位截瘫的患者等重度运动障碍患者群体，可通过脑机接口系统将自己脑中所想的信息传达出来。</p><p>&emsp;&emsp;“增强”方向主要是指将芯片植入大脑，以增强记忆、推动人脑和计算设备的直接连接等</p></li><li><p>娱乐</p><p>&emsp;&emsp;脑机接口在娱乐领域的应用主要集中在“补充”方向。例如，脑机接口为游戏玩家提供了<strong>独立于传统游戏控制方式之外的新的操作维度</strong>，可以用意念来控制虚拟现实界面的菜单导航和选项控制，极大的丰富了游戏内涵并提升了游戏体验。</p></li><li><p>智能家居</p><p>&emsp;&emsp;脑机接口在智能家居领域的应用主要集中在“补充”方向。智能家居是脑机接口与物联网跨领域结合的一大想象空间。例如，脑机接口可类似于“遥控器”，帮助人们用<strong>意念控制</strong>开关灯、开关门和开关窗帘等，进一步可以控制家庭服务机器人。</p></li><li><p>其他</p><p>&emsp;&emsp;脑机接口在其他方向的应用主要针对健康人群的“增强”和“补充”，实现机能的扩展。例如，澳大利亚的SmartCap 公司通过在棒球帽内植入电极，可以实时<strong>监测用户的疲劳状态</strong>，同时也有部分公司将脑机接口应用于驾驶状态监测，随时关注驾驶员的疲劳状态，以降低由于疲劳驾驶而发生事故的概率。在教育领域，脑机接口技术可对学生<strong>注意力表现实时探测</strong>，从而帮助教师及时了解课堂情况以改变教学方法。</p></li></ol><h2 id="非侵入式脑机接口应用案例"><a href="#非侵入式脑机接口应用案例" class="headerlink" title="非侵入式脑机接口应用案例"></a>非侵入式脑机接口应用案例</h2><h3 id="医疗健康"><a href="#医疗健康" class="headerlink" title="医疗健康"></a>医疗健康</h3><h4 id="假肢控制"><a href="#假肢控制" class="headerlink" title="假肢控制"></a>假肢控制</h4><p>&emsp;&emsp;BrainCo公司研发的BrainRobotics智能仿生手，可以通过手臂上肌肉神经信号，识别佩戴者的运动意图，再将运动意图转化成相应的运动指令，从而完成佩戴者想要完成的动作。BrainRobotics已经实现握手、抓杯子等日常操作，并且已有残疾患者通过练习实现了写毛笔字、弹钢琴等更为复杂的操作。<img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/brainRobotics-20210801124717626.gif"></p><center>图6    BrainRobotic智能仿生手</center><h4 id="康复训练"><a href="#康复训练" class="headerlink" title="康复训练"></a>康复训练</h4><p>&emsp;&emsp;专注于虚拟显示和运动捕捉的MindMaze公司，将自身技术与脑机接口结合发布了一款用于医疗商业领域的VR头显，用于中风后运动麻痹的病人恢复，并且已获得美国食品和药物管理局（FDA）批准，进入美国市场。</p><p>&emsp;&emsp;如果中风病人的左手不能动了，但右手能动，相机就会捕捉他右手的动作，然后当他试图控制左手时，会把右手的动作移植到虚拟化身的左手上，让病人观看虚拟化身的左手在动，从而欺骗病人的大脑，让大脑相信自己的左手也能动，从而提高神经的可塑性。所以，当脑机接口检测到用户的运动意图后，通过动作捕捉技术和VR技术，我们可以欺骗大脑，加速病人恢复。这就是这款VR头显中风恢复理疗的原理。<img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/1bc81b64fac44d728370584a0e97a6cb_th-20210801092700836-20210801124751087.jpg"></p><center>图7    中风恢复治疗</center><h4 id="睡眠监测"><a href="#睡眠监测" class="headerlink" title="睡眠监测"></a>睡眠监测</h4><p>&emsp;&emsp;国外InteraXon公司和国内的脑陆科技都推出了消费级的睡眠监测可穿戴EEG设备，通过分析脑电、心率、血氧和体动等睡眠过程中的重要指标，融合多模态生物信号，为用户提供精准的睡眠管理方案。展示量化的睡眠日报、周报、月报，可以随时掌握自身睡眠状态。特别是脑陆科技推出的脑电仪设备，能够将用户的睡眠脑电进行分期，分为清醒期、浅睡期、中度睡眠期、深度睡眠期和快速眼动期。采集的数据可供专业医生诊断提供参考，并且可以为后续通过粉噪音、白噪音等节律声波对神经实时调控，优化深度睡眠的应用场景提供可靠调控指标。</p><h4 id="信息表达"><a href="#信息表达" class="headerlink" title="信息表达"></a>信息表达</h4><p>&emsp;&emsp;脑机接口的一个重要应用领域是意念打字，自从1988年Farewell和Donchin提出的第一款脑机接口字符输入系统——P300 Speller开始，基于BCI的字符输入系统一直在发展迭代。目前，世界上字符输入速度最快的非侵入式BCI Speller是国内博睿康公司和清华大学合作开发的基于SSVEP的字符输入系统，该系统能够在一分钟类输入12个英文单词。该系统还处于实验室阶段，在此研究基础之上，北京邮电大学将中文双拼输入法与SSVEP字符输入系统结合，构建了基于SSVEP的中文字符输入系统。该系统目前正在产业化过程中。</p><p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/SSVEPspeller.gif" alt="SSVEPspeller-20210801124833980"></p><center>图8    清华大学基于SSVEP的字符输入系统</center><h3 id="娱乐"><a href="#娱乐" class="headerlink" title="娱乐"></a>娱乐</h3><h4 id="面部情绪识别"><a href="#面部情绪识别" class="headerlink" title="面部情绪识别"></a>面部情绪识别</h4><p>&emsp;&emsp;位于瑞士洛桑的MindMaze公司展示了一种在VR中读取脸部情绪的设备，名为MASK。戴上集成MASK的头显后，你马上可以看到屏幕上的虚拟化身在模仿你的表情。产品的电极被安装在泡沫衬垫面板上，而这些电极可以感觉到你的面部肌肉，甚至可以在完全作出表情之前进行预测。该设备目前可以追踪的情绪有限，包括微笑、皱眉、眨眼、嘲笑和扬眉。</p><p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/b4b4cc6c-5ddf-4a6d-88ff-47e213f3b8f0-7499262-20210801124925673.jpg"></p><center>图9    VR中的表情识别</center><h3 id="智能家居"><a href="#智能家居" class="headerlink" title="智能家居"></a>智能家居</h3><p>&emsp;&emsp;广州华南脑控公司针对手脚及身体不便人群,打造了一套脑机智能护理应用系统。该系统能够让用户随时掌握护理床各活动部件的升降开关，实现自主控制起坐、抬腿、屈腿、翻身、便盘等。结合护理场景下的智能电器设备，对所在房间空调、窗帘、电视等家居设备进行控制<img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/IMG_1718-20210801125008237.JPG"></p><center>图10    基于BCI的智慧床控制</center>                                                        <h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="注意力实时检测"><a href="#注意力实时检测" class="headerlink" title="注意力实时检测"></a>注意力实时检测</h4><p>&emsp;&emsp;在注意力监测方面，BrainCo公司开发的一款Focus1注意力检测头环，可以实时显示佩戴者的当前的注意水平。该产品可用于教育领域，对于学生上课专注的评估，便于教师根据学生对于课堂的接收情况来作出课程的调整。同时也能够通过实时注意力评估值，进行一些注意力集中的调控行为如冥想，帮助学生调整状态以进入最佳的状态，更好的进行课程学习。目前该产品已经销售往15个国家，近15000名学生使用。<img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/image-20210723152007427-20210801124941112-20210801125050909.png"></p><center>图11    BrainCo公司注意力监测头环</center><p>&emsp;&emsp;系统主要用于课堂上使用，分为课前、课中、课后以及常态训练四个阶段。上课之前老师给学生发放头环，打开 Focus EDU 系统，连接网络；然后依次进行不超过三分钟的冥想训练和神经反馈训练，之后进行正常课堂授课，课堂结束后取下头环。老师可以通过BrainCo提供的教育训练平台查看学生一周内的平均专注力报告，来及时作出课程的调整。</p><h4 id="疲劳状况监测"><a href="#疲劳状况监测" class="headerlink" title="疲劳状况监测"></a>疲劳状况监测</h4><p>&emsp;&emsp;脑陆科技提出的BCI智慧安全帽，是一款在传统安全帽或智能安全帽上集成脑机接口的新型智能终端设备。在完成安全防护的同时，对人的精神不安全状况和生理状况进行监测，实时进行安全预警，提升安全管理技术手段。</p><p>&emsp;&emsp;该设备中集成了EEG（脑电图）和fNRIS（功能性性近红外光谱）信号采集传感器，能够对佩戴的疲劳状况、注意力状况、脑血氧、心率和血压进行监测。可以对佩戴者的疲劳和注意力不集中情况进行报警，同时针对使用者缺氧、供血不足、脉搏紊乱和中毒等威胁生命的突发状况进行通报，通过GPS定位来确定佩戴者方位进行及时的抢救措施，保证工作人员施工过程中的生命安全。<img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/image-20210723154806314-20210801125127878.png"></p><center>图12    脑陆科技BCI智慧安全帽的结构功能图</center><h2 id="非侵入式脑机接口成熟技术"><a href="#非侵入式脑机接口成熟技术" class="headerlink" title="非侵入式脑机接口成熟技术"></a>非侵入式脑机接口成熟技术</h2><h3 id="基于脑电的生理情况监测"><a href="#基于脑电的生理情况监测" class="headerlink" title="基于脑电的生理情况监测"></a>基于脑电的生理情况监测</h3><h4 id="睡眠评估"><a href="#睡眠评估" class="headerlink" title="睡眠评估"></a>睡眠评估</h4><p>&emsp;&emsp;可穿戴睡眠监测设备最常使用的信号是脑电图 (EEG) 和光电容积脉搏波 (PPG)。相比与PPG基于 EEG 的系统是最准确的，并且能够识别所有睡眠阶段。 基于EEG的睡眠分期系统能够<strong>实现 80-90% 之间的分类准确率</strong>。目前，多通道信号对于睡眠评估具有优势，但单通道脑电图睡眠分期也取得了很好的性能（针对所有睡眠阶段分期准确率最高可达到86.2%）。单通道EEG设备便于佩戴且成本相对较低，容易普及，<strong>能够满足家庭睡眠评估，用于早期诊断和持续监测</strong>。</p><h4 id="注意力监测"><a href="#注意力监测" class="headerlink" title="注意力监测"></a>注意力监测</h4><p>&emsp;&emsp;大脑的神经振荡是指中枢神经系统自发产生的有节奏的脑电活动，有alpha, theta, delta, gamma等。其中的 alpha和 theta 波段活动与情绪和注意力状态有关。在注意力方面，脑电信号的alpha波段功率与其呈正相关，而脑电信号的θ波段功率同时呈负相关。目前，在研究中使用多通道采集设备结合机器学习算法对注意力的分类准确率达到91.72%。但具有注意力监测功能的产品都是单通道，单通道设备注意力监测的分类准确率平均在80%左右。并且注意力监测的准确率会因使用者不同任务情景（如阅读，听讲，计算），而存在10%左右的波动。</p><h4 id="疲劳程度监"><a href="#疲劳程度监" class="headerlink" title="疲劳程度监"></a>疲劳程度监</h4><p>&emsp;&emsp;根据人在昏昏欲睡时α波和β波减少，而θ波保持不变这一生理特征，可通过监测 EEG 频带的功率谱的变化来检测受试者的困倦情况。目前拥有困倦程度的监测设备很多，Emotiv公司的Epoc、Neurosky的MindWave、OpenBCI 和 InteraXon公司的Muse产品都具有困倦疲劳监测功能。2020年Jones 和 Minh Dong Le写了一篇简短的文章，回顾了几种低成本 EEG 设备及其检测睡意的能力。其中MindWave设备的监测准确度波动最大，波动最小的设备为OpenBCI，<strong>平均准确率为79.4%<strong>。尽管这些系统没有达到研究级或医疗级系统的准确度，但它们</strong>足以部署在某些环境中</strong>。例如，这些系统可以用于发展中国家的小型企业或迫切需要易于获得的困倦检测的劳务派遣公司等。2016年，Wilaiprasitporn 和 Yagi提出了将 EEG 的睡意检测系统集成到防护或职业头盔中的想法。国内的脑陆科技公司根据这一思路实现了一款BCI智慧安全帽，除了加入EEG监测技术外还增加了对佩戴者头部血氧浓度的监测，能够进行疲劳、中毒、缺氧和供血不足等特殊生理状况监控预警。</p><h3 id="基于BCI的外设交互"><a href="#基于BCI的外设交互" class="headerlink" title="基于BCI的外设交互"></a>基于BCI的外设交互</h3><h4 id="基于BCI的字符输入系统"><a href="#基于BCI的字符输入系统" class="headerlink" title="基于BCI的字符输入系统"></a>基于BCI的字符输入系统</h4><p>&emsp;&emsp;非侵入式字符输入系统一直是BCI领域的研究重点。从字符分布界面的设计到采用的刺激范式一些系列的优化与提高，到目前为止基于非侵入式字符输入系统的输入速率还远远达不到正常人的平均水平，仅仅为每分钟40字符（准确率达到91.5%），而正常人的水平为115个字符。因此基于该技术的系统大多还处于实验室阶段或者实验室到商业产品的转换阶段。目前基于BCI技术的字符输入系统中最接近人类输入速度的斯坦福教授Krishna Shenoy发表于《Nature》上的基于侵入式BCI的笔记想象字符输入系统，该系统能够达到每分钟输入90个字符，并且识别准确率高达99%。该系统的速度与在智能手机上打字的速度相当，是BCI字符输入系统领域的重大突破。目前影响该技术应用的是目前侵入式BCI技术还不够成熟，芯片植入后的风险以及后续的维护更换都是待解决的问题。<img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/8db6-kpzzqmz7958767-20210801125225097.gif"></p><center>图13    基于笔记想象的侵入式BCI字符输入系统</center><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;BCI技术最重要的应用是医疗领域，而目前医疗领域非侵入BCI最成熟的技术之一是基于EEG信号生理信息监测，睡眠监测、疲劳状况监测、注意力监测等。在从科研和医疗领域向大众市场的下放的过程中，考虑到便携性、可穿戴性和成本等多方因素，相关设备都牺牲了多通道信号源，采用单通道信号来进行后续一些应用场景分析。这使得产品的准确性和鲁棒性与研究和医疗领域有所差距，但是已经能够用于日常的使用。这类产品面临广泛的使用人群，相比于科研和医疗领域的相对单一可控的使用环境，面临复杂多变环境下的可靠性是产品体验的重要环节。目前由于产品推出不久，还没有广泛的使用人群并形成可靠权威的产品体验报告。</p><p>&emsp;&emsp;作为BCI技术诞生不久后，一直研究的字符输入系统，技术相对成熟，2018清华大学提出的SSVEP字符输入系统每分钟可以输入40个字符，但是目前迟迟没有产品推出，主要还是基于SSVEP的系统对于字符输入这种长时间的任务，不同频率的闪烁刺激方式容易产生疲劳，整体体验还有待优化。而针对BCI的智慧家居、假肢的控制以及基于虚拟现实的康复训练，目前只有极少的公司有产品化。</p><p>&emsp;&emsp;从产品的成熟度来看，脑机接口技术处于初级阶段，未来尚需更加完善的制度和标准来规范产品上市进程，对产品的安全性、有效性进行合理全面的认证。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><p>Current and Future Brain-Computer Interface，Christoph Guger，g.tech medical engineering (2021).</p></li><li><p>Imtiaz, Syed Anas. “A Systematic Review of Sensing Technologies for Wearable Sleep Staging.” Sensors 21.5 (2021): 1562.</p></li><li><p>Yang, Chen, et al. “A dynamic window recognition algorithm for SSVEP-based brain–computer interfaces using a spatio-temporal equalizer.” International journal of neural systems 28.10 (2018): 1850028.</p></li><li><p>LaRocco, John, Minh Dong Le, and Dong-Guk Paeng. “A systemic review of available low-cost EEG headsets used for drowsiness detection.” Frontiers in neuroinformatics 14 (2020).</p></li><li><p>Mohammadpour, Mostafa, and Saeed Mozaffari. “Classification of EEG-based attention for brain computer interface.” 2017 3rd Iranian Conference on Intelligent Systems and Signal Processing (ICSPIS). IEEE, 2017.</p></li><li><p>Wang, Bingbing, et al. “EEG-Based Closed-Loop Neurofeedback for Attention Monitoring and Training in Young Adults.” Journal of Healthcare Engineering 2021 (2021).</p></li><li><p>Willett, Francis R., et al. “High-performance brain-to-text communication via handwriting.” Nature 593.7858 (2021): 249-254.</p></li><li><p>伏云发,郭衍龙, 张夏冰, 李松. 脑-机接口—革命性的人机交互[译]. 北京:国防工业出版社, 2020.</p></li><li><p>伏云发,丁鹏,罗建功,吕晓彤.脑-计算机接口[译]. 国防工业出版社,北京,2021.</p></li><li><p>李静雯, 王秀梅. 脑机接口技术在医疗领域的应用[J]. 信息通信技术与政策, 2021,47(2):87-91.</p></li><li><p><a href="http://lib.ia.ac.cn/documents/17475/0/%E8%84%91%E6%9C%BA%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%9C%A8%E5%8C%BB%E7%96%97%E5%81%A5%E5%BA%B7%E9%A2%86%E5%9F%9F%E5%BA%94%E7%94%A8%E7%99%BD%E7%9A%AE%E4%B9%A6%EF%BC%882021%EF%BC%89.pdf">脑机接口技术在医疗健康领域应用白皮书</a>. 中国人工智能产业发展联盟”,2021.</p></li><li><p><a href="https://zhuanlan.zhihu.com/p/28584797">意念打字、心灵控制、大脑永生…这不是科幻大片，这是过去一年「脑机接口」领域的重磅突破！</a></p></li><li><p><a href="https://space.bilibili.com/1262597880/video?tid=0&page=1&keyword=&order=pubdate">g.tec 脑电产品中国区总代理</a></p></li></ol><p>  ​    </p><p>  ​    </p>]]></content>
      
      
      <categories>
          
          <category> 脑机接口 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 非侵入式BCI </tag>
            
            <tag> BCI应用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>宅在家系列Tips——煮挂面</title>
      <link href="/2021/07/31/Zoella-Cooking%E7%AC%94%E8%AE%B0%E4%B9%8B%E2%80%94%E2%80%94%E7%AE%80%E9%A4%90%E6%8C%82%E9%9D%A2/"/>
      <url>/2021/07/31/Zoella-Cooking%E7%AC%94%E8%AE%B0%E4%B9%8B%E2%80%94%E2%80%94%E7%AE%80%E9%A4%90%E6%8C%82%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<p>作为在广东的一个西北人，已经快一年没有吃过面了。这边的面无法接受，所以还是自己动手煮挂面吧。</p><h3 id="挂面选择"><a href="#挂面选择" class="headerlink" title="挂面选择"></a>挂面选择</h3><p><code>首先</code>是挂面的选择。</p><p>不同的挂面吸水性不同，容易吸水的后面需要加水和盐。<img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/different_noodle.jpg"></p><p>面，中火不盖锅盖煮<strong>五分钟</strong>即可。</p><h3 id="挂面调料"><a href="#挂面调料" class="headerlink" title="挂面调料"></a>挂面调料</h3><p><code>接着</code>主戏——挂面调料：</p><ol><li>两勺生抽</li><li>一勺四川熟油辣子</li><li> 半勺或一勺醋</li><li>一勺花椒油</li><li>加盐</li><li>一小块猪油</li></ol><p>以上调制完成，加入煮面的水，根据咸淡，添加水或盐。</p><p><code>然后</code>，煮五分钟的面，捞入调制好的汤中，加入葱花。</p><p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/noodles.jpg"></p><p><code>最后</code>，开始享用喽～</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><iframe width="950" height="534" src="https://www.youtube.com/embed/TBLF9oBab9k" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>]]></content>
      
      
      <categories>
          
          <category> 简餐 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 挂面 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机试——字符串、排序与查找</title>
      <link href="/2020/03/29/%E6%9C%BA%E8%AF%95%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E5%8A%9F/"/>
      <url>/2020/03/29/%E6%9C%BA%E8%AF%95%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E5%8A%9F/</url>
      
        <content type="html"><![CDATA[<h4 id="C-中字符串"><a href="#C-中字符串" class="headerlink" title="C++中字符串"></a>C++中字符串</h4><ol><li><p>string 的基本使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;isotream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string str,str1 = <span class="string">&#x27;OK&#x27;</span>; <span class="comment">/*定义string类型变量*/</span></span><br><span class="line">    cin&gt;&gt;str;  <span class="comment">//输入</span></span><br><span class="line">    str.<span class="built_in">size</span>() <span class="comment">// string类型变量长度</span></span><br><span class="line">    cout&lt;&lt;str&lt;&lt;endl;   <span class="comment">//输出</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;str.<span class="built_in">size</span>(); i++)&#123;   <span class="comment">//像数组一样访问元素</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,str[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    str.<span class="built_in">insert</span>(str.<span class="built_in">size</span>(),<span class="string">&quot;...&quot;</span>);  <span class="comment">//从当前下标开始插入   </span></span><br><span class="line">    str.<span class="built_in">erase</span>(<span class="number">0</span>,<span class="number">5</span>); <span class="comment">//删除下标从0～5的元素 </span></span><br><span class="line">    str.<span class="built_in">erase</span>(<span class="number">2</span>);</span><br><span class="line">    str.<span class="built_in">clear</span>(); <span class="comment">//str置空</span></span><br><span class="line"></span><br><span class="line">    str = str + <span class="string">&#x27;hello&#x27;</span>; <span class="comment">//字符串连接</span></span><br><span class="line">    str = str + str1;</span><br><span class="line">    str.<span class="built_in">find</span>(<span class="string">&quot;ok&quot;</span>); <span class="comment">// 在字符串中查找字符串或者字符 如果找不到返回 string::npos</span></span><br><span class="line">    str.<span class="built_in">sbustr</span>(<span class="number">2</span>,<span class="number">4</span>); <span class="comment">//返回str中下标从2开始的四个字符组成的子串</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>对于需要获取一行的字符串（含空格），需要使用getline</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string str;</span><br><span class="line"><span class="built_in">getline</span>(cin,str);</span><br></pre></td></tr></table></figure></li></ol><p>例子：</p><p>在情报传递过程中，为了防止情报被截获，往往需要对情报用一定的方式加密，简单的加密算法虽然不足以完全避免情报被破译，但仍然能防止情报被轻易的识别。我们给出一种最简的的加密方法，对给定的一个字符串，把其中从a-y,A-Y的字母用其后继字母替代，把z和Z用a和A替代，则可得到一个简单的加密字符串。</p><p>输入一行字符串，输出对该字符串加密的结果</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">incode</span><span class="params">(string str)</span></span>&#123;</span><br><span class="line">    string incodeStr;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>( (<span class="string">&#x27;a&#x27;</span>&lt;=str[i]  &amp;&amp; str[i]&lt;=<span class="string">&#x27;y&#x27;</span>) || (<span class="string">&#x27;A&#x27;</span>&lt;=str[i]  &amp;&amp; str[i]&lt;=<span class="string">&#x27;Y&#x27;</span>) )&#123;</span><br><span class="line">            incodeStr += str[i]+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (str[i] == <span class="string">&#x27;z&#x27;</span> || str[i] == <span class="string">&#x27;Z&#x27;</span>)&#123;</span><br><span class="line">            incodeStr += str[i]<span class="number">-25</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            incodeStr += str[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> incodeStr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(cin,str))&#123;</span><br><span class="line">        cout&lt;&lt;<span class="built_in">incode</span>(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><ol><li>c++内部基于快速排序的函数——sort<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sort</span>(first,last,comp); <span class="comment">// first,last 起始地址、结束地址， 排序方式定义的函数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>如果sort中的 比较函数comp 返回 true, 则排序时会将比较函数comp的第一个参数置于第二个参数前。<br>例子： 用一位数组存储学生的学号和成绩，然后按成绩排序输出</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">Student arr[MAXN];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Compare</span><span class="params">(Student a, Student b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.score == b.score)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.number &lt; b.number;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.score &lt; b.score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;arr[i].number,&amp;arr[i].score);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(arr,arr+n,Compare);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,arr[j].number,arr[j].score);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><p>机试中最常见的查找是二分查找<br>二分查找的前提是有序，二分查找的思想是： 对于当前要查找的数，与有序序列中中间位置的数与之做比较：</p><p> a. 如果大于要查找的数，则从小于中间位置的序列中再使用该方法查找。</p><p> b. 如果小于要查找的数，则从大于中间位置的序列中再使用该方法查找。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在长度位n的有序数组arr中查找x,返回查找到的下标</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch</span><span class="params">(<span class="keyword">int</span> arr,<span class="keyword">int</span> n,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">        <span class="keyword">int</span> middle = (low+high)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(arr[middle] == x)&#123;</span><br><span class="line">            <span class="keyword">return</span> middle;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[middle] &lt; x)</span><br><span class="line">            low = middle + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            high = middle - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 机试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 研究生复试上机题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机试--数学问题</title>
      <link href="/2020/03/29/%E6%9C%BA%E8%AF%95-%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98/"/>
      <url>/2020/03/29/%E6%9C%BA%E8%AF%95-%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>机试中，有一些与数字相关的题目： 进制转换、最大公约数、最小公倍数、素数、高进度整整数运算（无法用数值类型变量直接存储）。本文对于这几个部分的一些常见题，进行归纳总结。</p><span id="more"></span><h3 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h3><ol><li>整数二进制方式显示 [北邮上机题]</li></ol><blockquote><p>十进制转二进制，使用除留取余法，注意余数的先后顺序与该数二进制顺序相反，因此将余数按顺序存放，逆序输出即可</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span>   <span class="comment">//容器，可变长度的&quot;数组&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bit</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; NumBit;</span><br><span class="line">    <span class="keyword">int</span> BitNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(num != <span class="number">0</span>)&#123;</span><br><span class="line">        NumBit.<span class="built_in">push_back</span>(num % <span class="number">2</span>);</span><br><span class="line">        num /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = NumBit.<span class="built_in">size</span>()<span class="number">-1</span>; i &gt;= <span class="number">0</span> ; i--) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,NumBit[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    string s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num);</span><br><span class="line">        <span class="built_in">Bit</span>(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>大型正整数二进制显示 [清华上机题]</li></ol><blockquote><p>在C与C++中较大的整数无法存储进行直接的算数运算。因此，对于大数的处理一般需要使用字符串的方法。本题与上一题有相似之处，只是本题的数据无法存储，因此无法进行算术的除、取余操作。可以通过定义字符串的方式，实现字符串数字的除法、取余。进而套用上一题的方法。</p></blockquote><blockquote><p>对于字符串的：</p><ol><li>取余操作： 只需取当前字符串的最后一位做算术的取余操作，其结果即是整个字符串数的取余结果。</li><li>除法操作： 与我们平时在草稿纸上算的步骤一样，依次从高到低对字符串数的每个元素进行：<br> 除2 、 取余操作。 即可得到该字符串数除2的结果字符串。<strong>该过程中注意：取余的目的是为了，在下次除操作前，将上一位的余数与当前为合并作为被除数。 对于除完后的结果中可能前几位是0，需要去掉多余的0，方便除留取余法推出循环。</strong></li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">string <span class="title">divide</span><span class="params">(string num, <span class="keyword">int</span> divider)</span></span>&#123;  <span class="comment">//字符串除法</span></span><br><span class="line">    string answer; <span class="comment">//商</span></span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>; <span class="comment">//上一位的余数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;num.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> dividend = num[i]-<span class="string">&#x27;0&#x27;</span> + carry*<span class="number">10</span> ;</span><br><span class="line">        answer += (<span class="string">&#x27;0&#x27;</span> + dividend / divider);   </span><br><span class="line">        carry = dividend % divider; <span class="comment">//取余</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> post = <span class="number">0</span>; <span class="comment">//标示answer中不为0的第一个数字字符【重要】</span></span><br><span class="line">    <span class="keyword">while</span> (answer[post] == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">        post++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> answer.<span class="built_in">substr</span>(post);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printBit</span><span class="params">(string sNum)</span></span>&#123; <span class="comment">//十进制转二进制</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; NumBit;</span><br><span class="line">    <span class="keyword">while</span>(sNum.<span class="built_in">size</span>() != <span class="number">0</span>)&#123;</span><br><span class="line">        NumBit.<span class="built_in">push_back</span>((sNum[sNum.<span class="built_in">size</span>()<span class="number">-1</span>]-<span class="string">&#x27;0&#x27;</span>) % <span class="number">2</span>);</span><br><span class="line">        sNum = <span class="built_in">divide</span>(sNum,<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=NumBit.<span class="built_in">size</span>()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,NumBit[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string sNum;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; sNum)&#123;</span><br><span class="line">        <span class="built_in">printBit</span>(sNum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>求一个十进制数的逆序数。[清华机上机题]<blockquote><p>逆序数：对于一个十进制数A，将A转换为二进制数，然后按位逆序排列，再转换为十进制数B，我们称B为A的二进制逆序数。例如对于十进制数173，它的二进制形式为10101101，逆序排列得到10110101，其十进制数为181，181即为173的二进制逆序数。</p></blockquote></li></ol><blockquote><p>本题与上一题，有一定的联系。将大数的十进制（字符串形式）转换为二进制【上题内容】，接下来需要：将得到的二进制转换成新的大数的十进制（字符串形式）。</p><p>转换过程中涉及到： 字符串数与一位整数的 加法 和 乘法</p><ol><li>加法： 将加数作为低位的进位，从<strong>后向前</strong>遍历字符串数的每一个位： 当前位与进位相加，对10取余为求加法结果，对10取模为当前位加法向上一位的进位。<strong>注意即使进位为0，也要继续遍历高位，进行求和操作。否则结果会丢失高位信息。</strong>。如果加法遍历完后，最高位有进位需要给结果修正：最高位补1。</li><li>乘法： 对于被乘数进行从后向前遍历：当前位乘上乘数并加上后一位的进位，对10取余为乘法结果，对10取模为进位。如果最高位有进位，结果和加法一样需要类似的修正。</li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">divide</span><span class="params">(string sNum,<span class="keyword">int</span> divider)</span></span>&#123;   <span class="comment">//字符串除法</span></span><br><span class="line">    string answer; <span class="comment">//最后除的结果--商</span></span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>; <span class="comment">//上一位的余数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;sNum.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> dividend = (sNum[i]-<span class="string">&#x27;0&#x27;</span>) + carry*<span class="number">10</span>; <span class="comment">//当前位的被除数</span></span><br><span class="line">        answer += (<span class="string">&#x27;0&#x27;</span>+ (dividend / divider)); <span class="comment">//当前位的商</span></span><br><span class="line">        carry = dividend % <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> post = <span class="number">0</span>; <span class="comment">//商字符串中不为0的第一字符位置</span></span><br><span class="line">    <span class="keyword">while</span>(answer[post] == <span class="string">&#x27;0&#x27;</span>)&#123;    <span class="comment">//去除结果中前面多余的0</span></span><br><span class="line">        post++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> answer.<span class="built_in">substr</span>(post);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">multiple</span><span class="params">(string sNum,<span class="keyword">int</span> factor)</span></span>&#123;  <span class="comment">//字符串乘法</span></span><br><span class="line">    string answer;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=sNum.<span class="built_in">size</span>()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = (sNum[i]-<span class="string">&#x27;0&#x27;</span>)  * factor + carry;</span><br><span class="line">        answer = <span class="built_in"><span class="keyword">char</span></span>(<span class="string">&#x27;0&#x27;</span>+(temp % <span class="number">10</span>)) + answer;   <span class="comment">//从低位到高位分别乘二得到结果</span></span><br><span class="line">        carry = temp / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(carry == <span class="number">1</span>)&#123;     <span class="comment">//因为乘的是2，所以进位只能是1</span></span><br><span class="line">        answer = <span class="string">&#x27;1&#x27;</span> + answer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">add</span><span class="params">(string sNum, <span class="keyword">int</span> adder)</span></span>&#123;</span><br><span class="line">    string answer;</span><br><span class="line">    <span class="keyword">int</span> carry = adder;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=sNum.<span class="built_in">size</span>()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = sNum[i]-<span class="string">&#x27;0&#x27;</span> + carry; <span class="comment">//把要加的一位整数（0或1）当成当前位后一位的进位</span></span><br><span class="line">        carry = temp / <span class="number">10</span>;</span><br><span class="line">        answer = <span class="built_in"><span class="keyword">char</span></span>(<span class="string">&#x27;0&#x27;</span> +temp%<span class="number">10</span>) + answer ;  <span class="comment">//需要进行类型转换，否则无法将int型并入字符串</span></span><br><span class="line">        <span class="comment">//if(carry == 0) 没有进位，加法依然要继续，否则丢失高位值</span></span><br><span class="line">        <span class="comment">//    break;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(carry == <span class="number">1</span>)&#123; <span class="comment">//最高位有进位</span></span><br><span class="line">        answer = <span class="string">&quot;1&quot;</span> + answer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printInvertBinNum</span><span class="params">(string sNum)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//十进制字符串 转 二进制</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; InvertBinary;</span><br><span class="line">    <span class="keyword">while</span>(sNum.<span class="built_in">size</span>() != <span class="number">0</span>)&#123;</span><br><span class="line">        InvertBinary.<span class="built_in">push_back</span>( (sNum[sNum.<span class="built_in">size</span>()<span class="number">-1</span>]-<span class="string">&#x27;0&#x27;</span>) % <span class="number">2</span> ); <span class="comment">//取余</span></span><br><span class="line">        sNum = <span class="built_in">divide</span>(sNum,<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//二进制 转 十进制字符串</span></span><br><span class="line">    string answer = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;InvertBinary.<span class="built_in">size</span>(); i++)&#123;  <span class="comment">//对于求二进制逆序数来说： InvertBinary中保存的是逆序数的正序二进制</span></span><br><span class="line">        answer = <span class="built_in">multiple</span>(answer,<span class="number">2</span>); <span class="comment">//对于中间结果右移一位</span></span><br><span class="line">        answer = <span class="built_in">add</span>(answer,InvertBinary[i]); <span class="comment">//加上低位的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; answer.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,answer[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string sNum;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;sNum)&#123;</span><br><span class="line">        <span class="built_in">printInvertBinNum</span>(sNum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>M进制转N进制<blockquote><p>由于M，和N的值都有可能大于10，所以有字符串的形式存储M进制数和N进制数。因此需要现将M进制的数转换为数值形式，这里将其转换为我们熟悉的十进制是一种常见的方式，通过十进制作为两种不同进制字符串形式转换的桥梁。即 M进制字符串形式 –&gt; 十进制数值形式 –&gt; N进制字符串形式。在其中注意一些细节问题，如需要将高于10进制的数中的英文字符转换为数字，将高于10的数字转换为英文字符。这是于小于10的进制转换所不需要考虑的问题。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CharToInt</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&#x27;0&#x27;</span>&lt;=c &amp;&amp; c&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c-<span class="string">&#x27;A&#x27;</span>+<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">IntToChar</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x&lt;<span class="number">10</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;0&#x27;</span>+x;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x<span class="number">-10</span> + <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m,n;</span><br><span class="line">    string str,Nmum;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;m,&amp;n)) &#123;</span><br><span class="line">        cin &gt;&gt; str;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); ++i) &#123;  <span class="comment">//M进制转为10进制</span></span><br><span class="line">            number *= m;</span><br><span class="line">            number += <span class="built_in">CharToInt</span>(str[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="keyword">char</span>&gt; answer;</span><br><span class="line">        <span class="keyword">while</span>(number != <span class="number">0</span>)&#123;</span><br><span class="line">            answer.<span class="built_in">push_back</span>(<span class="built_in">IntToChar</span>(number%n));</span><br><span class="line">            number /= n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = answer.<span class="built_in">size</span>()<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, answer[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>进制转换的问题，最为重要的是转换的方法： 1.正向除留取余法，2.逆向移位求和法。 注意在做两种运算的过程中1的输出、2的输入的数据的顺序与正常情况下的相反。<br>在此基础之上，有时需要考虑到输入数据的方式：</p><ol><li>由于高于10进制，存储使用字符串方便。对于这种可以想办法把输入转为10进制数值，根据题目要求作处理。</li><li>需要输入的数远大于数值类型的存储范围，使用字符串存储。对于该类数据的运算，不能使用数值型，因为无法存储中间结果。需要实现字符串级别的“算术运算”。要注意定义运算过程中的一些细节，如运算后结果的修正，考虑最高位进位问题等。</li></ol><h3 id="最大公约数与最小公倍数"><a href="#最大公约数与最小公倍数" class="headerlink" title="最大公约数与最小公倍数"></a>最大公约数与最小公倍数</h3><p>这种题需要对于最大公约数和最小公倍数的判别方法熟悉。</p><h4 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h4><blockquote><p>对于 a, b 两数，求其最大公约数的思路是：</p><ol><li>把求   a, b的最大公约数 —&gt;  b, a%b的最大公约数  （数学推理过程略） <strong>注意b作为除数不能为0</strong></li><li>这样不断递归的缩小范围，直到求 某个数与0 的最大公约数，即非0数为最大公约数</li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxFactor</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">MaxFactor</span>(b,a%b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m,n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;m,&amp;n)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in">MaxFactor</span>(m,n));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="最小公倍数"><a href="#最小公倍数" class="headerlink" title="最小公倍数"></a>最小公倍数</h4><p>求最小公倍数思路是基于最大公约数的：<br>    a,b 的最小共倍数是  a*b / 最大公约数</p><h3 id="质数-素数"><a href="#质数-素数" class="headerlink" title="质数/素数"></a>质数/素数</h3><blockquote><p>质数或者素数a： 只能被1和本身整出的<strong>正整数</strong>（小于2的数一定不是素数）。 用所有小于sqrt(a)的数除a,如果存在整除的情况则不是素数。</p></blockquote><h4 id="判断一个数是否为素数"><a href="#判断一个数是否为素数" class="headerlink" title="判断一个数是否为素数"></a>判断一个数是否为素数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">JudgeSuNum</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">2</span>)&#123;                <span class="comment">//小于2的数一定不是素数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> bound = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; bound; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n%i == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in">JudgeSuNum</span>(n));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于一定大范围的数，判断其是否为素数，对于每一个数遍历判别，显然是有些耗时，效率不高。是否有更好的方法呢？——-素数筛选法</p><p>素数筛选法的思想是：假设当前大于1的数都为素数，遍历所有数，用已确定的素数，去标记后面是该素数倍数的数为非素数。通过选出不是素数的数，剩余的则是素数。</p><h4 id="输出1到给定n之间的素数"><a href="#输出1到给定n之间的素数" class="headerlink" title="输出1到给定n之间的素数"></a>输出1到给定n之间的素数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10001</span>;</span><br><span class="line"><span class="keyword">bool</span> isPrime[MAXN];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; prime;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Initial</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXN; ++i) &#123;</span><br><span class="line">        isPrime[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    isPrime[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">    isPrime[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; MAXN; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!isPrime[j])&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        prime.<span class="built_in">push_back</span>(j);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = j*j; i &lt; MAXN; i+=j) &#123;  <span class="comment">//从当前素数j的j倍开始，小于j的倍数的数 由 小于j的素数标记。i的“自增”为j的倍数</span></span><br><span class="line">            isPrime[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Initial</span>();</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n) != EOF) &#123;</span><br><span class="line">        <span class="keyword">bool</span> isOutput = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prime.<span class="built_in">size</span>() &amp;&amp; prime[i]&lt;n; ++i) &#123;</span><br><span class="line">            isOutput = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,prime[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!isOutput)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分解质因数"><a href="#分解质因数" class="headerlink" title="分解质因数"></a>分解质因数</h3><p>给定一个数N（1&lt;N&lt;1E9），将其分解为多个质因数相乘  </p><blockquote><ol><li>分解质因数，需要用到上题素数筛选法，通过素数筛选法确定 1～sqrt(1E9)+1 之间的素数。</li><li>遍历素数序列： 用素数取整除 N，如果成功则为N的质因数，输出。直到 所有的素数都遍历结束。</li><li>遍历结束后需要判断 N 整除前面得到的质因数的结果是否大于1，如果大于一，则存在大于 sqrt(1E9)+1的质因数。需要输出。</li></ol><p><strong>（对于N来说之多存在一个大于 sqrt(n）的质因数）</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">40000</span>;</span><br><span class="line"><span class="keyword">bool</span> isPrime[MAXN];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; prime;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Initial</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXN; ++i) &#123;</span><br><span class="line">        isPrime[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    isPrime[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">    isPrime[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; MAXN; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!isPrime[j])&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        prime.<span class="built_in">push_back</span>(j);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = j*j; i &lt; MAXN; i=i+j) &#123;  <span class="comment">//从当前素数j的j倍开始，小于j的倍数由小于j的素数标记其不为素数。i 的值为j的倍数</span></span><br><span class="line">            isPrime[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Initial</span>();</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n) != EOF) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prime.<span class="built_in">size</span>() &amp;&amp; prime[i]&lt;=n; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span>(n%prime[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,prime[i]);</span><br><span class="line">                n /= prime[i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">1</span>)&#123;   <span class="comment">//未出尽的数大于则是素因数</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><p>对于 a^b 的快速算法思路：</p><blockquote><p>将b分解为若干个2^k的和  如： 3^29 ,  其中b为29 = 1 + 4 + 8 + 16;</p><p>a^b = a^k1 * a^k2 * … * a^km,  3^29 = 3^1 * 3^4 * 3^8 * 3^16;</p><p>这样       3^1 = 3</p><pre><code>      3^2 = 3^1 * 3^1      一次计算         3^4 = 3^2 * 3^2      二次计算         3^8 = 3^4 * 3^4      三次计算          3^16 = 3^8 * 3^8     四次计算</code></pre></blockquote><blockquote><pre><code>      3^29 只需要计算四次   普通乘法需要29次</code></pre></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">aEb</span><span class="params">(<span class="keyword">long</span> a, <span class="keyword">long</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> answer = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(b != <span class="number">0</span>)&#123;     </span><br><span class="line">        <span class="keyword">if</span>(b%<span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">            answer *= a;</span><br><span class="line">        &#125;</span><br><span class="line">        b /= <span class="number">2</span>;        </span><br><span class="line">        a *= a;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b) != EOF) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,<span class="built_in">aEb</span>(a,b));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="高精度整数运算C-类是现实"><a href="#高精度整数运算C-类是现实" class="headerlink" title="高精度整数运算C++类是现实"></a>高精度整数运算C++类是现实</h3><blockquote><p>高进度数之所以不好处理的在于无法存储。一般有两种比较常见的处理方式： </p><ol><li> 用字符串存储</li><li> 用数组存储</li></ol><p>用字符串存储，在编写相应的算术运算实现时，对字符串操作由于字符串的长度不一，两个高进度整数运算时需要考虑具体的处理问题比较多。用数组存储，好处是通过指定存储数组的空间，算术运算实现时，不需要考虑太多运算过程中的数的长度的影响，因为为存储数的数组元素中的大于数长度的部分值置为0，便于大数与小数的运算。确点是需要实现分配容纳数的大量空间，利用效率不一定高。</p></blockquote><p>一下的算法是基于数组存储高进度整数的。<strong>数组存储以十进制的方式，从0～MAXN的下标依次存储数的个位、十位、百位、….</strong></p><ol><li><p>高进度整数表示的类定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN  = <span class="number">10000</span>;  <span class="comment">//最大能存储的10进制数的位数</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BigInteger</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> digit[MAXN];  <span class="comment">//从0～MAXN 存放数字的 个位 十位 百位 ...</span></span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">BigInteger</span>();</span><br><span class="line">    <span class="built_in">BigInteger</span>(<span class="keyword">int</span> x);</span><br><span class="line">    <span class="built_in">BigInteger</span>(string str);</span><br><span class="line">    <span class="built_in">BigInteger</span>(<span class="keyword">const</span> BigInteger&amp; b);</span><br><span class="line">    BigInteger <span class="keyword">operator</span>=(<span class="keyword">int</span> x);</span><br><span class="line">    BigInteger <span class="keyword">operator</span>=(string str);</span><br><span class="line">    BigInteger <span class="keyword">operator</span>=(<span class="keyword">const</span> BigInteger&amp; b);</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;=(<span class="keyword">const</span> BigInteger&amp; b);</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> BigInteger&amp; b);</span><br><span class="line"></span><br><span class="line">    BigInteger <span class="keyword">operator</span>+(<span class="keyword">const</span> BigInteger&amp; b);</span><br><span class="line">    BigInteger <span class="keyword">operator</span>-(<span class="keyword">const</span> BigInteger&amp; b);</span><br><span class="line">    BigInteger <span class="keyword">operator</span>*(<span class="keyword">const</span> BigInteger&amp; b);</span><br><span class="line">    BigInteger <span class="keyword">operator</span>/(<span class="keyword">const</span> BigInteger&amp; b);</span><br><span class="line">    BigInteger <span class="keyword">operator</span>%(<span class="keyword">const</span> BigInteger&amp; b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; in, BigInteger&amp; x);</span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, BigInteger&amp; x);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>高进度整数类的构造函数实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">BigInteger::<span class="built_in">BigInteger</span>() &#123;</span><br><span class="line">    <span class="built_in">memset</span>(digit,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(digit));</span><br><span class="line">    length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger::<span class="built_in">BigInteger</span>(<span class="keyword">int</span> x) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(digit,<span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(digit));</span><br><span class="line">    length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">0</span>)&#123;                <span class="comment">//对于0的特殊处理</span></span><br><span class="line">        digit[length++] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(x != <span class="number">0</span>)&#123;</span><br><span class="line">        digit[length++] = x%<span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger::<span class="built_in">BigInteger</span>(string str) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(digit,<span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(digit));</span><br><span class="line">    length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = str.<span class="built_in">size</span>()<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) &#123;  <span class="comment">//注意数组存储的方式从低位到高位</span></span><br><span class="line">        digit[length++] = str[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger::<span class="built_in">BigInteger</span>(<span class="keyword">const</span> BigInteger &amp;b) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(digit,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(digit));</span><br><span class="line">    length = b.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">        digit[i] = b.digit[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure></li><li><p>赋值运算符的重载</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>=(<span class="keyword">int</span> x) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(digit,<span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(digit));</span><br><span class="line">    length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">0</span>)&#123;</span><br><span class="line">        digit[length++] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(x != <span class="number">0</span>)&#123;</span><br><span class="line">        digit[length++] = x%<span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>=(string str) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(digit,<span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(digit));</span><br><span class="line">    length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = str.<span class="built_in">size</span>()<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        digit[length++] = str[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>=(<span class="keyword">const</span> BigInteger &amp;b) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(digit,<span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(digit));</span><br><span class="line">    length = b.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">        digit[i] = b.digit[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>输入、输出运算符重载</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; in,BigInteger &amp;x)&#123;</span><br><span class="line">    string str;</span><br><span class="line">    in&gt;&gt;str;</span><br><span class="line">    x = str;</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out,<span class="keyword">const</span> BigInteger &amp;x)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x.length<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        out&lt;&lt; x.digit[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure></li><li><p>高进度正整数的算术运算</p><p>a. 比较</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> BigInteger::<span class="keyword">operator</span>&lt;=(<span class="keyword">const</span> BigInteger&amp; b)&#123;</span><br><span class="line">    <span class="keyword">if</span>(length &lt; b.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(b.length &lt; length)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = length<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (digit[i] == b.digit[i])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> digit[i] &lt; b.digit[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> BigInteger::<span class="keyword">operator</span>==(<span class="keyword">const</span> BigInteger &amp;b) &#123;</span><br><span class="line">    <span class="keyword">if</span>(length != b.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = length<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (digit[i] != b.digit[i])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​            b. 加法    </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>+(<span class="keyword">const</span> BigInteger &amp;b) &#123;</span><br><span class="line">    BigInteger answer;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> bound = length&gt;b.length ? length:b.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bound; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = digit[i] + b.digit[i] + carry;</span><br><span class="line">        answer.digit[answer.length++] = temp % <span class="number">10</span>;</span><br><span class="line">        carry = temp / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(carry == <span class="number">1</span>)&#123;  <span class="comment">//最高位有进位</span></span><br><span class="line">        answer.digit[answer.length++] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>加法运算比较简单，以两个数中最大的长度为遍历边界，对于每一位进行加和，留下和中小于10的部分，大于10的作为进位，加入高位的求和中。</p></blockquote><blockquote><p>注意： 两数的每一位遍历加和完成后，<strong>要判断最高位是否有进位（即进位的标记是否为1），如果有进位，则求和的结果在最高位前补1</strong>；</p></blockquote><p>​        c. 乘法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>*(<span class="keyword">const</span> BigInteger &amp;b) &#123;</span><br><span class="line">    BigInteger answer;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    answer.length = length + b.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length;  ++i) &#123;                 <span class="comment">//模拟：每位与乘数每一位运算后的，同权的位结果求和</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; b.length; ++j) &#123;</span><br><span class="line">            answer.digit[i+j] += digit[i] * b.digit[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; answer.length; ++k) &#123;           <span class="comment">//对于answer结果中的每一位超过10的进行修正进位</span></span><br><span class="line">        answer.digit[k+<span class="number">1</span>] += answer.digit[k] / <span class="number">10</span>;</span><br><span class="line">        answer.digit[k] %= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(answer.digit[answer.length<span class="number">-1</span>] == <span class="number">0</span> &amp;&amp; answer.length &gt; <span class="number">1</span>)&#123;   <span class="comment">//消除结果中多余的0</span></span><br><span class="line">        answer.length--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>乘法：稍微复杂一点</p><ol><li>模拟手动计算乘法的过程，即将乘数的从最低位一次去乘被乘数，要注意一个细节： <code>乘数的第i位 * 被乘数的第j位 = 结果的第(i+j)位</code>。将对应结果的权值相同的位加起来。</li><li>此时等到的结果中，每一位的值都可能大于10，需要对这些位做调整，将大于10的部分进位到高位，留下小于10的部分作为当前位的值。</li><li>乘法结果中可能存在连续多个高位到最高位为0，需要去除多余的0.否则对于根据数字有效长度判断大小的函数，会产生错误的比较结果。（如： 000 &gt; 0）</li></ol></blockquote><p>​        d.减法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>-(<span class="keyword">const</span> BigInteger &amp;b) &#123;     <span class="comment">//只使用于大数减小数的减法</span></span><br><span class="line">    BigInteger answer;</span><br><span class="line">    <span class="comment">//大数为this指向的对象，b为小数的对象</span></span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> bound = length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bound; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = digit[i] - b.digit[i] - carry;</span><br><span class="line">        <span class="keyword">if</span> (temp &gt;= <span class="number">0</span>)&#123;         <span class="comment">// 如果 被减数 大于等于 (减数+借位)则不需要进位</span></span><br><span class="line">            answer.digit[answer.length++] = temp;</span><br><span class="line">            carry = <span class="number">0</span>;   <span class="comment">// 如果没有借位需要把carry从1置为0否则会影响以后计算的结果</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            answer.digit[answer.length++]  = <span class="number">10</span> + temp;</span><br><span class="line">            carry = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(answer.digit[answer.length<span class="number">-1</span>] == <span class="number">0</span> &amp;&amp; answer.length &gt; <span class="number">1</span>)&#123;  <span class="comment">//去除结果中多余的0</span></span><br><span class="line">        answer.length--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>减法：<br>从被减数的低位到高位： 依次减去（减数对应权的位+低位相当前位的借位）。减后结果有两种情况：</p><ul><li>结果&lt;0 ,此时就需要向高位借位。 结果+10 修正， 借位置1</li><li>结果&gt;=0,此时结果无需修正，<strong>但是注意要将借位位置为0</strong><br>减法同样需要对于结果中多余的0进行修正</li></ul></blockquote><p>​        e. 除法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>/(<span class="keyword">const</span> BigInteger &amp;b) &#123;</span><br><span class="line">    BigInteger answer;</span><br><span class="line">    answer.length = length;</span><br><span class="line">    BigInteger remainder = <span class="number">0</span>;</span><br><span class="line">    BigInteger temp = b;   <span class="comment">// temp 存在的意义在于 比较运算符 &lt;= 前的对象不能是const 类型。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = length<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(remainder.length == <span class="number">1</span> &amp;&amp; remainder.digit[<span class="number">0</span>] == <span class="number">0</span>))&#123;   <span class="comment">//余数不为0</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = remainder.length<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j) &#123;  <span class="comment">//高位余数右移（向高位的方向移动）</span></span><br><span class="line">                remainder.digit[j+<span class="number">1</span>] = remainder.digit[j];</span><br><span class="line">            &#125;</span><br><span class="line">            remainder.length++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        remainder.digit[<span class="number">0</span>] = digit[i]; <span class="comment">//当前位并如余数中 ，成为新的被除对象</span></span><br><span class="line">        <span class="keyword">while</span>(temp &lt;= remainder)&#123;        <span class="comment">//除操作</span></span><br><span class="line">            remainder = remainder - temp;</span><br><span class="line">            answer.digit[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (answer.digit[answer.length<span class="number">-1</span>] == <span class="number">0</span> &amp;&amp; answer.length &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        answer.length--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>除法的操作：与加法、减法、乘法的不同之处在于，除法运算是从高位到低位的顺序<br>遍历被除数的每一位： </p><ol><li>高位的余数*10（右移一位）与当前位并入，作为新的被除对象。</li><li>对于被除对象的除操作可以表达为： 对被处对象不断的减去除数，对于最终商的当前位置不断加1，直到被除对象小于除数。此时被处对象的值就是当前位余数的值</li><li>遍历被除数的下一位</li></ol></blockquote><p>​        f. 取余<br>取余操作是与除法紧密相关的操作，即除法最终的余数，即位所求。<br>因此，取余的算法几乎与除法算法相同，只是移除了不需要保存的除法的商。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>%(<span class="keyword">const</span> BigInteger &amp;b) &#123;</span><br><span class="line">    BigInteger remainder = <span class="number">0</span>;</span><br><span class="line">    BigInteger temp = b;   <span class="comment">// temp 存在的意义在于 比较运算符 &lt;= 前的对象不能是const 类型。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = length<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(remainder.length == <span class="number">1</span> &amp;&amp; remainder.digit[<span class="number">0</span>] == <span class="number">0</span>))&#123;   </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = remainder.length<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                remainder.digit[j+<span class="number">1</span>] = remainder.digit[j];</span><br><span class="line">            &#125;</span><br><span class="line">            remainder.length++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        remainder.digit[<span class="number">0</span>] = digit[i];</span><br><span class="line">        <span class="keyword">while</span>(temp &lt;= remainder)&#123;</span><br><span class="line">            remainder = remainder - temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> remainder;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 机试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 研究生复试上机题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DevOps是什么?为什么我们需要DevOps?</title>
      <link href="/2019/04/18/DevOps%E6%98%AF%E4%BB%80%E4%B9%88-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81DevOps/"/>
      <url>/2019/04/18/DevOps%E6%98%AF%E4%BB%80%E4%B9%88-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81DevOps/</url>
      
        <content type="html"><![CDATA[<p>什么是 DevOps? 公司在推行 DevOps 的进程中应该注意什么？只有大公司才能从 DevOps 中收益？~</p><p>英文原文：《What is DevOps and Why Do We Need It?》作者：Skywell Software<br>原文链接：<a href="https://medium.com/datadriveninvestor/what-is-devops-and-why-do-we-need-it-82c2ef0a9d3d">https://medium.com/datadriveninvestor/what-is-devops-and-why-do-we-need-it-82c2ef0a9d3d</a></p><span id="more"></span><p>DevOps 被许多专家认为，是一种最好的方式去加强开发团队和运维团队的合作。但是 DevOps 不仅仅是一种方法，它更是一种文化使得软件开发过程中技术和业务双方合作更加高效，以使得产品上市时间缩短，产品<strong>整体</strong>的质量得以提升。在了解为什么 DevOps 这么重要之前，我们首先给它一个定义。</p><h3 id="DevOps-定义"><a href="#DevOps-定义" class="headerlink" title="DevOps 定义"></a>DevOps 定义</h3><p>DevOps 是，打破分隔 开发和运维团队壁垒，增强彼此之间合作的敏捷开发方法论的产物。但是如果你无法适当地应用这种正确的文化，DevOps 将沦为赶时髦的官话。这些使用 DevOps 文化所倡导的：</p><ul><li><p>责任共有—— 在许多公司，开发团队单单专注于产品的开发，对于系统的运维和管理不感兴趣，甚至回避如果这是别人的工作。如果在系统运行期间的监控工作成为开发团队的职责的一部分，他们很可能就能够体会到运维团队工作是的痛苦。DevOps 产生了一种新的方式，通过自动化部署和很好的日志记录来简化部署和维护工作。</p></li><li><p>团队自主化——高效的合作仅仅会发生在没有复杂的决策流程，开发和运维团队能够独立的做决定和改动的情况下。这个就需要新人你的团队、调整风险管理的策略并避免员工惧怕承担风险和失败的情况。</p></li><li><p>移除所有孤岛——一些公司记录过程并且将记录资料移交另一个团队，认为这是一个定期的合作。</p></li></ul><h3 id="DevOps-的整个流程"><a href="#DevOps-的整个流程" class="headerlink" title="DevOps 的整个流程"></a>DevOps 的整个流程</h3><p>DevOps 的整个流程由多个阶段组成，但是它们的如下列举的类似：</p><ul><li><p>计划——这个阶段包括你预期的开发进度的最初规划</p></li><li><p>编码——根据客户的需求开发应用程序</p></li><li><p>构建——合并各个你编写的代码</p></li><li><p>发布——如果测试通过，应用可以上线</p></li><li><p>部署—— 为了一些附加的用途，程序部署到云环境下</p></li><li><p>运维—— 在代码层面指导运维工作</p></li><li><p>监控—— 关注应用的运行情况，进行必要的改进以满足客户端的需求</p></li></ul><h3 id="为什么我们需要-DevOps？"><a href="#为什么我们需要-DevOps？" class="headerlink" title="为什么我们需要 DevOps？"></a>为什么我们需要 DevOps？</h3><p>DevOps 为软件开发公式带来的许多好处，例如，增加了创新的速度为客户更好的服务。能够使你在变化的市场环境下，灵活的调整产生更高的商业价值。由于频繁的迭代速度和节奏，你能更够快速的优化你的产品。这使得发布新特性的时间更短，发现和修复 bug 的速度更快。而更重要的是,快速的用户响应能力将成为你的业务的有力竞争优势。持续集成和持续发布就是从构建到部署的自动化软件发布过程的实践。</p><p>虽然产品化的步伐被加速，但是它在完成时依然如此的稳定可靠。通过 CI/CD 你能够测试所有产品的变更，更好的监控和日志记录将帮助你保持你的应用在生产环境中一直运行在最佳状态。安全流程不会被影响，因为合规策略将被细粒度的控制和管理配置技术自动化。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>如果你刚刚开始踏上 DevOps 落地之旅，设定切实可行的目标期望是必不可少的。当你迫切希望获得 DevOps 项目管理带来的好处时，你的团队可能经历着文化的冲击，因为他们一直习惯于原来独立的组织结构。改变已将建立好的流程并不容易，需要花费时间落实在人员、流程和信息等方面。这种文化的冲击将会带来新的目标表，你不能告诉的以前一个月迭代一个版本的团队，现在开始每天维护五个版本，这完全行不通。</p><p>当你意识到发布时间表应该在你的团队开始去接受 DevOps 文化和方法论时慢下来，你需要有一个更有组织的方式。需要许多的学习和训练，需要时间去习惯这所有的改变。在过渡过程中，建立一些重要的业务指标是重要的，如整体的收入和客户的满意度。以有各种本版的目的而创建多个版本是没有意义的。它必须对于你们的业务基础有效果。</p><p>考虑到 DevOps 所带来的优点，可以负责任的说那些没有完成 DevOps 进程化的公司将面临落后的风险。一个普遍的错误观点是 DevOps 仅仅针对大公司，但是小型和中等规模的公司也能够从中获得 DevOps 所提供的好处。事实上，像 Facebook、Netflix 和 其他的集团公司能够实现如此快速的增长，是因为他们很早就采用了 DevOps 的模式，使得他们能够相对于竞争对手更快的提供新功能给用户。因此，如果你还没有开始 DevOps 的进程，你已经落后于你的竞争者了。</p>]]></content>
      
      
      <categories>
          
          <category> 翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> open source </tag>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-Web框架介绍</title>
      <link href="/2019/04/17/Python-Web%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/"/>
      <url>/2019/04/17/Python-Web%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p>针对 Python 中的 全栈框架（Django） 和 微型框架（Flask）行进介绍，对于一些应用特定场景的其他框架做简单的说明~</p><p>英文原文：《A Complete Guide to Python Web Frameworks》作者：Premjith B P K</p><p>原文链接：<a href="https://opensourceforu.com/2019/04/a-complete-guide-to-python-web-frameworks/">https://opensourceforu.com/2019/04/a-complete-guide-to-python-web-frameworks/</a></p><span id="more"></span><p>Web 框架就是一些函数库，通过使用这些库使得 Web 开发更加简单快捷。Python 作为多功能的编程语言，有许多 Web 框架，像 Django、Web2py、Flask 和 Bottle等等。接下来我们将来介绍这些框架的相关情况。</p><p>对于开发 Web 应用程序的团队，Python 是一种主流且非常灵活的编程语言。应用程序以一种模块化的开发模式进行开发，使得开发者和 Web 框架紧密的联系起来。调用框架中提供的大量的解决方案，使得开发者能够更加专注于应用程序的逻辑业务，不再为重复和低优先级的任务所扰。</p><p>如今，开发者尝试使用强大功能的 Python 框架去解决解决一些具体的实现细节，这个加速了原型设计和开发的进程。从针对企业的强大全栈框架到适合开发小型专业的工具的超轻量级微框架流，目前有各种各样的流行的 Python Web 框架。</p><p>Python Web 框架在很大程度上削减了 Web 应用开发的成本、人力和时间周期。我们将分享这些流行框架中一些重要功能点，帮助在你开发 Web 应用程序中做的更好。我们希望能够帮助你确定针对自己实际需求的最合适框架。</p><h3 id="框架的作用"><a href="#框架的作用" class="headerlink" title="框架的作用"></a>框架的作用</h3><p>Web 框架使得开发者不需要去关注 Socket、协议 和 线程管理 等细节，专注于 Web 应用程序和服务的开发。框架的完成的大部分职责集中于 cookies 的处理、参数的获取以及 session 的处理等。主流的 Web 框架分为两大类：全栈框架 和 微型框架。</p><h3 id="选择全栈框架还是微型框架"><a href="#选择全栈框架还是微型框架" class="headerlink" title="选择全栈框架还是微型框架"></a>选择全栈框架还是微型框架</h3><p>当你在框架选择时，你应该将项目规模和复杂性作为考虑的重要因素。如果你希望应用的开发以业务功能为主，需要与其他的周边框架协作，全栈框架的选择将能够减少整个团队在开发时间和开发任务。但是，如果你在开发一个小型、简单需求的少的项目时，微型框架是你最好的选择。另一个需要考虑的问题是：你需要框架帮你完成多少事情？全栈 Web 框架包含了开发一个功能丰富 Web 应用的所有组件—框架生成器、访问列表和模板等。这使得你的团队能根据不同的需求创建出相应的页面和应用。对于希望快速开发出产品的团队这是一个很好的选择，因为这是使得他们更加专注于应用的开发而不是与之相关的周边事情。如果你有复杂的个性化需求或者已经在开发多种不同类型的定制化的软件，不管在什么情况下，你都不应该使用这些框架。</p><h3 id="全栈框架"><a href="#全栈框架" class="headerlink" title="全栈框架"></a>全栈框架</h3><p>有许多新且完备的全栈 web Python框架选择方案：如主流的框架 TurboGears 2、Pylons 和 Web2py。但是其中最流行的是 Django。</p><ul><li><p>Django</p><p>Django 是流程的 Python 框架，至于具体的原因大家不难理解。大量的网站使用了 Django，从出版社到社交媒体和分享网站，再到重要的<strong>机构</strong>和非盈利组织。由于 Django 最初开发于编辑部门，因此 华盛顿邮报 和 卫报 运行在该框架上也不是意外。一些新公司和初创公司像 Eventbrite 和 Disqus 已经在往 Django 迁移并且在提高完成度。同时社交巨头 Instagram 和 Pinterest 已经使用该框架去开发他们的动态 Web 应用。 </p><p>当考虑到框架时，Django 以快速开发 和 对业务开发者友好 而著称。作为一种“可插拔式”的框架，它提供了所有你需要的基础的组件 认证、可渲染模板、ORM 和路由等。相比于其他的主流 Web 框架，它有良好的技术文档。</p><p>通过对大量选择的处理，Django 能够在很大程度上减少新项目的引导时间。但是，在获得速度的同时也牺牲了长期开发维护的灵活性。例如，Django 内置的 ORM 在大部分情况下效果显著。但是，它无法像被称为最好的 Python 数据库抽象工具 SQLAlchemy那样有突破性。你可以想象在 Django 下使用 SQLAlchemy，但是那样你讲失去 Django 中的一些一开始就吸引人的重要功能。</p></li></ul><ul><li><p>Web2py</p><p>Web2py 是另一个主流的全栈框架。需要牢记的是 Web2py 不兼容 Python3。虽然 Web2py 的早期开发者已经保证会去开发兼容 Python3 的新版，但时至今日依然没有新版依然没有正式发布。</p><p>即便相较目前最新发布的 Python 版本已经十年时间了，Web2py 依然在许多大型企业中使用，其中就包括跨国银行。使得这个老 Web 框架依然有许多开发者在使用的原因，是他独一无二的功能。一方面，它即能够像 Django 一样简单易学习，又兼具灵活性和可扩展能力。不管是 AWS 还是 Google App Engine 中 VPS， 同样的一段代码几乎可以应用到 所用的使用 SQL  或者 Mongo DB 的 VPS 中 。</p><p>Web2py 有优秀的文档手册和活跃的社区在其背后作为强大的支持。另一个亮点在于 Web2py 有自己的IDE，其中包含了 代码编辑器、调试器、bug 票务框架 和 单独的票务部署功能等等。如果你的团队在未来几年中开发以 Python2 为主，或者希望充分利用已有的众多 Python 库和应用，那么 Web2py 框架非常符合你的要求。</p><p>Pyramid 确切的来说不是一个全栈的 Web 框架，并且自称是符合“金发姑娘”原则（适度原则）的框架。Pyramid 有这丰富的特性不会限制使用某种特定的方式去处理事情。作为一种轻量级的框架，不会使你随着应用的开发陷入独自一人的窘境。由于良好的通透性和模块化，Pyramid 是 Python 老鸟最喜爱的开发框架。不仅中等规模的团队在使用，像 Mozilla、Yelp、SurveyMonkey 和 Dropbox 这样的科技巨头也在使用。</p><p>事实上，Pyramid 框架中几乎所有的组件都能够替换掉。你能够使用你的数据库接口，甚者连接任何你想要连接的数据库。它不会像Django那样授权处理具体的选择，也不鼓励自动化处理具体任务的奇妙功能。这使得它不会表现预期的或者吸引人的方式。</p><p>Pyramid 流程的原因是它安全的解决方案，使得访问控制记录的创建和检查变得简单。另一个值得关注的创新功能是 Pyramid 的从 URL 到 code 的映射的路由系统，这使得最终创建 RESTful 接口变得容易。</p></li></ul><h3 id="微型框架"><a href="#微型框架" class="headerlink" title="微型框架"></a>微型框架</h3><p>考虑到你可能不需要全面和丰富的全栈框架。如今，新一代的 Web 应用需要许多可以插拔的部分，包括数据库抽象层，框架认证 和 可配置的访问控制规则。但是也有大部分的 Web 应用不要这些模块。对于这种项目，微型框架应该是最需要的。</p><p>这些超轻量级的应用被开发的目的是使得一些死掉的 Web 应用重新能被使用并且尽可能的运行的更快。他们的设计的功能精简—————— 对一些能通过安装一些其他的库满足的功能专门进行了移除。使用这些透明的方法的好处是使你的代码更加的简洁清晰，并且网站运行速度更快。这就是为什么微型框架没有全栈框架那么抽象。相比于对初学者友好的 Web 框架，你编写的代码将需要触及HTTP 的一些功能。</p><ul><li><p>Flask: </p><p>Flask 无疑是最有名的 Python 微型框架，并且一直是最有名的 Python 结构中的佼佼者。和 Django 一样，开发 Flask 的目的是使得 Web 应用开发并尽可能运行的更快。虽然是微型框架，但 Flask 已经被一些大公司所使用，其中包括 LinkedIn 和 Pinterest。</p><p>无论如何，这是个较量。相比 Django，Flask是那些又小又简单项目的理想选择。因此，你可以期待 Web 服务器开发将支持 Google App Engine 并且 内置单元测试功能。Flask 不支持 数据库抽象层 和 表单验证，且自动上传的功能被禁用。但是，每一个这些功能都能够通过外部扩展来实现。例如一些主要的扩展包括 SQLAlchemy 数据库 、 Jinja2 模板和 CouchDB。</p><p>一些 Python 开发者会选择 Flask 而非 Django ，因为前者越来越 Pythonic。这更加符合 Pytho 之禅的原则：一种方式完成事情，并且相应的代码能够表明在做什么。如果你非常想要从头开始使代码更加简洁明了，Flask 应该是你合适的选择。</p></li><li><p>Bottle: </p><p>Bottle 是另一个主流的微型框架。它从一开始就是为创建 Web API 而生，这也是它最好的使用案例。Bottle 更加奇妙的地方在于，它尝试使用一个单一的文件做所有的事情，这给我们一个重要的认识：它的设计是多么的 micro。</p><p>Bottle 包含一些开箱即用的功能包括 模板、路由、应用程序 和 一些在 WSGI 标准上的基础抽象。和 Flask 一样，有你的编码将更接近底层相比于全栈框架。尽管如此，Bottle 已经被 Netfilx 用于创建 Web 接口。</p></li></ul><h3 id="其他一些流行的框架"><a href="#其他一些流行的框架" class="headerlink" title="其他一些流行的框架"></a>其他一些流行的框架</h3><p>我们已经介绍了许多广泛使用的 Python Web 框架，你可以从中有不同的选择。接下来将了解一些在特定情况下表现优良的其他框架。</p><p>Tornado 是专为解决 C10k 问题而开发的 Python Web 框架。（在正确配置下，它能够通过异步 I/O 处理超过 10,000 并发连接数）这个对于那些需要高质量且大量并发用户的项目是一个巨大的吸引力。</p><p>CubicWeb 是一个奇妙的 Web 框架，它完全不同其他的 Web 框架。它是语义 Web 的一种，用外行人的话将，它是一个通过减少对于电脑系统性能要求的方式来显示信息的系统。它使用一个单独的概念替代了 MVC 模型中的 model 和 view ，即数据块———能够由于开发不同的组件，有点像 Web 上的 Docker。</p><p>Phalcon 是一个专注于创建云 API 的微型框架。和其他微型框架一样，它保持的较少的依赖，并且与复杂功能保持着一个明智的距离。但是，不同于其他框架，它不是为 HTML 的页面而开发的，而是，为更快的创建 RESTful API 而生。</p><p>即便 Android 有非常优秀开箱即用的 SDK ，但使用 Python 实现替代 Java 实现有着巨大的好处，对于网站和应用开发（使用 Kivy 移动应用开发的 Python 开源库 ）。因为 Python 提供了更快的时间转化和库的复用。</p><p>Python 作为一个可靠、安全的开发语言，被用于安全敏捷 Web 应用的开发。作为可靠备选中的佼佼者，它减少了顶尖稳定 Web 应用和网站的开发周期。你可以在开发你的下一个项目时，咨询有经验的 Python 开发人员，以得到更好的指导。</p>]]></content>
      
      
      <categories>
          
          <category> 翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> open source </tag>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何通过在不写代码的情况下做开源</title>
      <link href="/2019/04/16/%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E5%9C%A8%E4%B8%8D%E5%86%99%E4%BB%A3%E7%A0%81%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E5%81%9A%E5%BC%80%E6%BA%90/"/>
      <url>/2019/04/16/%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E5%9C%A8%E4%B8%8D%E5%86%99%E4%BB%A3%E7%A0%81%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E5%81%9A%E5%BC%80%E6%BA%90/</url>
      
        <content type="html"><![CDATA[<p>本文作者阐述了，如果在不写代码的模式下，优雅的为开源事业做贡献~</p><p>英文原文：《How do you contribute to open source without code?》作者： Chris Hermansen<br>原文链接：<a href="https://opensource.com/article/19/4/contribute-without-code">https://opensource.com/article/19/4/contribute-without-code</a></p><span id="more"></span><p>我最早开始为开源做贡献要追溯到20世纪80年代中期。那是我们组织第一次连接到UseNet网站，在那里我们了解到了代码贡献以及为其开发和维护的机会。</p><p>今天，有很多种方式去做贡献，从代码贡献到制作教程。</p><p>我将一步步说明代码贡献这个问题，而不是仅仅指出“那些写代码却不认为自己是开发者的人，依然能够贡献代码”。我愿意告诉每个人：有很多种不通过写代码的方式贡献开源社区的方法。具体谈谈这种不写代码的贡献方式。</p><h3 id="提交-bug-报告"><a href="#提交-bug-报告" class="headerlink" title="提交 bug 报告"></a>提交 bug 报告</h3><p>一种主要、集中的代码贡献方式被称为“不要害怕创建一个体面的 bug 报告”，接下来得内容主要是关于这中方式。有时，编写一个相当好的的 bug 报告是一件相当有挑战的事情。比如：</p><ul><li><p>一些 bug 可能很难记录并秒速。例如 一个带有一系列的不可知代码的冗长复杂信息可能在计算机启动时闪现，或者导致一些奇怪的现象并且显示屏没有相应的错误信息产生。</p></li><li><p>一些 bug 可能是很难复现的。它仅仅在一些特定的 软件/硬件 配置下，并且很难再次触发，对于某些具体的问题可能并不明显。</p></li><li><p>一些 bug 可能涉及到一些非常具体的庞大、混乱、复杂开发环境配置，以至于 bug 的提交非常困难。需要花力气去创建一些精简的测试案例。</p></li><li><p>当提交一个分支版的软件 bug 时，维护者会建议提交上流版本的 bug 测试情况。在当前版本不是社区上流推崇的版本的分支时，这将产生许多工作量。（这个通常发生在分支版本的维护滞后于官方当前的发行版和开发版时）</p></li></ul><p>尽管如此，我依然倡导 未来的 bug 提交者 能够重视并尽可能详细的记录和说明 bug 的情况。</p><p>在开始时，通过自己喜欢的检索工具去寻找相关的 bug 报告，看看它们是如何描述，怎样展现等等。另一种重要的需要知道的是 bug 提交报告的正式术语，关于你用的系统分发版本（Fedora、openSUSE、Ubuntu） 或者 使用的软件（LIbreOffice、Mozilla） 。</p><h3 id="解决用户的问题"><a href="#解决用户的问题" class="headerlink" title="解决用户的问题"></a>解决用户的问题</h3><p>我潜水并偶尔参与到各种各样的邮件列表和论坛，像 Ubuntu quality control 小组或者论坛、LinuxQuestions.org 和 the ALSA users’ 邮件列表。在这里，主要的贡献不是 bug 的提交和修复，更多的是编写软件相关的使用案例。当有人加入讨论并解决他们的特殊问题时，每一个人都有一种喜悦。</p><h3 id="为开源而创作"><a href="#为开源而创作" class="headerlink" title="为开源而创作"></a>为开源而创作</h3><p>最后，另一个我喜欢的贡献方式是通过创作一些关于开源软件的使用的资料。包括 如何使用的指南、一个针对特殊问题，同类软件之间的测评 以及 对于一个感兴趣领域的探索（就我而言，使用开源的音乐播放器来聆听音乐）。一个类似的方式是制作软件使用教程视频，以一种简单的方式录制一些困难的桌面操作，如使用GIMP创作一个引人注目的logo。如果你熟悉两种或者多种语言可以考虑将目前的已有的一些文字教程和视频教程翻译为另一种语言。</p>]]></content>
      
      
      <categories>
          
          <category> 翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> open source </tag>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你应该知道的markdown语法</title>
      <link href="/2019/03/13/%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84markdown%E8%AF%AD%E6%B3%95/"/>
      <url>/2019/03/13/%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84markdown%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>关于 markdown 常用的一些语法，方便我们以 markdown 的方式记录生活~</p><span id="more"></span><p>你还在用word写笔记、心得体会、说明文档之类的东东吗？是不是还在为word的排版而烦恼? ^_^<br>快来试试,代码圈最风靡的说明文档编写姿势吧，markdown 让你在了解几分钟语法的情况,专注于内容的输出。下面我们一起来看一看这些经常用到的语法~</p><!--  --><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 大秦帝国</span></span><br><span class="line"><span class="section">## 长平杀降</span></span><br></pre></td></tr></table></figure><p>标题总共有六级</p><p>效果：</p><img src="/2019/03/13/%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84markdown%E8%AF%AD%E6%B3%95/%E6%A0%87%E9%A2%98.png" class="" title="标题效果"><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; 白起奉亲昭襄王诏令，坑杀赵国数十万放下武器的士兵</span></span><br><span class="line"><span class="quote">&gt;</span></span><br><span class="line"><span class="quote">&gt; &gt; 白起： 秦国上将军，战国时期四大战神之首。</span></span><br><span class="line"><span class="quote">&gt;</span></span><br><span class="line"><span class="quote">&gt; ## 武安君之死</span></span><br><span class="line"><span class="quote">&gt;</span></span><br><span class="line"><span class="quote">&gt; 硬候范睢建议秦昭襄王赐死辞官回乡的白起</span></span><br></pre></td></tr></table></figure><p>效果：</p><img src="/2019/03/13/%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84markdown%E8%AF%AD%E6%B3%95/%E5%BC%95%E7%94%A8.png" class="" title="引用效果"><p>对于引用可以在内部嵌套 markdown 的语法</p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">战国名士</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 苏秦</span><br><span class="line"><span class="bullet">-</span> 张仪</span><br><span class="line"><span class="bullet">-</span> 公孙衍</span><br><span class="line"><span class="bullet">-</span> 孟尝君</span><br></pre></td></tr></table></figure><p>效果：</p><img src="/2019/03/13/%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84markdown%E8%AF%AD%E6%B3%95/%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8.png" class="" title="无序列表效果"><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">战争的要素</span><br><span class="line"><span class="bullet">1.</span> 钱粮</span><br><span class="line"><span class="bullet">2.</span> 兵马</span><br><span class="line"><span class="bullet">3.</span> 将领</span><br></pre></td></tr></table></figure><p>效果：</p><img src="/2019/03/13/%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84markdown%E8%AF%AD%E6%B3%95/%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8.png" class="" title="有序列表效果"><h3 id="代办事项列表"><a href="#代办事项列表" class="headerlink" title="代办事项列表"></a>代办事项列表</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> [ ] 阅读孙皓晖教授的书籍</span><br><span class="line"><span class="bullet">-</span> [x] 观看大秦帝国之裂变</span><br></pre></td></tr></table></figure><p>效果：</p><img src="/2019/03/13/%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84markdown%E8%AF%AD%E6%B3%95/%E4%BB%A3%E5%8A%9E%E4%BA%8B%E9%A1%B9%E5%88%97%E8%A1%A8.png" class="" title="代办事项列表效果"><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">\<span class="code">`\`</span>\`c</span><br><span class="line"><span class="section">#include <span class="xml"><span class="tag">&lt;<span class="name">stdio.h</span>&gt;</span></span></span></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"><span class="code">    printf(&quot;hi~,markdowner ^-^ \n&quot;);   </span></span><br><span class="line"><span class="code">    </span></span><br><span class="line"><span class="code">    return 0;</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code">\`\`\`</span></span><br></pre></td></tr></table></figure><blockquote><p>代码块的语法以```为开头和结尾，此处由于博客展示的原因（不知道代码块的语法如何做到不转义，如果有知道的小伙伴，还请指教^_^）。</p></blockquote><p>效果：</p><img src="/2019/03/13/%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84markdown%E8%AF%AD%E6%B3%95/%E4%BB%A3%E7%A0%81%E5%9D%97.png" class="" title="代码块效果"><h2 id="内容标识"><a href="#内容标识" class="headerlink" title="内容标识"></a>内容标识</h2><p>斜体、加粗</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="emphasis">_白起的妻子是赵国人?_</span></span><br><span class="line"><span class="strong">**白起一生从无败战**</span></span><br></pre></td></tr></table></figure><p>效果：</p><img src="/2019/03/13/%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84markdown%E8%AF%AD%E6%B3%95/%E6%A0%87%E8%AF%86.png" class="" title="标识效果"><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">Dribbble</span>](<span class="link">https://dribbble.com/shots</span>)</span><br></pre></td></tr></table></figure><p>效果：</p><img src="/2019/03/13/%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84markdown%E8%AF%AD%E6%B3%95/%E9%93%BE%E6%8E%A5.png" class="" title="链接效果"><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">coding man</span>](<span class="link">https://lifeisbianry_codeingman.jpg</span>)</span><br></pre></td></tr></table></figure><p>效果：</p><img src="/2019/03/13/%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84markdown%E8%AF%AD%E6%B3%95/%E5%9B%BE%E7%89%87.png" class="" title="图片效果"><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">赵国阵营</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 廉颇</span><br><span class="line"><span class="bullet">-</span> 李牧</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">秦军阵营</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 蒙骜</span><br><span class="line"><span class="bullet">-</span> 白起</span><br></pre></td></tr></table></figure><p>效果：</p><img src="/2019/03/13/%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84markdown%E8%AF%AD%E6%B3%95/%E5%88%86%E5%89%B2%E7%BA%BF.png" class="" title="分割效果"><h2 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~~秦军与赵军在长平进行了一场大对决~~</span><br></pre></td></tr></table></figure><p>效果：</p><img src="/2019/03/13/%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84markdown%E8%AF%AD%E6%B3%95/%E5%88%A0%E9%99%A4%E7%BA%BF.png" class="" title="删除线效果"><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>在要展示目录的文章头部输入<code>[TOC]</code><br>效果：</p><img src="/2019/03/13/%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84markdown%E8%AF%AD%E6%B3%95/%E7%9B%AE%E5%BD%95.png" class="" title="目录效果"><h2 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">白起[^1]是战神，他曾经和赵括在长平进行战争[^2]</span><br><span class="line"></span><br><span class="line">[<span class="symbol">^1</span>]:<span class="link">秦国上将军</span></span><br><span class="line">[<span class="symbol">^2</span>]:<span class="link">杀人的机器</span></span><br></pre></td></tr></table></figure><p>效果：</p><img src="/2019/03/13/%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84markdown%E8%AF%AD%E6%B3%95/%E8%84%9A%E6%B3%A8.png" class="" title="脚注效果">]]></content>
      
      
      <categories>
          
          <category> 展现形式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdwon </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
