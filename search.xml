<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>window 使用的tip</title>
      <link href="/2022/12/05/window-%E4%BD%BF%E7%94%A8%E7%9A%84tip/"/>
      <url>/2022/12/05/window-%E4%BD%BF%E7%94%A8%E7%9A%84tip/</url>
      
        <content type="html"><![CDATA[<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><ol><li>win+E：打开资源管理器</li><li>win+D：隐藏/显示所有桌面上界面</li><li>win+L：锁屏</li><li>win+shift+s：截图</li><li>win+Tab：在打开的应用程序间切换</li><li>Alt + 双击左键：查看文件属性</li><li>win +. :调出window 下的表情和公式符</li></ol><p>应用窗口快速缩小放大</p><p>Alt + 空格 + x ：全屏</p><p>Alt + 空格 + r ：还原</p><p>Alt + 空格 + n：缩小</p><blockquote><p>通过鼠标双击应用窗口的标题栏,也可以实现全屏和窗口还原操作。</p></blockquote><p>鼠标左键拖动文件到另一地方时：</p><ul><li>按住Shift并释放为移动文件操作</li><li>按住Ctrl并释放为文件复制</li></ul><h2 id="实用软件"><a href="#实用软件" class="headerlink" title="实用软件"></a>实用软件</h2><ol><li>空格键查看文件内容——quicklook</li><li>快速文件检索——everything</li></ol>]]></content>
      
      
      <categories>
          
          <category> 电脑使用tips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> win </tag>
            
            <tag> 效率 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 系统管理与常用指令</title>
      <link href="/2022/12/05/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E4%B8%8E%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
      <url>/2022/12/05/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E4%B8%8E%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="linux的历史"><a href="#linux的历史" class="headerlink" title="linux的历史"></a>linux的历史</h2><ol><li><p>unix</p><p> 1970，贝尔实验室的工程师因开发的游戏无法继续在贝尔实验室的系统上继续使用，开发了unix来继续运行游戏</p><p>特点：</p><ul><li>多任务、多用户<ul><li>多用户：多个用户可以在同一时间使用同一个linux系统</li><li>多任务：Linux中可以同时运行多个程序，执行多个任务</li></ul></li><li>有网络</li><li>并行处理，稳定性好</li><li>C编写，可移植性强</li></ul></li><li><p>linux</p><p>1987，荷兰教授因unix系统版权被收回，讲操作系统原理课不方便。开发了minix。芬兰的linux在minix上增加功能，并与1991年将其上传到互联网成为linux（跟准确的说linux发布的是<strong>linux kernel</strong>）</p><p>特点：</p><ul><li>承袭unix的特点（多任务、多用户、网络、并行处理、稳定性和移植性好）</li><li>常用来搭建网络服务器，LAMP（linux + Apache + MySql + PHP） 和 LNMP （linux + Nginx+ MySql + PHP）就是使用极为普遍的web服务平台。</li><li>广泛应用于嵌入式系统。手机、机顶盒、路由器等。</li></ul></li></ol><h2 id="linux的内核——kernel"><a href="#linux的内核——kernel" class="headerlink" title="linux的内核——kernel"></a>linux的内核——kernel</h2><p>kernel：</p><p>​    完成操作系统<strong>最基本功能</strong>的程序。</p><p>​    运行在硬件之上，是所有应用程序运行的基础。是计算机硬件和用户之间的桥梁。通过它，我们才能让CPU处理各种数据，在硬盘中读写各种数据，与网络上的计算机进行通信</p><p>最基本的功能：</p><p>​    管理形形色色的硬件设备</p><p>​    提供用户操作界面</p><p>​    提供应用程序的运行环境    </p><p>linux = kernel + 应用程序（linux系统桌面也是应用程序）</p><h2 id="linux的发型版本"><a href="#linux的发型版本" class="headerlink" title="linux的发型版本"></a>linux的发型版本</h2><p>linux kernel 符号GUN协议，任何人可以免费使用，并修改。</p><ol><li><p>RedHat Linux</p><p>RHEL（企业付费版，提供技术支持和定制第三方软件）和 Fedora（免费版）</p></li><li><p>CentOS</p><p>在RHEL开放出的源代码基础上二次编译而成的linux系统，<strong>命令操作和服务配置方法与RHEL相同</strong>，去掉了RedHat的收费套件</p></li><li><p>Debian</p><p>以稳定著称的免费linux系统，有很多服务器采用Debian作为操作系统。</p><p>基于Debian二次开发出的有：Ubuntu 和 Kali Linux</p></li><li><p>SUSE</p><p>在欧洲流行的linux发行版，不适合初级用户。</p><p>有 企业版SUSE 和 openSUSE</p></li></ol><h2 id="VMware"><a href="#VMware" class="headerlink" title="VMware"></a>VMware</h2><h3 id="虚拟机的架构"><a href="#虚拟机的架构" class="headerlink" title="虚拟机的架构"></a>虚拟机的架构</h3><p>我们平时使用的虚拟机，是寄居架构（虚拟化软件在操作系统上安装）。企业使用的是裸金属架构（原生架构：在硬件上直接安装虚拟化软件），两者的性能有天壤之别。</p><h3 id="虚拟机的网络"><a href="#虚拟机的网络" class="headerlink" title="虚拟机的网络"></a>虚拟机的网络</h3><ol><li><p>桥接模式（bridged）</p><p>虚拟机类似一台物理机，可以访问外网，外网的计算机也可以访问该虚拟机。</p><p>将虚拟机的IP设置为与物理机的IP同一个网段，则虚拟机可以与该局域网中的物理机和其他主机通信。</p><p>桥接模式对应的虚拟网络名称：VMnet0</p><p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20221205000442.png" alt="image-20210430210749765"></p></li><li><p>仅主机模式（host-only）</p><p>虚拟机在一个独立的虚拟网络中，与物理网络之间是隔离的。所有仅主机模式的虚拟机之间以及虚拟机与物理机之间可以互相通信，但是它们与外部网络的主机无法通信。</p><p>仅主机模式对应的虚拟网络名称：VMnet1，物理主机要与仅主机模式下的虚拟机通信，需要保证VMnet1网卡的IP与虚拟机IP在同一网段。</p><p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20221205000450.png" alt="image-20210430211522637"></p></li><li><p>NAT模式（网络地址转换）</p><p>NAT模式对应的虚拟网络名称：VMnet8。</p><p>与仅主机模式类似，虚拟机也是处于与物理网络隔离的独立的网络中。但是此时，物理主机作为一个支持NAT功能的代理服务器，虚拟机可以作为客户端，通过物理主机的IP地址访问外部网络的计算机，但是由于NAT技术的特点，外部网络中的计算机无法主动与NAT模式下的虚拟机进行通信，只有虚拟机到外部网络计算机的单向通信。</p></li></ol><h2 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h2><p>shell也属于应用程序。</p><p>shell 就是 Command Line Interface。将用户的命令解释为系统内核可以理解的语言，内核执行以后，将结果以用户可以理解的方式显示出来。</p><p>![image-20210430212829106](/Users/lifeisbinary/Library/Application Support/typora-user-images/image-20210430212829106.png)</p><p>shell的实现有多种：sh、Csh、Zsh和Bash。CentOS默认使用Bash，这也是目前应用最为广泛的一种shell。</p><h3 id="命令提示符"><a href="#命令提示符" class="headerlink" title="命令提示符"></a>命令提示符</h3><p><code>[lifeisbinary@centos-linux ~]$</code>        【终端当前用户@主机名 当前所在目录】    $ ——普通用户； #——管理员</p><p>用户切换命令： <code>su - root</code>     实现不同权限的操作 </p><p>用户在本地所打开的终端称为虚拟终端TTY，用户在远程所打开的终端称为伪终端PTS。</p><h3 id="Shell的格式"><a href="#Shell的格式" class="headerlink" title="Shell的格式"></a>Shell的格式</h3><p><code>命令名 【选项】 【参数】</code></p><p>命令名：必不可少</p><p>选项：调节命令的具体功能，用“-”开头。选项即可以有一个，也可以有多个。 如 <code>ls -l -a</code> 与 <code>ls -la</code></p><p>​            部分选项以“–”开头， 如<code> ls --help</code></p><p>shell中，一行可以输入多条命令，命令之间用分号隔开。如果在一行命令后加上 “\”，可以进行换行</p><p>命令区分大小写</p><h3 id="关机和重启命令"><a href="#关机和重启命令" class="headerlink" title="关机和重启命令"></a>关机和重启命令</h3><p>单用户时使用，只保存当前用户的更改，其他用户的更改会丢失。</p><p><code>poweroff</code></p><p><code>reboot</code></p><p>多用户时使用，因为可以发送提示信息所以更加安全</p><p><code>shutdown -h now</code>     //立即关闭系统</p><p><code>shutdown -r now</code></p><p><code>shutdown -h +15</code>     //15min后重启</p><p><code>shutdown -h +15 ‘the system will be rebooted!!&#39;</code>     //    15min以后系统重启，并发送设定的信息给登陆到本机的各用户</p><p><code>Ifconfig 网卡名 IP地址</code>     //配置网卡的IP地址</p><blockquote><p>tip：如果两台主机之间网络通信出现问题，可以使用ping从一台主机去ping另一台，如果ping不通，可能是因为另一台主机开启了防火墙。可以通过另一台主机去pint当前这一台，来排出这种可能性。</p></blockquote><p>远程登录到linux，以前采用telnet，但该方式的数据以明文传输不安全。现在主要采用SSH，默认端口号TCP22</p><p>远程登录使用的工具： XShell、SecureCRT、PuTTY</p><h1 id="文件管理和目录管理"><a href="#文件管理和目录管理" class="headerlink" title="文件管理和目录管理"></a>文件管理和目录管理</h1><p>Linux中一切皆文件：数据、其他资源（包括硬件设备）以文件的形式组织起来。例如，硬盘以及硬盘中的每个分区在Linux中都被视为一个文件。用户可以像使用普通文件那样对设备进行操作。</p><p>Linux使用纯文本保存配置信息：无论是Linux系统本身还是应用程序，他们的配置信息往往都保存在一个纯文本的配置文件中。如果需要改动系统或者应用程序中的某项功能，那么只需要编辑相应的配置文件。</p><h3 id="目录管理"><a href="#目录管理" class="headerlink" title="目录管理"></a>目录管理</h3><p>Linux系统使用“/”进行分隔路径中目录的分隔（window使用“\”）</p><p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20221205000555.png" alt="image-20210501004927526"></p><blockquote><p>/mnt    一般是空的，用来临时挂载存储设备</p><p>/proc    存储系统内核和进程的相关信息</p><p>/run      存放进程产生的临时文件，系统重启后会消失</p><p>/lost+found   存放系统意外崩溃或者关机时产生的文件碎片</p></blockquote><p><code>pwd</code>         //打印当前目录</p><p><code>cd - </code>        //在最近工作过的两个目录之间切换</p><h4 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h4><p><code>ls</code>  or <code>ls 文件或目录名</code>             //目录内容列表展示，结果：蓝色——目录，灰色——通文件，绿色——可执行文件，红色——压缩文件，浅蓝色——链接文件</p><p><code>ls -a</code>      //显示所有文件，包含隐藏文件</p><p><code>ls -l</code>     //显示美国文件的详细信息<img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20221205000605.png" alt="image-20210501112709908"></p><ul><li><p>drwxr-xr-x: </p><ul><li>第一个字符：d——文件夹，- ——普通文件，l——链接文件，【<strong>硬件设备</strong> c——字符设备，b——块设备】</li><li>其余六个代表文件的权限</li></ul><blockquote><p>设备文件分为块设备和字符设备，块设备支持随机访问，而字符设备则只能线性访问。键盘是字符设备，硬盘是块设备。</p></blockquote></li><li><p>2： 被硬链接的次数，文件默认为1，目录默认为2。（linux中的链接文件类似于window中的快捷方式）</p></li><li><p>lifeisbinary： 文件的所有者</p></li><li><p>lifeisbinary:  文件所属的组</p></li><li><p>4096：文件的大小，对于目录只显示目录本身的大小，不显示目录所包含内容的大小</p></li><li><p>6月 12 2020：文件被创建或者最近一次修改的时间</p></li><li><p>Desktop：文件名</p></li></ul><p><code>ls -ld 目录</code> 显示目录本身的信息而不是，目录内部的信息</p><p><code>ls -lh  </code>  文件的容量用 KB、 MB、GB等单位显示</p><h4 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h4><p><code>touch newfile</code>         //创建新文件</p><h4 id="mkdir-和-rmdir"><a href="#mkdir-和-rmdir" class="headerlink" title="mkdir 和 rmdir"></a>mkdir 和 rmdir</h4><p><code>mkdir newDirectory</code>     //创建文件夹</p><p><code>mkdir a b c</code>            //创建多个文件夹</p><p><code>mkdir -p ~/newfilm/HKfilm</code>             //创建嵌套的多级目录结构</p><h4 id="cp、mv和rm"><a href="#cp、mv和rm" class="headerlink" title="cp、mv和rm"></a>cp、mv和rm</h4><p>cp 复制文件</p><p>​        <code>cp /etc/network.conf /home/ </code>             //复制到指定的文件夹</p><p>​        <code>cp /etc/network.conf /home/newnetwork.conf</code>              //复制到指定文件夹并重新命名</p><p>cp 复制文件夹</p><p>​        <code>cp -r /home/film/  /home/newfile/</code>              // -r 递归复制所有文件和目录</p><p>​        <code>cp -p</code>         // -p 在复制中保证文件和目录的属性（所有者和所属组）不发生变化</p><p>mv 移动文件或者重新命名</p><p><code>mv /home/film/china.txt /home/film/china/</code>     //移动文件</p><p><code>mv /home/film/china.txt /home/film/currentFilm.txt</code>   //文件重新命名</p><blockquote><p>mv 在移动文件夹时不需要添加像cp命令一样的-r选项，就可以直接移动文件夹</p></blockquote><p>rm 文件删除、目录删除</p><p><code>rm newfile.txt</code>    //文件删除</p><p><code>rm -f newfile.txt</code>    //文件删除，跳过询问确认</p><p><code>rm -rf film/</code>        //文件夹删除</p><blockquote><p>在生产环境中，为了安全起见一般不是使用 rm -rf。如果要删除某文件或者目录，使用mv将其移动到一个专门设置的回收目录，过一段时间之后，确认不再需要这些文件或目录，再用rm命令将其彻底删除。</p></blockquote><h4 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h4><p>通过特殊的符号，对多个文件进行批量的选择，并用shell命令处理</p><p><code>*</code>：匹配任意数量的任意字符</p><p>​    eg：<code>ls -d /etc/pa*</code>    //列出etc目录下所有以pa开头的目录或者文件</p><p>​            <code>rm -f /tmp/*.txt</code>    //删除/tmp目录下的所有txt文件</p><p><code>?</code>：配置任意单个字符</p><p>​    eg：<code>ls -lh /dev/sd?</code>    //列出/dev目录下所有以sd开头只有<strong>三个字符</strong>的文件信息</p><p><code>[]</code>：配置指定范围的任意单个字符</p><p>​    eg：<code>ls /dev/[df]??</code>    //    列出/dev目录下所有以“d“和”f“开头并且文件名为三的文件</p><p>​            <code>ls /dev/[a-c]*</code>    //    列出/dev目录下所有一个“a”、“b”和“c“开头的文件</p><p>​            <code>ls /dev/???[0-9]*</code>    //     列出/dev目录下文件名的第四个字符是数字的文件</p><p>​    在<code>[]</code>中还可以使用<code>!</code>指定不再选择范围的字符</p><p>​    eg：<code>ls /dev/[!fhi]*</code>    //    列出/dev目录下不以“f”、“h”和”i“开头的文件</p><h4 id="扩展符"><a href="#扩展符" class="headerlink" title="扩展符"></a>扩展符</h4><p><code>&#123;&#125;</code>中可以包含一个以逗号分隔的列表，并将其自动展开为多个路径或文件名。</p><p>eg：<code>mkdir /tmp/&#123;a,b,c&#125;</code>    //一次性创建/tmp/a、/tmp/b和/tmp/c三个目录</p><p>​        <code>touch /tmp/test&#123;1..10&#125;.txt</code>    //在/tmp目录下一次性创建 test1.txt , … , test10.txt共10个文件 </p><h3 id="文件内容操作"><a href="#文件内容操作" class="headerlink" title="文件内容操作"></a>文件内容操作</h3><h4 id="cat——小文件查看"><a href="#cat——小文件查看" class="headerlink" title="cat——小文件查看"></a>cat——小文件查看</h4><p><code>cat -n /etc/passwd</code>     //显示文本文件的内容，-n显示行号</p><blockquote><p>cat会一次显示完所有的文件内容，并且只保留最后一页在屏幕上，<strong>不方便查看长文件</strong>。</p></blockquote><h4 id="less-and-more-——长文件查看"><a href="#less-and-more-——长文件查看" class="headerlink" title="less and more ——长文件查看"></a>less and more ——长文件查看</h4><p><code>less -N /etc/passwd</code></p><p><code>more -N /etc/passwd</code></p><blockquote><p>less,more 命令适合与长文件阅读</p><p>less具有翻页功能,到文件末尾需要手动退出——适合查看长文件</p><p>more只能向后翻页，并且到文件末尾自动退出——与其他命令结合使用</p></blockquote><h4 id="tail-and-head-——-文件部分查看"><a href="#tail-and-head-——-文件部分查看" class="headerlink" title="tail and head —— 文件部分查看"></a>tail and head —— 文件部分查看</h4><p>head and tail 默认只显示10行内容</p><p><code>head -2 /etc/passwd</code>    //查看文件的前两行内容</p><p><code>tail -2 /etc/passwd</code>    //查看文件的后两行内容</p><p><code>tail -f /var/log/messages</code>    //查看系统公共日志文件messages的最后10行内容，并在末尾跟踪显示该文件中实时更新的内容。</p><blockquote><p>tail命令更多的被用于查看系统日志文件，以便观察相关的网络访问、服务调试信息。配合-f选项可以用于跟踪日志文件末尾的内容变化，实时显示更新的日志内容。</p></blockquote><h4 id="wc——文件内容统计"><a href="#wc——文件内容统计" class="headerlink" title="wc——文件内容统计"></a>wc——文件内容统计</h4><p><code>wc /etc/passwd</code>    //输出passwd文件的 行数、单词数、字节数</p><h4 id="echo——输出指定的内容"><a href="#echo——输出指定的内容" class="headerlink" title="echo——输出指定的内容"></a>echo——输出指定的内容</h4><p>输出字符串</p><p>​    <code>echo &quot;Hello world!&quot;</code></p><p>输出变量</p><p>​    <code>    echo $SHELL</code></p><p>​    <code>    echo $day</code>     //自定义变量 <code>day = &quot;&quot;Sunday</code>前提下</p><p>echo命令常与&gt;和&gt;&gt;重定向符结合，将内容保存或者追加到文件中</p><p><code>echo &#39;hello world&#39; &gt; test.txt</code>    //覆盖</p><p><code>echo &#39;good bye world&#39; &gt;&gt; test.txt </code>    //追加</p><blockquote><p>echo的输出会默认换行，添加 -n 后可以不产生换行效果</p></blockquote><h4 id="文件内容查找——grep"><a href="#文件内容查找——grep" class="headerlink" title="文件内容查找——grep"></a>文件内容查找——grep</h4><p>grep:    在文件中查找并显示指定字符串的所有行。</p><p><code>grep [选项] 查找条件 目标文件</code></p><p><code>grep &quot;root&quot; /etc/passwd</code>    //在/etc/passwd文件中查找包含“root”字符串的行</p><blockquote><p><strong>grep命令在设置查找条件时，不支持“ * ”和“  ？”等通配符，而是使用正则表达式设置条件。</strong></p></blockquote><p><code>grep &quot;^root&quot; /etc/passwd</code>    //查找以root开头的行</p><p><code>grep &quot;^$&quot; /etc/passwd</code>        //查找空白行</p><blockquote><p>-n：输出行的行号</p><p>-v：找出不符合查找条件的行</p><p>-i：查找条件不区分大小写</p><p>-w：精确匹配<strong>单词</strong>（含有这个单词的其他单词不会被显示）</p></blockquote><h4 id="文件内容对比——diff"><a href="#文件内容对比——diff" class="headerlink" title="文件内容对比——diff"></a>文件内容对比——diff</h4><p>diff命令用于比较多个文本文件之间的差异，这在系统安全防范中非常重要。例如，在黑客入侵系统后，往往会修改一些系统配置文件，从而留下“后门”。作为运维人员，最好事先将一些重要文件备份，然后定期执行diff命令进行对比，从而发现文件是否被改动过。</p><p>在进行如下操作后</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[lifeisbinary@centos-linux ~]$ cp .bashrc .bashrc.bak  #文件备份</span><br><span class="line">[lifeisbinary@centos-linux ~]$ echo &quot;cd /tmp&quot; &gt;&gt; .bashrc  #在.bashrc文件的末尾增加一行</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>进行比较<img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20221205000617.png" alt="image-20210505164955600"></p><p>12d11：</p><p>​    文件1(.bashrc)的第12行在文件2(.bashrc.bak)中被删除了（d代表删除）</p><p>&lt; cd /tmp</p><p>​    以&lt;开始的行属于文件1（.bashrc）,以&gt;开始的行属于文件2（.bashrc.bak）</p><p>​    cd /tmp 为被删除的行</p><p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20221205000622.png" alt="image-20210505165722660"></p><h3 id="时间和日期相关命令"><a href="#时间和日期相关命令" class="headerlink" title="时间和日期相关命令"></a>时间和日期相关命令</h3><h4 id="Date——打印、修改日期"><a href="#Date——打印、修改日期" class="headerlink" title="Date——打印、修改日期"></a>Date——打印、修改日期</h4><p><code>date</code>     //按照系统默认的格式显示日期和时间</p><p><code>date +%F</code>    //只显示日期</p><p><code>date +%T</code>    //只显示时间</p><p><code>date 050517002021</code>      //将当前日期修改为2021年5月5日17:00</p><h4 id="hwclock——显示或修改硬件时钟"><a href="#hwclock——显示或修改硬件时钟" class="headerlink" title="hwclock——显示或修改硬件时钟"></a>hwclock——显示或修改硬件时钟</h4><p>在linux系统中存在两套时钟系统：date命令查看的系统时间    和    记录计算机BIOS中的硬件时钟。两套时钟所显示的时间可能会不一致。</p><p>由于没次重启系统的时候，系统都会重新从BIOS中将时间读取出来，所以要修改日期和时间，单单执行date命令还不够，还必须再用hwclock命令来更新硬件时钟。</p><p>如果发现两者不一致:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hwclock -w <span class="comment">#将系统时钟写入硬件时钟</span></span><br><span class="line">hwclock -s <span class="comment">#将硬件时钟写入系统时钟</span></span><br></pre></td></tr></table></figure><h4 id="文件元数据查看——stat"><a href="#文件元数据查看——stat" class="headerlink" title="文件元数据查看——stat"></a>文件元数据查看——stat</h4><p>linux系统中文件包含两部分：</p><ul><li>文件内容（cat、more、less等查看的内容）</li><li>文件元数据，用于描述文件本身的属性，文件大小、存储位置、访问权限及时间戳等。</li></ul><p>查看 /etc/passwd的元数据：</p><p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20221205000627.png" alt="image-20210505172235873"></p><p><strong>最近更改时间</strong>指的是<strong>文件内容的变化</strong>，最近改动时间指的是文件元数据的变化。而内容的变化会引起文件大小的变化，即内容变化会导致文件最近更改时间和最近改动时间的同时变化。</p><p>文件元数据单个变化包括：权限修改操作、重新命名等。</p><blockquote><p>linux避免频繁对磁盘进行写入操作，一般文件的最近访问时间不会实时变化。</p></blockquote><h3 id="文件查找命令"><a href="#文件查找命令" class="headerlink" title="文件查找命令"></a>文件查找命令</h3><h4 id="简单快速查找——locate"><a href="#简单快速查找——locate" class="headerlink" title="简单快速查找——locate"></a>简单快速查找——locate</h4><p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20221205000645.png" alt="image-20210505172915923"></p><p>无需给定查找的起始路径，查找速度快。</p><p>locate只能实现模糊查找，如查找passwd文件，会出现很多结果。因为它会将所有的名字甚至路径中包含“passwd”的目录和文件全部查出来。</p><p>另外，它是基于实现构建的索引数据库，该数据库定期更新。因而lacate无法查找刚刚新建的文件。</p><h4 id="强大的文件查找命令——find"><a href="#强大的文件查找命令——find" class="headerlink" title="强大的文件查找命令——find"></a>强大的文件查找命令——find</h4><p>能够实现精确的查找</p><p><code>find [查找路径] [选项] [查找条件] [处理动作]</code></p><ul><li><p>查找条件：可以根据文件名、文件大小、文件类型、从属关系和权限等进行设置</p></li><li><p>处理动作：对查到的文件要执行的操作。如复制、删除等。</p></li></ul><h5 id="查找条件设置："><a href="#查找条件设置：" class="headerlink" title="查找条件设置："></a>查找条件设置：</h5><p>​        <code>find /etc -name &quot;net*.conf&quot;</code>     //按名称查找，允许使用通配符</p><p>​        <code>find /etc/ -iname &quot;*net*&quot;</code>        //按名称查找，不区分大小写</p><p>​        <code>find / -empty</code>            //查找空文件和空目录</p><p>​        </p><p>​        <code>find /etc -type l -ls </code>     //查找链接文件，并显示其详细信息</p><p>​        <code>find /etc -size +1M</code>    //查找大小在1M以上的文件</p><p>​        <code>find /etc -size -10K</code>    //查找大小在10K一下的文件</p><p>​        </p><p>​        <code>find /boot -not -type f -ls</code>     //查找所有文件类型不是普通文件的文件，并显示其详细信息</p><p>​        <code>find /tmp -atime +7 -type f</code>     //查找7天内没有被访问过的文件</p><p>​        <code>find /etc -mtime -1 -type f </code>    //查找最近一天之内被改动过的文件</p><p>​        <code>find /etc -cmin -180 -type f</code>     //查找最近3</p><p>小时内被修改过状态信息的文件</p><blockquote><p>-atime, -mtime , -ctime        —— 访问时间，更改时间，改动时间</p><p>-amin, -mmin, -cmin类似</p></blockquote><p>-exec ,对查到的结果进一步处理</p><p><code>find /boot -name &quot;init*&quot; -exec cp &#123;&#125; /tmp \</code></p><p>“{}”：表示find查询到的结果</p><p>“\“：命令结束的标志</p><p>同时指定多个查询条件</p><p><code>find /boot -size +1024K -name &quot;init*&quot;</code></p><h5 id="find的辅助命令——xargs"><a href="#find的辅助命令——xargs" class="headerlink" title="find的辅助命令——xargs"></a>find的辅助命令——xargs</h5><p>find查询后的结果可能很多，如果都送入exec的执行命令中，可能由于结果太多，命令无法处理这么多的参数。因此<strong>使用xargs分批将结果传给后续的命令进行处理</strong>。</p><p><code>find /tmp -name &quot;*.txt&quot; -exec cp &#123;&#125; /root \ </code></p><p><code>find /tmp -name &quot;*.txt&quot; | xargs -i cp &#123;&#125; /root</code></p><blockquote><p>如果 -exec命令不满足要求时，使用xargs命令。</p></blockquote><h3 id="linux内部命令和外部命令"><a href="#linux内部命令和外部命令" class="headerlink" title="linux内部命令和外部命令"></a>linux内部命令和外部命令</h3><p><strong>内部命令</strong>：集成在shell中的命令，只要shell被执行，内部命令就</p><p>自动载入内存，用户可以直接使用。</p><p><strong>外部命令</strong>：考虑到运行效率等原因，不可能把所有的命令都集成在Shell中，更多的linux命令是独立于Shell之外的，这些命令成为外部命令。</p><blockquote><p>使用<code>type 命令名</code>可以查看命令是外部命令还是内部命令</p></blockquote><p><strong>linux中的大部分命令属于外部命令，而每个外部命令都对应了系统中一个可以执行的二进制文件</strong>，这些二进制文件主要存放在下列目录中：</p><ul><li>普通命令： /bin,   /usr/bin 和 /usr/local/bin</li><li>管理员命令(root权限执行)： /sbin ,   /usr/sbin   和 usr/local/sbin</li></ul><blockquote><p>使用<code>which 命令名</code>可以查看外部命令对应的程序文件，which的搜索范围由环境变量PATH决定。</p></blockquote><p><strong>Linux系统默认将外部命令文件的存放路径保存在一个名为PATH的环境变量中。</strong></p><p>当用户输入命令并执行时，Shell首先会检查命令是否是内部命令，若不是，Shell就会从PATH变量所保存的这些路径中寻找命令所对应的程序文件。如果把一个外部命令对应的程序文件删除，或者存放外部命令程序文件的目录没有被添加到PATH变量中，这会导致外部命令无法正常执行。</p><p>Linux会将用户执行过的外部命令的程序文件路径缓存下来，这样再次执行时，就不需要去PATH中查找。使用<code>hash</code>命令可以查看当前Shell所缓存的命令程序文件路径。</p><h3 id="常用命令设置别名——alias"><a href="#常用命令设置别名——alias" class="headerlink" title="常用命令设置别名——alias"></a>常用命令设置别名——alias</h3><p><code>alias</code>    //查看当前系统中存在的别名</p><p><code>alias cpd=&#39;cat /etc/passwd&#39;</code>    //设置查看密码文件的命令别名</p><p><code>unalias cpd</code>    //删除别名</p><blockquote><p>注意：设置的别名只在当前Shell有效。      如果需要在每次用户登录后都有效，需要将该命令写入到配置文件中。</p><p>希望对所有用户有效，写入全局配置文件    /etc/bashrc </p><p>希望对指定用户有效，写入相应用户的家目录中 ~/.bashrc</p><p>修改完配置文件后，需要通过 source 配置文件，才能够立即生效</p></blockquote><h3 id="查看执行命令的历史记录——history"><a href="#查看执行命令的历史记录——history" class="headerlink" title="查看执行命令的历史记录——history"></a>查看执行命令的历史记录——history</h3><p><code>history 3</code>    //列出最近执行过的三条历史命令</p><p><code>history !16</code>    //把第16条历史命令重新执行一遍</p><p><code>history -d 16</code>    //删除第16条历史命令</p><p><code>history -c</code>    //删除缓存中的历史命令</p><h3 id="查看命令帮助信息——help"><a href="#查看命令帮助信息——help" class="headerlink" title="查看命令帮助信息——help"></a>查看命令帮助信息——help</h3><p>内部命令帮助信息查看——<code>help 命令名</code></p><p>外部命令帮助信息查看——<code>命令名 --help</code></p><blockquote><p>help查看的帮助信息较为简略，如果要查看更为详尽的帮助信息，可以使用<code>man 命令名</code>命令。</p><p>无论是外部命令还是内部命令，都可以使用man</p></blockquote><h3 id="清屏——clear"><a href="#清屏——clear" class="headerlink" title="清屏——clear"></a>清屏——clear</h3><p>快捷键——ctrl + L</p><h3 id="标准输入输出"><a href="#标准输入输出" class="headerlink" title="标准输入输出"></a>标准输入输出</h3><p>linux系统中一切皆文件，因此负责输入和输出的硬件设备也被视为系统中的一个文件。用户在通过操作biotin给处理信息的过程中，包含一下三类交互设备：</p><ul><li>标准输入（stdin）：默认是键盘，文件描述符为0。从标准输入文件中读取数据</li><li>标注输出（stdout)： 默认是显示器，文件描述符为1。输出数据到标准输出文件中。</li><li>标准错误（stderr）：默认是显示器，文件描述符为2。输出错误信息到标准错误文件中。</li></ul><p>一个linux程序通常从标准输入中得到输入数据，并将正常数据输出到标准输出，将错误信息输出到标准错误。</p><p>在某些情况，我们可能希望从键盘以外的其他设备读取数据，或者将数据送到显示器以外的其他输出设备，这种情况就成为<strong>重定向</strong>。</p><p>Shell中，输入重定向能够把文件导入命令中，输出重定向能够把原本输出到屏幕的信息写入指定文件中。</p><p>管道则为输入和输出重定向的结合，一个程序向管道的一端发送数据，而另一个程序从管道的另一端读取数据，即“把前一个命令原本要输出到屏幕的数据当作后一个命令的标准输入”。管道为不同命令的协同工作提供了一种机制。</p><h5 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h5><ol><li><p>标准输出重定向</p><p><code>cat /etc/passwd &gt; pass.txt</code>    //输出重定向 （覆盖）</p><p><code>tail -3 /etc/shadow &gt;&gt;pass.txt</code>    //输出重定向（追加）</p><p><code>cat 1.txt 2.txt &gt; 3.txt</code>    //两个文本合并到一个文本</p><p><code>cat 1.txt &gt; 2.txt</code>    //将文本的内容复制到另一个文本（覆盖）</p><p><code>cat 1.txt &gt; 2.txt</code>    //将文本的内容追加到另一个文本</p></li><li><p>标准输入重定向</p><p>将命令接受输入的途径从默认的键盘改为指定的文件</p><p><code>cat &gt;test.txt &lt;&lt;EOF</code>     //将一段连续输入的信息保存至指定文档。通过EOF结束连续的输入，结束标记必须要在最后一行的行首顶格书写。</p></li><li><p>标准错误重定向</p><p>将命令执行过程中的错误信息重定向并保存到指定的文件中</p><p><code>find / -user student 2&gt; find.txt</code>    //将错误信息保存到find文件中， “2&gt;”中，2是标准错误输出的文件描述符。</p><p><code>find / -user student &amp;&gt; find.txt</code>   //将程序运行的结果（正确执行的信息或错误信息）保存到find中 ，“&amp;&gt;”用来合并正常输出和错误输出。</p><p>linux系统中提供了一个特殊的设备文件/dev/null，被称为“黑洞”设备文件，进入该设备的数据将被“吞并”而丢失。</p><p>在有些命令执行过程中会产生一些错误信息，而我们不关心这些错误信息，只想看到正常执行的结果，可以通过标准错误重定向到/dev/null,来过滤这些错误信息。</p><p><code>find / -user student 2&gt; /dev/null</code>    //过滤错误信息</p><p><code>cat /dev/null &gt; test.txt</code>    //    利用黑洞设备文件清空一个文件内容</p></li><li><p>管道符 |</p><p>可以把多个命令连接起来实现复杂的功能</p><p>管道符左侧命令的结果将作为右侧命令的输入</p><p><code>ls -lh /etc | grep net</code>    列出/etc目录下包含net关键字的目录和文件</p><p><code>head /etc/passwd | tail -1</code>    从paawd文件中取出第10行</p></li></ol><h3 id="Vi文本编辑器"><a href="#Vi文本编辑器" class="headerlink" title="Vi文本编辑器"></a>Vi文本编辑器</h3><p>Visual Interface</p><p>vim是vi的增强版</p><p><code>vim [filename]</code></p><ol><li>vi编辑器的三种模式：<ul><li>命令模式：启动后默认进入命令模式，主要完成光标移动、字符串查找、删除、复制和粘贴等操作。<strong>无论用户处于何种模式，通过<ESC>键都可以进入命令模式</strong></li><li>插入模式：在命令模式下，输入 i可以切换到插入模式。该模式主要就是文本内容编辑，修改、删除或添加。<strong>处于插入模式时，vi编辑器的最后一行会出现“–INSERT–“的状态提示信息</strong>。</li><li> 末行模式：在命令模式下，输入：即可进入末行模式，可以保存文件、退出文件编辑，对文件内容进行查找、替换等。<strong>当处于末行模式时，vi编辑器的最后一行会显示：提示符</strong></li></ul></li></ol><p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20221205000759.png" alt="image-20210523174519623"></p><ol start="2"><li><p>vi的常用命令</p><h6 id="命令模式下"><a href="#命令模式下" class="headerlink" title="命令模式下"></a>命令模式下</h6><ul><li><p>光标移动： </p><ul><li><p>翻页： Ctrl+F （向下翻页）     Ctrl+B（向上翻页）</p></li><li><p><strong>行内跳转</strong>：  </p><p> 0 或者 ^（跳转至行首）         $ (跳转至行尾)    </p><p> 6 右方向键 （向右移动6个字符） 6 左方向键 （向左移动6个字符）</p></li><li><p>行间跳转：</p><p>gg 跳转至首行            G跳转至尾行</p><p>6G 跳转至第6行</p></li><li><p>行号显示： :set nu(vi中显示行号)      :set none (vi中取消行号)</p></li></ul></li><li><p>复制、粘贴和删除</p><ul><li>x 删除光标处的单个字符       dd 删除光标所在的行</li><li>yy 复制当前光标所在行的内容  p 粘贴内容到光标所在行之后</li></ul></li><li><p>文件内容查找</p><ul><li>/xxx 自上而下查找字符串     ?xxx 自下而上查找字符串 （n 定位下一个搜索匹配的结果，N定位上一个搜索匹配的结果）</li></ul></li><li><p>撤销编辑： <strong>u 撤销最近的一次操作</strong>，默认情况最多可以撤销50次         Ctrl+R 恢复最近一次的操作</p></li></ul><h6 id="末行模式下"><a href="#末行模式下" class="headerlink" title="末行模式下"></a>末行模式下</h6><ul><li><p>保存文件：  :w保存          :w ~/Desktop/newfile 另存为其他文件</p></li><li><p>退出： :q未修改退出          :q! 放弃修改退出</p></li><li><p>保存并退出：     :wq</p></li><li><p>文件内容替换：     :% s/旧内容/新内容【/gc】 </p><p>g每行的所有匹配结果都替换，默认只替换每行匹配的第一个结果    c表示每次替换都进行询问</p></li></ul><h6 id="vi的可视模式"><a href="#vi的可视模式" class="headerlink" title="vi的可视模式"></a>vi的可视模式</h6><p>在命令模式下 ，v 进入按字符选定内容，y进行复制，d进行删除，p进行粘贴。可视模式提供了一种更加简便的对部分字符进行复制、删除等操作的处理方式。</p><blockquote><p>vi编辑器提供的官方联系教程，命令行输入 <code>vimtutor</code></p></blockquote></li></ol><h1 id="软件包管理"><a href="#软件包管理" class="headerlink" title="软件包管理"></a>软件包管理</h1><p>linux的软件安装主要分为:</p><ul><li><p>源码安装方式：</p><p><strong>困难且耗时的方式</strong>。在取得源码后，需要编译并解决软件依赖关系。在安装和卸载时，需要考虑软件与其他程序、库的依赖关系，操作难度较大。</p><p>源码安装的优势：</p><ul><li>可移植性好。可以安装到任何linux中使用，而RPM包只能用于某些Linux</li><li>可以灵活定制软件，运行效率高（编译过程可以更好的适应安装主机的系统环境，运行效率和优化程度强于使用RPM包安装）。</li><li>版本新。代码总是最先发布</li></ul></li><li><p>RPM安装方式：</p><p>源码安装方式复杂耗时，RedHat公司设计了一种软件包管理系统RPM（RedHat Packet Manager）。</p><p><strong>RPM是一种已经编译好并封装好的软件包</strong>（软件包中会封装程序、配置文件和帮助手册等），用户可以直接安装。RPM软件包是CentOS系统中软件的基本组成单位，每个软件都是由一个或多个RPM软件包组成。通过RPM，用户可以轻松的管理系统中的所有软件。</p><p>RPM软件包只能用于采用RPM机制的Linux系统上（RHEL、CentOS、Fedora、SUSE等）。RPM相较于其他的包管理机制，基本已经成为Linux系统中软件包管理事实上的标准。</p><p>RPM的一大<strong>缺点是：RPM软件包之间的依赖复杂</strong>。如安装A包需要B包的支持，而安装B包又需要C包的支持。因此，在安装A之前，必须先安装C，再安装B，最后才能安装A包。如此<strong>复杂的依赖关系都要由用户自行来解决。</strong></p></li><li><p>YUM安装方式：</p><p>YUM在RPM的基础上，解决了RPM软件包之间的依赖问题，从而更加轻松地管理Linux系统中的软件。</p><p>从RHEL 5时代起，RedHat就推荐使用YUM软件安装方式。</p></li></ul><p>linux上下载的软件安装包，一般都是 .gz、.tar.gz 和 .tgz之类的压缩文件，需要先进行解压缩。</p><h3 id="tar命令——文件打包和压缩"><a href="#tar命令——文件打包和压缩" class="headerlink" title="tar命令——文件打包和压缩"></a>tar命令——文件打包和压缩</h3><p>linux中打包和压缩是两个分开的操作。</p><p>打包命令：tar</p><p>压缩命令：gzip、bzip2、xz</p><p>通常先进行打包，后调用某种压缩工作进行压缩。如文件名后缀为 .tar.gz 、 .tgz的文件就属于这种先打包再压缩的文件。</p><blockquote><p>在实际使用中，一般通过tar命令来调用gzip进行压缩或解压，而很少单独使用这些压缩命令。</p></blockquote><ol><li>打包并压缩：</li></ol><p><code>tar -zcvf newfile.tar.gz  directory </code>  //将directory目录打包并压缩保存为newfile.tar.gz文件</p><ul><li>-c： 创建 .tar格式的文件，不会进行压缩</li><li>-v： 显示打包的过程</li><li>-f： 指定打包或者解包的文件名，必须在选型的最后一位</li><li>-z： 指定的压缩方式为gzip</li></ul><ol start="2"><li><p>解包和解压缩</p><p><code>tar -xf【 压缩文件】 -C 【解压后的目录】</code></p><ul><li>-x： 解开tar格式的包文件</li><li>-f：指定解包的文件</li><li>-C：指定解压后文件存放的位置</li></ul><blockquote><p>此命令不需要指定调用那种压缩工作，系统会分析压缩文件的格式，自动调用相应的压缩工具进行解压。</p></blockquote></li></ol><h3 id="使用YUM进行软件安装"><a href="#使用YUM进行软件安装" class="headerlink" title="使用YUM进行软件安装"></a>使用YUM进行软件安装</h3><ol><li><p>配置yum源</p><p>yum源就是存放大量RPM软件包的远程仓库</p><p>yum源通过文件的方式来配置，存放在 /etc/yum.repos.d/目录中，以.repo为后坠</p><p>访问系统本身的默认yum源，比较慢。设置阿里云的yum源。</p><p>为了避免系统中同时存在多个yun源而造成混乱，先将系统默认的yum源文件全部删除。<code>rm -f /etc/yum.repos.d/*</code>。</p><p>然后从阿里云镜像网站下载yum配置文件，并将其存放到系统指定的目录。<code>wget http://mirros.aliyun.com/repo/Centos-7.repo -O /etc/yum.repos.d/Centos-7.repo</code></p><p>通过yum list 列出当前系统已经安装和未安装的软件包。名字前有@符号的是已经安装过的软件包。</p><p><code>yum list xxx</code>    查看yum源中是否有该软件包</p><p><code>yum repolist</code>    查看当前系统中可用的yun源，也可以用于检测yum源是否配置好</p></li><li><p>常用的yum命令</p><p><code>yum info xxx </code>: 查看软件包的信息（版本，软件功能）。如果软件包已经安装，则会显示已经安装的软件包。如果未安装，则会显示可安装的软件包。</p><p><code>yum install xxx</code> 安装软件包，安装过程中如果该软件包依赖的其他包未安装，则会询问用户是否安装该软件包需要的依赖包。</p><p><code>yum install xxx -y    </code> 当安装过程中进行询问时，自动确认</p><p><code>yum remove xxx</code>     卸载软件。<strong>yum remove在卸载一个软件时同时会将所有依赖于该软件的其他软件包一同卸载</strong>。例如，<code>yum remove cpp</code>，cpp是安装gcc时作为依赖包被一通安装的，因而在卸载cpp时会提示将要gcc也一同卸载。因为如果cpp被卸载了，那么gcc肯定也无法正常使用。但是这也就会导致新的问题出现，比如gcc又是别的软件的依赖包，那么将会导致这些软件也无法正常使用。因此，如果这些被一同卸载的软件正好是其他软件或者系统本身运行需要的，就容易造成问题甚至系统奔溃。<strong>因而在使用yum remove命令卸载软件时一定要慎重。</strong></p></li></ol><p>​        <code>yum clean all</code> 清除本地缓存，yum会自动创建本地缓存，一条yum执行效率。yum默认优先使用yun缓存来获取软件相关信息。如果发现yum运行不正常，也许就是由于yum缓存造成的。此时就需要清空yum缓存。</p><h3 id="yum故障排查"><a href="#yum故障排查" class="headerlink" title="yum故障排查"></a>yum故障排查</h3><ol><li>确认：yum源的定义文件是否存在错误</li><li>检查是否还有别的yum源定义文件，linux允许系统配置并启用多个yum源，但是必须要保证这些yum源都正确，如果其中一个出现错误，那么都会导致无法正常安装软件</li><li>yum clean all 清空缓存</li><li>yum list 检测是否能正确list出yum源中的软件包</li></ol><h3 id="RPM进行软件包管理"><a href="#RPM进行软件包管理" class="headerlink" title="RPM进行软件包管理"></a>RPM进行软件包管理</h3><p>rpm命令在linux中主要用于查询，查询软件是否安装、查询软件包信息</p><p>RPM机制封装的软件包拥有约定俗成的命令格式： 软件名称-版本号-发布号.硬件平台.rpm</p><p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20221205000900.png" alt="image-20210523231450303"></p><ul><li>发布号：RPM软件包是由CentOS组织封装的，因而软件包的发布号（RedHat更新）与软件版本号（开发者更新）是两回事。</li><li>硬件平台：<ul><li>x86_64： 64位PC架构</li><li>i386 / i686 : 32位PC架构</li><li>noarch: 不区分硬件架构</li></ul></li></ul><h6 id="安装-卸载软件"><a href="#安装-卸载软件" class="headerlink" title="安装/卸载软件"></a>安装/卸载软件</h6><p><code>rpm -ivh rpm包的路径</code>  安装软件包</p><ul><li>-i： 安装软件</li><li>-v： 显示安装过程</li><li>-h： 显示安装进度</li></ul><p><code>rpm -e xxx</code>  卸载软件包</p><h6 id="查询软件包"><a href="#查询软件包" class="headerlink" title="查询软件包"></a>查询软件包</h6><p><code>rpm -qa | grep ssh</code>  查看是否安装ssh</p><blockquote><p>ssh 不是软件的完成名称，因此才通过 rpm -qa列出所有已经安装的软件包，再通过内容查找其返回的结果</p><p>q: qurey</p></blockquote><p><code>rpm -qi xxx</code> 查询<strong>已安装的软件包</strong>的信息</p><p><code>rpm -ql xxx</code>    查看软件包在系统中安装的文件</p><p>一个典型的linux应用的组成：</p><ul><li>普通的可执行文件，保存在 /usr/bin，普通用户可执行</li><li>管理程序文件，保存在 /usr/sbin，管理员权限执行</li><li>配置文件，保存在 /etc下，配置文件较多时，会建立子目录</li><li>日志文件，保存在 /var/log</li><li>程序的参考文档，保存在 /usr/share/doc</li><li>可执行文件以及配置文件的man手册， 保存在 /usr/share/man</li></ul><p><code>rpm -gc xxx</code>    查看软件包安装的配置文件</p><p><code>rpm -qf 文件</code>    查询某个文件所属的软件包</p><p><code>which find</code> + <code>rpm -qf /usr/bin/find</code>  查询find命令来自哪个软件包，如果误删了find命令文件，可以通过安装该软件包进行修复</p><h3 id="利用源码编译安装软件"><a href="#利用源码编译安装软件" class="headerlink" title="利用源码编译安装软件"></a>利用源码编译安装软件</h3><p>源码安装需要<strong>主机具备编译环境</strong>，C语言是Linux的标准程序语言，常见的源码包一般是用C语言开发。常用的C语言编译器是GCC。</p><p>软件在编译或者执行期间，需要依赖其他的软件或者链接库。大部分软件开发者会在README或者INSTALL文件中告知需要准备哪些软件。</p><h6 id="源码安装的流程"><a href="#源码安装的流程" class="headerlink" title="源码安装的流程"></a>源码安装的流程</h6><p>解包—-配置—-编译—安装</p><p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20221205000909.png" alt="image-20210523235013026"></p><p>在生产环境中，将本地的软件包传到服务器中：</p><p>在linux服务器中安装lrzsz软件，在本地的XShell中执行rz命令，这时会打开一个Windows窗口，直接选择要上传的文件即可，文件默认会被上传到当前工作目录下。</p><h6 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h6><p>一般建议将各种软件的源码统一保存到 /usr/src/  /usr/local/src/ 或 /temp/目录中，以便于集中管理。</p><h6 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h6><p>编译软件前，必须先设置好编译的参数。配置工作通常由源码中的configure脚本来完成，具体的配置参数可以在源码目录中执行 ./configure –help 进行查看</p><p>配置中有一个 –prefix参数，指定软件包安装的目标目录。源码编译安装会将软件中所有文件安装到指定的目录<code>./configure --prefix=/usr/local/xxx</code>。这样将来卸载软件只需要安装目录删除，而无须担心误删其他软件。</p><p>配置结果会保存到源码目录中的makefile文件中</p><h6 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h6><p>编译的过程就是根据makefile文件中的配置信息，将源码编译并连接成可执行程序。</p><p><code>make</code></p><p><code>make test</code>对make的结果进行检查，保证没有错误de</p><h6 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h6><p><code>make install</code> 安装过程是将软件的执行文件、配置文件等相关文件复制到linux系统的相应位置。</p><p>安装完成后，进入安装目录下的bin/sbin目录中，执行相应的程序，就可以使用安装好的软件了。</p><h1 id="进程和服务管理"><a href="#进程和服务管理" class="headerlink" title="进程和服务管理"></a>进程和服务管理</h1><p>进程：系统中正在运行的程序。</p><p>服务：系统启动后<strong>自动在后台运行的程序</strong></p><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>在系统运维过程中经常设计对进程的管理操作。</p><p>进程是正在运行的程序，占用CPU和内存等资源。</p><p>进程是分配和调度操作系统资源的基本单位。</p><h6 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h6><p>进程在启动后不一定立马开始运行，因而进程存在多种状态 </p><ol><li>理论上进程的状态</li></ol><p><strong>运行态</strong>：值当前进行已经分配CPU，正在处理器上执行。运行态的进程不能超过cpu的数量。</p><p><strong>就绪态</strong>：已经具备运行的条件，但是当前的CPU被其他程序占用，等待分配CPU状态。</p><p><strong>阻塞态</strong>：进程因等待某种事情的发生（IO输入输出完成），而不能运行。即使CPU空闲，阻塞态的该进程也不能运行。当阻塞态进程等待的时间发生之后，就会进入就绪态。</p><p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20221205000924.png" alt="image-20210524151948444"></p><ol><li><p>Linux系统中进程的状态</p></li><li><p>可运行状态<strong>（R）</strong>： 该状态的进程，要么正在运行，要么正准备运行。理论上，运行态和就绪态的进程，在linux系统中都被视为可运行状态。</p></li><li><p>睡眠状态： 进程处于阻塞状态，一旦等待的事情完成，就会变为就绪态。</p><ul><li>可中断睡眠状态 <strong>（S）</strong></li><li><strong>不可中断</strong>睡眠状态<strong>（D）</strong>：处于该状态的进程对于中断信号不作出响应</li></ul></li><li><p>僵尸状态<strong>（Z）</strong>：进程执行结束，但是进程所占用的系统资源未释放。一般情况下，子进程由父进程结束，并释放其所占用的系统资源。当某个进程已经运行结束，但是它的父进程还没有释放其系统资源时，该进程就处于僵尸状态。</p></li><li><p>停止状态<strong>（T</strong>）: 进程暂停于内存中，不会被调度，等待某种特殊处理。</p></li></ol><h6 id="父进程和子进程"><a href="#父进程和子进程" class="headerlink" title="父进程和子进程"></a>父进程和子进程</h6><p><strong>除初始化进程systemd之外，Linux中的每个进程都必须由已经运行的进程来创建</strong>，这就就构成了父进程和子进程的关系。</p><p>systemd是Linux启动的第一个进程，系统中其他所有进程都是systemd进程的子进程。<strong>除了systemd之外，每一个进程都必须有一个父进程。</strong>父进程和子进程之间的关系是管理和被管理的关系。<strong>当父进程终止时，子进程也随之而终止</strong>，但子进程终止，父进程并不一定终止。</p><p>如果<strong>父进程在子进程结束之前就退出</strong>，那么它的子进程就变成了“孤儿”进程。如果没有相应的处理机制的话，“孤儿”<strong>进程就会一直处于僵尸状态</strong>，资源无法释放。<strong>此时解决的办法是在已启动的进程中寻找一个进程来作为这些“孤儿”进程的父进程，或者直接让systemd进程作为它们的父进程，进而释放“孤儿”进程占用的资源。</strong></p><h6 id="进程的属性"><a href="#进程的属性" class="headerlink" title="进程的属性"></a>进程的属性</h6><p>进程在启动后，系统会为每个进程分配一个唯一的进程标示符，称为进程ID（PID）</p><p><code>pidof sshd</code> 查看sshd进程的PID</p><p>除了systemd进程的PID固定为1，其他的进程的PID都是不固定的。当进程启动时，系统会自动为其分配一个PID，当进程结束时，系统会回收这个PID。</p><p>其他属性： </p><ul><li>父进程的ID （PPID）</li><li>启动进程的用户名 （UID）</li><li>进程的状态</li><li>进程的执行优先级</li><li>进程所在的终端名</li><li>进程占用的资源大小</li></ul><h6 id="进程的分类"><a href="#进程的分类" class="headerlink" title="进程的分类"></a>进程的分类</h6><p>系统进程： 能执行内存资源分配和进程切换工作，这些进程不受用户的干预，<strong>root用户也不能干预系统进程的运行</strong></p><p>用户进程： 执行应用程序或内核之外的系统程序而产生的进程。此类进程可以在用户的控制下运行或关闭。<strong>我们管理的主要是这类用户进程</strong>。用户进程又可以分为：守护进程和交互进程</p><ul><li>守护进程：<strong>由运行各种服务所产生的进程，一般在系统后台运行</strong>，而且通常会随Linux系统的启动而启动，在系统关闭的同时终止。守护进程始终是运行着的，一般其所处的状态是等待处理请求任务。例如，无乱是否有人访问Web服务器上的网页，该服务器上的httpd服务都是一直在运行。</li><li>交互进程：通过终端命令启动的进程，可以运行在前台也可以运行在后台。</li></ul><h6 id="进程状态查询——ps-（process-state）"><a href="#进程状态查询——ps-（process-state）" class="headerlink" title="进程状态查询——ps （process state）"></a>进程状态查询——ps （process state）</h6><p>ps  显示<strong>当前用户在当前终端</strong>所启动的进程</p><ul><li>TTY：为终端。每个终端都有相应的编号，tty 可以查看当前用户所在的终端。 <code>echo hello &gt; /dev/pts/5</code></li><li>TIME: 只进程占用额CPU时间，通常很小，显示为0</li></ul><p>ps aux</p><p>参数：</p><ul><li><p>a：显示与当前终端有关的所有进程，包括其他用户的进程</p></li><li><p>u：显示与当前终端无关的所有进程，a和u一起使用，显示系统中的所有进程。</p></li><li><p>x：以面向用户的格式显示进程信息</p></li></ul><p>执行结果：</p><ul><li>USER：启动该进程的用户。存在一些进程的启动者是专门的程序用户。</li><li>VSZ：进程占用的虚拟内存集的大小，单位是KB</li><li>RSS：进程常驻内存集的大小，单位是KB</li><li>TTY：启动进程的终端，<strong>如果显示？，表示该进程由系统内核启动，与终端无关。</strong></li><li>STAT：进程的状态。 有很多辅助表示进程状态的符号： + ——前台进程，l——多线程进程，N——低优先级进程，&lt;——高优先级进程，s——该进程是绘画领导者，如果这样的进程关闭，那么由该进程所派生出来的子进程也将被关闭。</li><li>TIME：进程从启动以来占用CPU的总时间</li><li>COMAMDN：启动该进程的命令。如果名称带有中括号，则表示该进程由系统内核启动</li></ul><p>因为ps aux 显示的内容多一般与more连用</p><p><code>ps -ef</code></p><ul><li>-e：显示系统中所有进程的信息</li><li>-f：显示进程的所有信息</li></ul><p>结果：</p><ul><li>C：进程所占用的CPU百分比</li></ul><blockquote><p>该命令，可以显示进程的父进程ID</p></blockquote><h6 id="top——查看进程的动态信息"><a href="#top——查看进程的动态信息" class="headerlink" title="top——查看进程的动态信息"></a>top——查看进程的动态信息</h6><p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20221205000945.png" alt="image-20210524170528539"></p><p>top命令结果：</p><p>第一行：系统时间，系统启动的时间，当前登录系统的用户个数，CPU的负载情况：过去1min，过去5min，过去15min</p><p>第二行：进程总数，各状态的进程数</p><p>第3～5：cpu的使用情况、内存使用情况，交换分区使用情况</p><blockquote><p>在top命令执行期间，可以对显示的结果进程排序。</p><p>P键——按占CPU的百分比排序（默认）</p><p>M键——按占内存的百分比排序</p><p>T键——按占用CPU的时间排序</p><p>N键——按进程启动时间排序</p></blockquote><h6 id="伪文件系统——-proc"><a href="#伪文件系统——-proc" class="headerlink" title="伪文件系统—— /proc"></a>伪文件系统—— /proc</h6><p>/proc被称为伪文件系统，因为该目录存放的并不是传统意义上的硬盘中的文件或目录，<strong>而是内存中正在运行的数据</strong>。</p><p>系统中所有进程的状态信息以文件的形式被存放在该目录中。</p><p>/proc目录中有很多以数字命令的目录,这些数字其实是进程PID，每个进程的信息都保存在对应的目录中。ps 和 top 命令都是从/proc目录获取进程的状态信息</p><h6 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h6><p>在shell命令行中执行某条命令，启动的进程默认情况下属于前台进程。执行过程中产生的相关信息会显示在终端上，进程执行过程中会占用当前终端，进程没结束，用户不能在当前终端执行其他操作。</p><p>在要执行的命令后面加上&amp;符号，则此进程转到当前终端后台运行。后台启动适合那些运行期间不需要用户干预或执行时间较长的程序。</p><p><code>jobs -l</code> // 查看当前终端中正在后台运行的进程任务</p><p>进程的前后台执行切换：</p><ol><li><p>后台进程切换到前台</p><p>fg(frontground)命令，将后台进程切换到前台</p><p><code>fg 1</code> 将任务编号为1的后台进程切换为前台执行</p></li><li><p>前台进程切换到后台</p><p>Ctrl + Z 切换到后台，进程处于停止状态</p><p>bg(background)命令，让后台挂起的进程继续执行</p></li></ol><p>通过shell运行的进程，无论是后台进程还是前台进程都与当前终端有关。如果关闭终端，那么该终端所有的进程也会关闭。这所以这样，是因为<strong>当前终端是所有其中运行的进程的父进程，它是一个回话的领导者，所以只要关闭它，终端中所有的子进程自然也会被关闭。</strong></p><p>通过nohop命令可以解除要执行的命令与当前终端之间的关系，使启动的进程为系统的后台进程。</p><p><code>nohop nc -lp 9527</code></p><h6 id="终止进程"><a href="#终止进程" class="headerlink" title="终止进程"></a>终止进程</h6><p>前台进程——Ctrl+C </p><p>后台进程——fg 切换到前台——Ctrl+C</p><p>其他终端或系统后台运行的进程——kill命令</p><p><strong>kill命令</strong>：</p><p>​    <code>kill PID</code></p><p>​    kill命令通过向进程发送终止信号使其退出运行。</p><p>​    kill可以发送的信号有多种，每个信号都有一个编号。其中默认使用的是15号信号SIGTERM。若进程已经无法响应终止信号，那么可以发送9号信号SIGKILL，强行将进程终止（<code>kill -9 PID</code>）。</p><p><strong>killall命令</strong>终止一组进程，通过程序的名字，直接结束所有进程。</p><p><code>killall sshd</code> 客户端与服务器之间的所有连接都将被断开。</p><h6 id="lsof（list-open-files）"><a href="#lsof（list-open-files）" class="headerlink" title="lsof（list open files）"></a>lsof（list open files）</h6><h6 id="查看当前系统文件的工具。在linux环境下，任何事物都以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。如传输控制协议-TCP-和用户数据报协议-UDP-套接字等，系统在后台都为该应用程序分配了一个文件描述符，该文件描述符提供了大量关于这个应用程序本身的信息。"><a href="#查看当前系统文件的工具。在linux环境下，任何事物都以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。如传输控制协议-TCP-和用户数据报协议-UDP-套接字等，系统在后台都为该应用程序分配了一个文件描述符，该文件描述符提供了大量关于这个应用程序本身的信息。" class="headerlink" title="查看当前系统文件的工具。在linux环境下，任何事物都以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。如传输控制协议 (TCP) 和用户数据报协议 (UDP) 套接字等，系统在后台都为该应用程序分配了一个文件描述符，该文件描述符提供了大量关于这个应用程序本身的信息。"></a>查看当前系统文件的工具。在linux环境下，任何事物都以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。如传输控制协议 (TCP) 和用户数据报协议 (UDP) 套接字等，系统在后台都为该应用程序分配了一个文件描述符，该文件描述符提供了大量关于这个应用程序本身的信息。</h6><p>lsof -i:端口号 //查看占用某端口的进程</p><h3 id="查看用户登录信息"><a href="#查看用户登录信息" class="headerlink" title="查看用户登录信息"></a>查看用户登录信息</h3><p>linux是一个多用户的操作系统，在同一时间可能会有多个用户同时登录使用系统，可以通过users、who或者w命令查看当前有哪些用户正在登录系统</p><p><code>users</code> //列出当前所有登录该系统的<strong>用户名</strong></p><p><code>who</code> //列出当前所有登录该系统的<strong>用户信息</strong>（用户名、终端、登录时间以及源IP地址）</p><p><code>w</code>  //who命令的增加版，除了who命令列出的信息，还可以列出用户正在执行的命令</p><p><code>last</code>   //查看系统的登录记录，哪些人以什么身份在什么终端上登录本机。<strong>由于last命令是通过查询日志文件来获取登录信息，而日志文件又容易被黑客篡改，因此不能单纯以该命令的输出信息来判断系统有无被恶意入侵</strong>。</p><h6 id="踢出可疑用户"><a href="#踢出可疑用户" class="headerlink" title="踢出可疑用户"></a>踢出可疑用户</h6><p>通过<code>who</code>查到用户的终端——通过<code>ps aux | grep pts/0</code>查到终端进程的PID——通过<code>kill -9 PID</code>强制终止该进程</p><h3 id="查看系统占用的资源情况"><a href="#查看系统占用的资源情况" class="headerlink" title="查看系统占用的资源情况"></a>查看系统占用的资源情况</h3><p><code>cat /proc/cpuinfo</code>    //查看系统CPU硬件信息</p><p><code>uptime</code>     //查看CPU使用情况, top命令的第一行信息</p><p><code>free -h -s 10</code>  //查看内存使用情况，-h：人性化显示内存容量单位，-s 动态刷新信息的时间频率，秒为单位 </p><blockquote><p>avilabel表示的系统可用内存大于free的值，是因为加入了buff/cache的部分可以回收的内存空间</p></blockquote><p><code>du -hs [directory]</code> //查看某个目录的大小</p><h3 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h3><h6 id="服务："><a href="#服务：" class="headerlink" title="服务："></a>服务：</h6><p>​        在系统后台运行，等待用户或其他软件调用的一类特殊程序。无论在哪个终端上运行服务，该服务所产生的进程都与终端无关，也就是说，将终端关闭之后，这些服务进程仍然会在系统后台自动运行。</p><p>​        Linux系统中服务名称的最后一般带有字母d，如vsftpd、httpd、sshd等，d是英文单词daemon的缩写，表示这是一种守护进程。</p><h6 id="系统初始化进程"><a href="#系统初始化进程" class="headerlink" title="系统初始化进程"></a>系统初始化进程</h6><p>​        初始化进程是Linux系统启动时第一个被执行的进程，它负责启动并管理其他各种服务，完成系统的初始化工作。</p><p>​        CentOS 7 的初始化进程是systemd。sytemd由系统自动在后台运行，所以也是一种典型的服务，一般也称systemd服务。systemd的PID永远为1。systemd进程启动后将陆续运行系统中的其他程序，不断生成新的进程。这些进程称为systemd的子进程，这些子进程可以进一步生成各自的子进程，最终构成一颗进程数。因此，<strong>systemd进程是维持整个Linux系统运行的所有进程的基础，该进程是不允许轻易终止的。</strong></p><p><code>pstree</code>    可以显示系统的进程数。</p><blockquote><p>在CentOS 7之前的版本中，采用的初始化进程是init，从CentOS 7开始采用systemd初始化进程。systemd相比于init的优势：</p><ol><li>开机速度变快。在系统开机的时候，systemd可以并发启动一些没有依赖的服务。不需要向init那样，让服务一个一个的排队，一个一个启动。</li><li>systemd提供按需启动服务的功能。在init初始化的时候，会将所有可能用到的服务全部启动起来，系统必须等待所有服务都启动就绪后，才允许用户登录。systemd只有在某个服务被真正请求的时候才启动它，当该服务结束时，可以动态关闭它，等待下次需要时才会再启动。</li></ol></blockquote><p>systemd中有一个核心的概念unit，systemd的系统管理功能主要就是通过各种unit来实现的。每中unit都有一个相应的配置文件对其进程标识和配置。这些配置文件主要存放在 /usr/lib/systemd/system/ 和 /etc/systemd/sytem/目录下。</p><ul><li>对服务进程管理的单元<strong>Service unit</strong>：以.service结尾。系统中每一种服务都会有一个与之对应的服务单元。</li><li>目标单元<strong>Target unit</strong>：以.target结尾。用于模拟实现系统运行级别。</li><li>设备单元<strong>Device unit</strong>：定义系统内核需要识别的设备</li><li>挂载单元<strong>Mount unit</strong>：定义文件系统的挂载点</li></ul><h6 id="使用systemctl命令管理服务"><a href="#使用systemctl命令管理服务" class="headerlink" title="使用systemctl命令管理服务"></a>使用systemctl命令管理服务</h6><p>Linux系统中提供了很多服务，从功能上可以分为：系统服务和网络服务。我们要管理的主要是网络服务（提供远程登录的sshd服务，提供网站浏览的httpd服务）。</p><blockquote><p>CentOS 5和CentOS 6系统中，对服务的管理主要是通过service和chkconfig命令完成，在CentOS 7中则主要是通过systemctl，systemctl是systemd提供的一个重要管理工具。</p></blockquote><p><code>systemctl start|stop|status|restart|reload 服务名</code></p><p>systemd将系统中的每个服务都看作一个服务单元（Service unit），在服务的名称后面加上.service作为后缀。在利用systemctl命令对服务进行管理时，服务名称后面加不加.service后缀均可。</p><p><code>system status xxx   </code></p><p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20221205000959.png" alt="image-20210528091402592"></p><p>结果解释：</p><p>第二行：表示服务已经被加载，该服务的Service unit配置文件位置，<strong>enabled表示服务已经被设为开机自动启动</strong>，vendor preset：enabled 表示该服务在系统中默认被预设为开机自动启动。</p><p><strong>在服务的配置管理中，如果修改了某项服务的设置，那么必须将服务重启，才能使得修改后的配置生效。</strong></p><p><code>systemctl restart xxx</code></p><blockquote><p>restart的重启方式会使服务产生暂时的中断，<strong>如果需要在不中断服务的前提下使得修改后的配置设置生效，需要使用reload方式重新加载服务。</strong>但对于某些服务配置所做的修改，必须重启才能生效，比如修改服务的端口号等网络配置，就无法通过reload方式重新加载。</p></blockquote><p><code>systemctl list-units --type service</code>  查看系统中所有正在运行的服务</p><p><code>systemctl list-units --type service --all</code> 列出系统中所有的服务</p><p><code>systemctl enable|disable|is-enabled 服务名</code></p><ul><li>enable 设置服务为开机自动启动</li><li>disable 表示禁止服务开机自动启动</li><li>is-enabled 查看服务的启动状态</li></ul><p><code>systemctl list-unit-files --type service</code> 查看系统中所有服务的开机启动状态</p><p>Linux上安装并使用一个服务的基本操作：</p><ol><li>查询系统中是否安装该服务 <code>rpm -qa | grep xxx</code></li><li>安装该服务 <code>yum install xxx -y</code></li><li>启动服务 <code>systemctl start xxx</code></li><li>设置开机自动启动 <code>systemctl enable xxx</code></li></ol><h6 id="管理系统的运行级别"><a href="#管理系统的运行级别" class="headerlink" title="管理系统的运行级别"></a>管理系统的运行级别</h6><p>Window中，正常启动模式和安全模式下，所能够运行的程序有所不同。正常模式下，所有被设为开机自动运行的服务或程序都会被自动启动，但如果进入安全模式，那么就只会启动系统基本的程序以及微软官方的服务。Linux中也有类似的机制，它将在系统运行时启动的各种程序服务互相组合以构成不同的搭配关系，满足不同的系统需求。这种搭配关系称为“运行级别”。总共有7种运行级别（0～6）。</p><p>不同的运行级别代表系统不同的运行状态，每种运行级别下所运行的服务或者程序会有所区别。</p><p>常用的运行级别时3和5，代表字符模式和图形模式。在选择相应的运行级别后，系统在启动时运行的服务就会有所区别。</p><p>将运行级别设置为3，系统启动时将会自动进入字符模式，所有与图像界面相关的服务都不会运行。</p><p>将系统级别设置为5，系统启动时会自动进入图形模式，自动运行与图形模式相关的服务。系统安装了图形界面，默认运行级别是5。</p><blockquote><p>在CentOS 5 和 CentOS 6系统中对运行级别进行管理，主要是借助runlevel 和 init 命令，CentOS 7也支持这两种命令。但是更加推荐使用systemctl命令。</p></blockquote><p><code>systemctl get-default</code>  查看系统的默认运行级别</p><p><code>runlevel</code> 查看系统的运行级别，结果会显示，上次切换前的系统（如果为N 表示之前未切换过运行级别）级别 和当前的系统级别</p><p><code>init 3</code>     切换到运行级别3模式，字符模式</p><p><code>init 0</code>    关闭系统</p><p><code>init 6</code>    重启系统</p><p>以上的方式切换系统级别只是临时的，当系统重启后，还是会进入默认的运行级别。</p><p><code>systemctl set-default multi-user.target</code>     //        设置系统的默认运行级别为3</p><p><code>systemctl set-default graphical.target</code>     //    设置系统默认运行级别为5</p><h6 id="重置root密码"><a href="#重置root密码" class="headerlink" title="重置root密码"></a>重置root密码</h6><p>Window系统重置管理员密码： </p><ol><li>用引导盘启动系统并进入WinPE</li><li>利用WinPE中提供的密码修改工具</li></ol><p>Linux系统：</p><p>CentOS 5 和 CentOS 6:</p><ol><li>启动系统进入单用户模式（运行级别1），此时无需密码即可以root身份登录系统</li><li>然后修改root用户密码</li></ol><p>CentOS 7:</p><pre><code>1. 进入救援模式，类似WinPE2. 密码重置</code></pre><blockquote><p>无论是单用户模式还是救援模式，都只能在系统本地登录才能使用，而无法通过网络远程操作，这样设计的目的很明显是处于安全的考虑。</p></blockquote><h6 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h6><p>计划任务可以让系统<strong>在指定的时间自动执行预先计划好的管理任务</strong>，因而计划任务是实现Linux系统自动化运维的重要途径。</p><p>通过计划任务来执行需要在指定时间或周期性执行的操作。</p><p>对于那些比较费时间而且占用资源较多的操作，可以通过设置计划任务，将它们安排在深夜由系统自动运行，从而避免影响正常服务的运行。</p><p>Linux系统听过两种计划任务：只会执行一次的at计划任务   和    可以周期执行的cron任务</p><ol><li><p>执行一次的at计划任务</p><p>在确认atd服务已经运行的情况下，<code>at 计划的时间</code>命令进入交互模式，一次输入准备执行的命令，最后按Ctrl+D保存。</p><p>计划时间的格式：</p><ul><li>HH:MM [YYYY-mm-dd]:  <code>at 10:05</code> 或 <code>at 10:05 2018-12-28</code></li><li>tomorrow: <code>at 10:05 tomorrow</code></li></ul><p>到时间后，系统会自动执行计划任务中的相关命令，并将执行结果以邮件的形式发送给用户。用户再此登录时，会看到友新邮件提示，执行mailx命令可以查看邮件。</p><p><code>at -l</code>     查看等待执行的计划任务</p><p><code>at -c 2</code>     查看编号为2的计划任务的具体内容</p><p><code>at -d 2</code>     删除编号为2的计划任务</p></li></ol><blockquote><p>通过非交互方式创建计划任务，<code>echo &#39;systemctl restart http&#39; | at 23:00</code></p></blockquote><ol start="2"><li><p>配置cron周期性计划任务</p><p>更多情况下，我们可能需要周期性地执行某项操作，比如每天凌晨2:00自动将/etc目录进行打包备份。</p><p>crontab命令用来设置用户的周期性计划，执行该命令会生成一个以用户名命名的配置文件，存放在/var/spool/cron目录中。</p><p><code>crontab -e</code>    编辑计划任务列表，打开一个任务编辑的界面。每一行代表一个记录，每个记录包括六个字段。</p><p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20221205001046.png" alt="image-20210528111637394"></p></li></ol><p>在时间周期设置中，没有设置的位置要用*号占位。</p><p>在配置计划任务时，命令建议使用绝对路径，因为当前系统执行计划任务中的操作时，无法获取环境变量PATH中保存的路径。关于命令的绝对路径，可以使用which查看</p><p>配置计划中的重点和难点是时间周期的设置</p><p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20221205001056.png" alt="image-20210528111757978"></p><p><code>0 23 */5 * * /usr/bin/rm -rf /var/ftp/pub/*</code>     每隔5天，在23:00清空一次FTP服务器公共目录 /var/ftp/pub中的数据</p><p><code>30 17 * * 1,3,5 /usr/bin/tar -zcf httpd.tar.gz /etc/httpd </code>    每周1，3，5的17:30，使用tar自动备份/etc/httpd目录</p><p><code>crontab -e -u lifeisbinary </code>     为lifeisbinary用户设置计划任务</p><p><code>crontab -l</code>  查看用户计划任务</p><p><code>crontab -l -u lifeisbinary</code></p><p><code>crontab -r -u lifeisbinary</code>      删除用户lifesibinary的计划任务</p><p>删除单条任务使用 crontab -e </p><p>使用 crontab 命令设置的是用户计划任务，除此之外，用户还可以通过编辑/etc/crontab文件，设置系统计划任务。</p><p>配置系统任务时，应遵循“分钟 小时 天 月 星期 <strong>用户</strong> 命令“的格式。</p><p><code>0 */3 * * * root /usr/bin/echo &quot;hello world&quot;</code></p><h1 id="磁盘和文件系统管理"><a href="#磁盘和文件系统管理" class="headerlink" title="磁盘和文件系统管理"></a>磁盘和文件系统管理</h1><h3 id="磁盘分区和格式化"><a href="#磁盘分区和格式化" class="headerlink" title="磁盘分区和格式化"></a>磁盘分区和格式化</h3><h6 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h6><p>传统的磁盘分区包括：主分区、扩展分区、逻辑分区3中。</p><p>硬盘的主引导扇区（MBR）中用来存放分区信息的空间只有64个字节（主引导扇区一共只有512字节空间），而每个分区的信息要占16个字节，因而理论上一块磁盘最多只有4个分区，这四个分区都是主分区。</p><p>硬盘越来越大，4个分区远远不够，引入扩展分区的概念。<strong>扩展分区也是主分区。但它不能直接使用，相当于一个容器</strong>。在扩展分区中可以创建新的分区，这些分区被称为逻辑分区。逻辑分区的数量不再受主引导扇区空间大小的限制，想SCSI或SATA接口的磁盘在Linux系统中最多可以创建12个逻辑分区。</p><p><strong>Linux系统中，所有磁盘和磁盘中的每个分区都是用文件的形式来表示。</strong>例如，在计算机中有一块硬盘，硬盘上划分了3个分区，那么在Linux系统中就会有相对应的4个设备文件，一个是硬盘的设备文件，另外每个分区也有一个设备文件，所有的设备文件都统一存放在/dev目录。</p><p>不同类型硬盘和分区的设备文件都有统一的命名规则。</p><ul><li>硬盘：对于SATA或SCSI接口的硬盘设备，采用“sdX”的文件名,其中X为a,b,c,d等字母序号。例如，系统中的第一块硬盘表示为“sda”。</li><li>分区：以硬盘设备的文件名作为基础，在后边添加该分区对应的数字序号。例如，第一块硬盘中的第一个分区表示为“sda1”。</li></ul><blockquote><p>主分区数目最多为4，因此主分区和扩展分区的序号限制为1～4。逻辑分区的序号将从5开始。第一个逻辑分区的序号为“sda5”。</p></blockquote><h6 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h6><p>文件系统，决定了磁盘分区中存放、读取文件数据的方式和效率。</p><p>对于一块新的磁盘，在向其存放数据之前，必须先创建文件系统。文件系统是在对磁盘分区进程高级格式化时被创建的，在系统中会存在很多<strong>不同类型的文件系统</strong>。</p><p>Windows下，磁盘分区通常采用FAT32或NTFS。</p><p>Linux下，常用EXT系列和XFS文件系统。在CentOS 7之前，采用EXT系列，从CentOS 7开始转向更适合大数据环境的XFS。</p><blockquote><p>Linux系统也可以支持Windows中的FAT32文件系统，在Linux中该文件系统名称换为VFAT。</p><p>Linux系统不支持NTFS，在Linux上使用NTFS硬盘，需要额外安装NTFS-3G软件包。</p></blockquote><p>文件/etc/filesystems中存放了系统支持的所有文件系统类型。</p><p>Linux中有一个swap类型文件系统——交换分区。类似于Windows的虚拟内存。</p><h6 id="分区管理"><a href="#分区管理" class="headerlink" title="分区管理"></a>分区管理</h6><p>Linux中，磁盘分区管理工具是fdisk。</p><p><code>fdisk -l</code></p><p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20221205001105.png" alt="image-20210528153202001"></p><ul><li>Boot: 是否是引导分区，* 表示引导分区</li><li>Id：表示分区类型的ID标记号，对于XFS分区，其为83，对于LVM分区，其为8e</li><li>System：表示分区类型，Linux代表XFS文件系统，Linux LVM代表逻辑卷</li></ul><h6 id="添加新硬盘给机器"><a href="#添加新硬盘给机器" class="headerlink" title="添加新硬盘给机器"></a>添加新硬盘给机器</h6><p><code>fdisk -l</code>    </p><p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20221205001112.png" alt="image-20210528153941487"></p><p>新加的硬盘为初始化，名称没有有效信息</p><ol><li><p>分区：</p><p><code>fdisk /dev/sdb</code>    进入磁盘分区的交互界面。</p><p>在创建逻辑分区前，需要先创建其容器扩建分区。</p><p>分区删除可以在fdisk交互界面中使用d。</p></li></ol><ol start="2"><li><p>格式化分区：</p><p>格式化的主要目的是在分区中创建文件系统，同时格式化也会清空所有数据。</p><p><code>mkfs -t 指定的文件系统 分区设备文件名</code> </p><p><code>mkfs -t xfs /dev/sdb1</code></p></li><li><p>挂载</p><p>Linux系统与Windows系统在存储设备操作方式上的一个非常重要的区别就是挂载。</p><p>在Linux系统中，核心系统虽然可以通过设备文件操作各种设备，但是对用户来说，还需要通过挂载，才能想正常访问目录一样访问存储设备中的资源。</p><p><strong>挂载就是将用户不方便操作的设备文件与系统中的目录绑定起来，这样用户可以通过访问目录，来调用里面的数据。</strong></p><blockquote><p>作为挂载点的目录必须事先存在，挂载点目录最好为空目录，否则挂载之后，目录原有的内容会被暂时隐藏。</p></blockquote><p><code>mount 设备文件 挂载点目录</code></p><p><code>umount 挂载点目录</code>   //必须保证此时存储设备不能处于busy状态，常见的错误是在挂载点下进行卸载操作。</p><p>Linux系统提供了两个默认的挂载点目录：/media 和 /mnt</p><ul><li>/media 系统自动挂载点，在图形界面下，插入U盘或光盘时，系统会将它们自动挂载到/media下</li><li>/mnt 用户手动挂载点，不建议将设备直接挂载到/mnt目录之下，而应该先在其中创建子目录，然后分别将不同设备挂载到相应的子目录中。</li></ul><p>自动挂载，mount挂载的设备在系统重启或关系时都会被自动卸载，这些开机后又需要手动挂载一遍。<strong>Linux系统可以通过修改/etc/fstab文件来完成存储设备的自动挂载。</strong></p><blockquote><p>一般linux下，修改系统文件的方式进行设置，需要重启才能生效。</p><p>可以通过 mount -a让系统自动挂载配置文件中的所有文件系统，而无需重启系统。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20221205001121.png" alt="image-20210528164441972"></p><ul><li><p>第一个字段：需要挂载的设备文件名。可以使用UUID</p><p>UUID（Universally Unique Identifier,全局唯一标识符）</p><p>通过设备文件名，可能每次插入的移动设备分配的名称会有变化，而UUID是不会变的。</p><p><code>blikid 设备文件</code>      查看设备文件的UUID</p></li><li><p>第二个字段：挂载点</p></li><li><p>第三个字段：文件系统类型</p></li><li><p>第四个字段：挂载选项 ，一般采用“defaults”</p></li><li><p>第五个字段：存储设备是否需要dump备份，0表示忽略，1表示备份。</p></li><li><p>第六个字段：系统启动是是否检测这个存储设备，以及检测顺序。0表示不检测，1标识的设备检测完会检测2标识的设备</p></li></ul></li><li><p>查看挂载的的情况</p><p><code>df -hT</code></p><ul><li>df (disk free)</li><li>h:人性化显示</li><li>T：显示文件系统类型</li></ul><p>结果中会有很多类型为tmpfs的文件系统，这些都是Linux中的临时文件系统，一般可以忽略。<code>df -hT | grep -v tmpfs</code>过滤临时文件系统。</p><p>如今ISO镜像使用的频率越来越高，因为光驱已经逐渐淘汰。在Linux系统中，可以将ISO镜像直接挂载使用。Linux系统将ISO镜像视为一种特殊的“回环”文件系统，因此在挂载时需要添加“-o loop“选项。</p><p><code>mount -o loop xxx.iso mnt/cdrom</code>    将ISO文件挂载到/mnt/cdrom目录</p></li></ol><h3 id="磁盘配额管理"><a href="#磁盘配额管理" class="headerlink" title="磁盘配额管理"></a>磁盘配额管理</h3><p>略</p><h3 id="磁盘阵列管理"><a href="#磁盘阵列管理" class="headerlink" title="磁盘阵列管理"></a>磁盘阵列管理</h3><p>传统机械硬盘性能提升缓慢，固态硬盘可靠性较低。</p><p>q: 如何提高硬盘性能，又增强数据存储安全性（备份）？</p><p>a: 多块硬盘组成RAID</p><h6 id="RAID"><a href="#RAID" class="headerlink" title="RAID"></a>RAID</h6><p>RAID（Redundant Array of Independent Disks，独立冗余磁盘阵列），<strong>简称磁盘阵列</strong>。把<strong>多块独立的硬盘</strong>按照不同方式<strong>组合</strong>起来<strong>形成一个硬盘组</strong>。提供比单个硬盘更高的存储性能和数据备份能力。</p><p>从用户的角度看，组成的硬盘组就像一个硬盘，用户可以对它进行分区、格式化等，对磁盘阵列的操作与对单个硬盘基本一样。不同的是，磁盘阵列的<strong>读写速度要比单个硬盘高很多</strong>，而且可以<strong>提供自动数据备份</strong>功能。</p><p>RAID技术的两大特点：速度、安全。</p><p>有时我们希望提高硬盘的工作速度，有时希望提高数据的安全性，更多的时候希望二者兼得。因此，按照不同的用户需求，RAID提供了很多种不同的组合方式，这些组成磁盘阵列的不同方式就称为RAID级别。</p><p>常用的RAID级别：RAID0、RAID1、RAID10（RAID1 + RAID0） 和 RAID5</p><ol><li><p>RAID0——提升硬盘读写速度</p><p>组建RAID0至少需要两块硬盘。</p><p>数据将分成数据块存储在不同的硬盘上。进行数据读写操作时，对于多块硬盘同时操作，从而大幅度提高硬盘工作性能。</p><p>所有RAID机级别中，RAID0存取速度最快，磁盘利用率最高。但是没有冗余，数据没有备份。</p><p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20221205001130.png" alt="image-20210528194516742"></p></li><li><p>RAID1——数据备份</p><p><strong>只需两块硬盘构成</strong>，将用户写入其中一块盘的数据原样地自动复制到另一块盘。读取数据时，先从源盘读取，如果读取失败，则转读备份盘。</p><p>RAID1提供了很高的数据安全保障，但写入速率低，使用一半的空间来存储备份数据，存储成本高。</p></li><li><p>RAID10——将RAID1和RAID0组合</p><p>四块硬盘实现，将四块硬盘分为两组，组成RAID1，以保证数据安全。然后将两个RAID1硬盘组成组RAID0，以提高读写速度。</p><p>读写性能出色，又具有非常高的安全性。但存储成本高，磁盘空间利用率只有50%。<strong>由于大部分情况下相比硬盘的价格，我们更加在乎数据的价值，因此RAID10在生产环境中被广泛应用。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20221205001140.png" alt="image-20210528194448287"></p></li><li><p>RAID5——将奇偶校验信息和数据较差起来进程存储</p><p>至少需要三块盘，将数据分布于不同的硬盘上，硬盘上交叉存储数据与校验信息。</p><p>这样任何一块盘损坏，都可以通过其他硬盘将其中数据恢复回来。</p><p>RAID5，存储数据相对较安全，数据读取速率较高，但写入速率较低；磁盘利用率为（n-1）/ n。</p><p><strong>相比RAID10,是一种妥协的方案，兼顾存储性能、数据安全和储存成本，因而在生产环境中也被广泛采用。</strong></p></li></ol><h6 id="RAID实现方式"><a href="#RAID实现方式" class="headerlink" title="RAID实现方式"></a>RAID实现方式</h6><p>软件RAID：占用一定系统资源，受操作系统稳定性影响。</p><p>硬件RAID：通过独立的RAID硬件显卡，目前大多数服务器配置了RAID卡或主板上集成了RAID控制芯片。不占用其他硬件资源，稳定性和速度都比软件RAID好。</p><h3 id="逻辑卷管理（LVM）"><a href="#逻辑卷管理（LVM）" class="headerlink" title="逻辑卷管理（LVM）"></a>逻辑卷管理（LVM）</h3><p>逻辑卷管理是Linux系统中比较重要的一种磁盘管理机制，管理员利用LVM可以在磁盘不用重新分区的情况下动态调整文件系统的大小，并且利用LVM管理的文件系统可以跨越磁盘。</p><p>例如，系统中的sda1分区原先分配的容量，在使用一段时间后，发现容量不够用。</p><p>如果采用传统的磁盘管理机制，只能将sda硬盘重新分区，并给sda1分区分配更大的空间，但这样不可避免地会造成数据丢失，影响服务器的正常使用。</p><p>如果采用LVM机制，就可以在保证系统正常运行的前提下，随时为sda1分区增大空间，而且即使该分区所在的硬盘sda没有多余的空间可用，也可以随时为服务器添加新的硬盘，并将新的硬盘上的空间扩展到sda1分区中。当然，这里采用sda和sda1的方式进行描述，只是为了方便理解。<strong>当采用LVM机制后，传统意义上的硬盘会被组合成卷组（VG），然后从卷组中划分出逻辑卷（LV）来使用，逻辑卷就相当于传统意义上的磁盘分区。</strong></p><p><strong>LVM为我们提供了逻辑概念上的磁盘，使得文件系统不再关心底层物理磁盘的概念。LVM的出现实现了磁盘空间的动态调整和按需分配。</strong></p><p>LVM是建立在物理磁盘和分区智商的一个逻辑层，通过它可以将若干个磁盘分区组合为一个整体的卷组，形成一个存储池。在卷组中可以任意创建逻辑卷，并进一步在逻辑卷上创建文件系统，最终在系统中挂载使用的就是逻辑卷。逻辑卷的使用方法和普通的磁盘分区完全一样。</p><p>重要概念：</p><ul><li><p>物理卷（Physical Volume，PV ）是构建LVM的基础，通常就是指磁盘或磁盘分区。实现LVM的第一步，将原先的磁盘或磁盘分区转换为LVM物理卷。</p></li><li><p>卷组（Volume Group，VG）是一个存储池，是LVM逻辑概念上的磁盘设备，可以将多个物理卷组合成一个卷组。</p></li><li><p>逻辑卷（Logical Volume，LV）是LVM逻辑概念上的磁盘分区，可以从指定卷组中提取指定的容量来创建逻辑卷，最后对逻辑卷进程格式化和挂载使用。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20221205001152.png" alt="image-20210528203349470"></p><blockquote><p>由于/boot目录用于存放系统引导文件，因此不能应用LVM机制。</p></blockquote><p>逻辑卷的设备文件可以采用“/dev/卷组名/逻辑卷名“的方式。</p><p>CentOS 7安装过程中，自动分区采用LVM机制（除/boot）</p><p><code>pvs</code>      查看系统中的已有物理卷</p><p><code>vgs</code>      查看系统中的已有卷组</p><p><code>lvs</code>      查看系统中的已有逻辑卷</p><p>1.创建物理卷pv</p><p>​    <code>pvcreate /dev/sd&#123;b,c&#125;</code>    将硬盘sdb、sdc转换为物理卷</p><p>​    <code>pvdisplay /dev/sdb</code>     查看置顶的pv：dev/sdb的信息</p><p>2.创建VG</p><p>​    <code>vgcreate wgroup /dev/sd&#123;b,c&#125;</code>     使用物理卷/dev/sdb，/dev/sdc创建名为wgroup的卷组</p><p>​    <code>vgdisplay wgroup</code>    查看指定卷组信息</p><p>3.创建逻辑卷LV</p><p>​    <code>lvcreate -L 容量 -n 逻辑卷名 卷组名</code></p><p>​    <code>lvcreate -L 39G -n ftp wgroup</code>    从wgroup卷组中创建大小为39G的逻辑卷ftp。创建好的逻辑卷设备文件为/dev/wgroup/ftp</p><p>​    <code>lvdisplay /dev/wgroup/ftp</code>     查看逻辑卷信息</p><p>4.使用逻辑卷</p><p>​    <code>mkfs -t xfs /dev/wgroup/ftp</code>    格式化</p><p>​    <code>mount /dev/wgroup/ftp /var/ftp</code></p><pre><code> 修改 /ect/fstab文件实现自动挂载</code></pre><p>5.扩展逻辑卷空间</p><p>由于逻辑卷位于物理磁盘和分区之上的逻辑层，因此逻辑卷可以跨越物理磁盘。</p><p>当需要扩充逻辑卷的空间时，首先应保证它所在的卷组有可以分配的空余空间。我们可以按照以前的步骤，先添加一块盘，将其初始化物理卷之后，再加入卷组，这样就可以任意地调整逻辑卷的容量。</p><p>在调整容量之前先卸载设备和挂载点的关联 <code>umount /var/ftp</code></p><p>将新的磁盘转换为物理卷 <code>pvcreate /dev/sd&#123;d,e&#125;</code></p><p>将新的物理卷加入到卷组中 <code>vgextend wgroup /dev/sd&#123;d,e&#125;</code></p><p>扩展逻辑卷的空间 </p><ul><li><code>vlextend -L +10G /dev/wgroup/ftp</code>     在原有基础上增加10G空间</li><li><code>vlextend -L 10G /dev/wgroup/ftp</code>       将原有空间扩展到10G</li></ul><p>以上完成了对逻辑卷物理边界的扩大，还需要扩大逻辑边界，也就是要更新文件系统的大小。这样，才能使逻辑卷的容量真正发生变化。</p><p>不同类型文件系统使用的命令不同：</p><ul><li>xfs： <code>xfs_growfs 扩展的逻辑卷</code></li><li>EXT系列：<code>resize2fs 扩展的逻辑卷</code></li></ul><p>6.删除LVM分区</p><p>卸载挂载点—删除逻辑卷—删除卷组—删除物理卷</p><p><code>umount /var/ftp</code></p><p><code>lvremove /dev/wgroup/ftp</code></p><p><code>vgremove wgroup</code></p><p><code>pvremove /dev/sd&#123;b,c,d,e&#125;</code></p><p>在卸载挂载点时注意删除 /etc/fstab相应的条目</p><h1 id="用户和权限管理"><a href="#用户和权限管理" class="headerlink" title="用户和权限管理"></a>用户和权限管理</h1><p><code>useradd username</code>    添加用户</p><p><code>passwd username</code>      设置用户的登录密码</p><p><code>su username</code>             切换当前的登录的用户</p><h6 id="权限与归属"><a href="#权限与归属" class="headerlink" title="权限与归属"></a>权限与归属</h6><p>Linux系统中的每个文件或者目录都有两种属性：访问权限（读、写、执行）和文件归属（拥有文件的用户，拥有文件的组）</p><p><code>ls -l xxx    </code>查看文件的权限和归属</p><p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20221205001203.png" alt="image-20210528213617203"></p><ul><li><p>第一列：文件类型+访问权限（所有者的权限+所属组的权限+其他用户的权限）</p></li><li><p>第二列：所有者</p></li><li><p>第三列：所属组</p></li></ul><blockquote><p>用户只要有有对目录的写入权限，就可以删除文件夹下的子目录和文件，而不用管这些文件或子目录是否属于该用户。</p></blockquote><h6 id="chmod修改文件的权限"><a href="#chmod修改文件的权限" class="headerlink" title="chmod修改文件的权限"></a>chmod修改文件的权限</h6><p>chmod(change mode)，只有root用户或者文件的所有者才有权限用chmod命令改变文件或目录的访问权限。</p><p>chmod两种修改文件权限的方式：</p><p>1.字符形式的chmod命令</p><p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20221205001208.png" alt="image-20210528221846415"></p><p><code>chmod o+w 文件</code></p><p>2.数字形式的chmod命令</p><p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20221205001215.png" alt="image-20210528222630258"></p><p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20221205001233.png" alt="image-20210528222642134"></p><p><code>chmod 775 /tep/test</code></p><h6 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h6><p>允许<strong>经过授权的个别普通用户</strong>以root权限执行一些<strong>授权使用的管理命令</strong></p><blockquote><p>sudo运行后，输入的是当前用户的密码，而不是root密码</p></blockquote><p>![image-20210528223217118](/Users/lifeisbinary/Library/Application Support/typora-user-images/image-20210528223217118.png)</p><p>archer用户使用sudo命令也无法创建用户，因为在Linux系统中只有被授权的用户才能执行sudo命令，而且使用sudo也只能执行那些被授权的命令。</p><p>因此要使用sudo命令必须先经过管理员的授权设置，修改配置文件/etc/sudoers</p><p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20221205001252.png" alt="image-20210528223923016"></p><p><code>archer ALL=ALL</code>    可以以sudo执行所有命令</p><p><code>archer ALL=/usr/sbin/useradd,/usr/sbin/userdel,/usr/bin/passwd</code></p><p>执行部分命令</p><p><code>archer ALL=NOPASSWD:/usr/sbin/useradd,/usr/sbin/userdel</code></p><p>执行后不需要输入密码</p><p><code>archer ALL=NOPASSWD:/usr/sbin/useradd,!/usr/bin/passwd root</code>  通过！阻止用户执行指定的命令（阻止修改root的密码，😄）</p><h1 id="Shell脚本"><a href="#Shell脚本" class="headerlink" title="Shell脚本"></a>Shell脚本</h1><p>编译型编程语言：程序转换为二进制代码，计算机直接读取编译后的目标代码（object code），目标代码非常接近计算机底层，所有执行效率高。</p><p>解释型语言：又叫脚本语言，解释器一行为单位，将每行代码一次转换为二进制代码。每次执行程序都多了解释的过程，效率有所下降。</p><p><strong>Shell更加类似于Windows系统中的批处理程序，是一些命令的集合。编写Shell脚本的目的是批量执行一系列系统命令，并通过选择、循环等程序结构加以控制。</strong></p><p>参考资料：<a href="https://book.douban.com/subject/34838376/">https://book.douban.com/subject/34838376/</a></p>]]></content>
      
      
      <categories>
          
          <category> 电脑使用tips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 效率 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac 的操作 与 tip</title>
      <link href="/2022/12/04/Mac-%E7%9A%84%E6%93%8D%E4%BD%9C-%E4%B8%8E-tip/"/>
      <url>/2022/12/04/Mac-%E7%9A%84%E6%93%8D%E4%BD%9C-%E4%B8%8E-tip/</url>
      
        <content type="html"><![CDATA[<h5 id="截图与录屏-：-shift-command-5"><a href="#截图与录屏-：-shift-command-5" class="headerlink" title="截图与录屏 ： shift + command + 5"></a>截图与录屏 ： shift + command + 5</h5><ul><li><p>自动框选截图：shift + command +4 + 空格 </p></li><li><p>点按光标截图之前， contorl + option  </p><ul><li>control——将截图复制到剪贴板</li><li>option——去掉截图的阴影边框</li></ul></li><li><p>调整图片的大小，一般用于一些网站资料上传时图片大小有限制的情况</p><ul><li>使用自带的预览打开图片，文件——导出，调整大小</li></ul></li><li><p>截取pdf文件中的几页，成为单独的文件</p></li><li><p>使用自带的预览打开pdf，选中要导出的页面，拖拽到桌面，自动生成一个新的pdf（只包含你选中的几页）</p></li><li><p>QuickTime 视频压缩</p><ul><li>导出</li></ul></li></ul><h5 id="Finder"><a href="#Finder" class="headerlink" title="Finder"></a>Finder</h5><ul><li><p>文件快速浏览</p><ul><li>command + ”+“     ——图标的放大</li><li>command + ”-“      ——图标的缩小</li><li>空格键 ——文件预览</li><li>command + o ——文件打开</li><li>文件夹<ul><li>右方向键 ——展开文件夹</li><li>左方向键 ——收起文件夹</li></ul></li></ul></li><li><p>文件大小计算</p><ul><li>选中文件，option + command + i </li></ul></li><li><p>无法复制的文本，OCR工具——Text Scaner</p></li><li><p>键盘打开程序坞程序 —— manico</p></li></ul><h5 id="tip"><a href="#tip" class="headerlink" title="tip"></a>tip</h5><ul><li><p>复制一段文字发现格式不对， shift + command + option + v 调整格式</p></li><li><p>程序切换器</p><ul><li><p>按住command，点击tab ——在程序之间切换</p><ul><li>command + tab 只能选中当前的应用图标，无法看到应用具体的标签页，<strong>此时按住方向上键或者下键就可以查看当前应用打开的标签页</strong></li></ul></li><li><p>按住command，点击q ——关闭当前程序</p></li><li><p>按住command，点击h ——隐藏程序</p></li></ul></li><li><p>程序窗口切换 —— tab + command ，松开前按 option，可以调出窗口</p><ul><li>平时窗口的不要关闭和最小化，使用 隐藏 command + H，<strong>这样就不需要按住 option了</strong></li></ul></li><li><p>窗口放大全屏与还原：command + ctrl + f</p></li><li><p>隐藏大部分的窗口，option + command 点击想要保留的窗口的docker栏图标</p></li><li><p>演示、投影或者录屏时，清空桌面 ——<strong>超级右键</strong>，右键桌面，隐藏所有文件</p></li><li><p><strong>copyLess2</strong>文档编辑过程中的，批量筛选与复制 ——让你专心找你需要的内容，将复制和粘贴的碎片时间规整</p><ul><li>Option + command + Z ——开启批量复制</li><li>command + c ——复制</li><li>option + command + x ——粘贴下一个</li></ul></li><li><p>跨文件夹内容选择——文件暂存区.  DropOver </p><ul><li>不同文件夹中的文件统一移动</li><li>实现 文件的剪贴</li></ul></li><li><p>窗口分屏——将窗口拖拽至屏幕边缘</p></li><li><p>Comand + option + 空格—— <strong>瞬间唤醒访达</strong>，并进文件的全局搜索</p></li></ul><h5 id="comand的强大功能"><a href="#comand的强大功能" class="headerlink" title="comand的强大功能"></a>comand的强大功能</h5><ul><li>按住command 移动图标——调整右上角图标的位置</li><li>按住command，显示聚焦搜索文件的位置, 点击即可到达存放当前文件的目录</li><li>按住command，将访达中经常使用的文件夹拖移到访达的工具栏</li><li>按住command，保持前台窗口选中（微信），移动后台的文件到前台窗口中</li><li>按住command，无视排版时的吸附参考线</li></ul><h5 id="option的强大功能"><a href="#option的强大功能" class="headerlink" title="option的强大功能"></a>option的强大功能</h5><ul><li><p>mac默认移动文件是剪贴，按住option移动是复制</p></li><li><p>关闭同一个程序（访达）多个窗口页面</p><ul><li>按住option，点击关闭</li></ul></li><li><p>文件右键，按住option——更改该类型文件的打开方式，并 <strong>复制文件路径</strong></p></li><li><p>按下option，点击滚动条空白位置——页面浏览（pdf）时取消滚动动画的翻页跳转</p></li></ul><h5 id="看视频的同时做笔记——mac画中画"><a href="#看视频的同时做笔记——mac画中画" class="headerlink" title="看视频的同时做笔记——mac画中画"></a>看视频的同时做笔记——mac画中画</h5><ul><li>减少视频和笔记之间的切换 </li><li>html视频画中画功能开启，在视频页面，右键一次，再右键一次选择“画中画”选项</li></ul><h5 id="mac自带输入法技巧"><a href="#mac自带输入法技巧" class="headerlink" title="mac自带输入法技巧"></a>mac自带输入法技巧</h5><ul><li><p>翻页选词</p><ul><li> 不用点击方向键，右手小拇指点击「 和 」进行翻页</li></ul></li><li><p> 混合输入中文英文和数字</p></li><li><p>按住shift输入大写字母</p></li><li><p>按住option输入数字</p><p>eg：我买了1个APPLE</p><p>​        C区7栋10楼D号房</p><p>​    </p></li><li><p>拆字输入 （一些不知道拼音的字输入，不常见字的输入）</p><ul><li>longtian ——shift + 控制 ——䶮</li></ul></li><li><p>Emoji</p><ul><li>comand + control + 空格 ——唤醒emoji</li></ul></li><li><p>持续输入英文</p><ul><li>长按中英文切换的按钮 </li></ul></li><li><p>调出虚拟键盘练习盲打</p></li></ul><h5 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h5><ul><li> command + T 新建标签页（浏览器标签 ）</li><li>  程序内部窗口切换——command + ～  </li><li>打开强制关闭应用的菜单——command + option + esc </li><li>fn + del——删除光标后面的内容</li><li>shift + command + 5 —— 截图和录屏</li></ul><h5 id="触控板的手势操作"><a href="#触控板的手势操作" class="headerlink" title="触控板的手势操作"></a>触控板的手势操作</h5><ul><li>轻点——鼠标单击</li><li>两指轻点——鼠标右键</li><li>三指拖移</li><li>两指上下滑动——网页上下浏览网页</li><li>网页，pdf文档的缩放<ul><li><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20221204232046.png" alt="image-20210417094617748" style="zoom:200%;" /></li></ul></li><li>双指轻拍两下——智能缩放</li><li>网页浏览前进后退<ul><li><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20221204232124.png" alt="image-20210417094923275"></li></ul></li><li>四指向上扫——调度中心（应用程序切换）</li><li>四指向下扫——单个应用的多个打开窗口的平铺</li><li>启动台打开<ul><li><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20221204232129.png" alt="image-20210417095354464"></li></ul></li></ul><h5 id="mac文件管理——访达"><a href="#mac文件管理——访达" class="headerlink" title="mac文件管理——访达"></a>mac文件管理——访达</h5><ul><li><p>文件标签——给文件多维度的 分类</p><ul><li><p>用标记记录在文件夹或文件名中不方便体现的信息</p></li><li><p>标记过的文件即使被打乱，通过标记依然可以有效的查看</p></li><li><p>添加标记</p><ul><li><p>保存文件的时候 ，阅读完内容后添加</p><p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20221204232137.png" alt="image-20210417102012386"></p></li><li><p>访达文件右键添加</p></li></ul></li></ul></li><li><p>文件选中</p><ul><li><p>多文件选中</p><ul><li><p> command + a ——全选，继续按住command 点击需要排出在外的文件</p></li><li><p> shift 连续选择</p></li><li><p> 选中项目新建文件夹</p></li></ul><p>  <img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20221204232145.png" alt="image-20210417112028185"></p><ul><li> 选中文件，回车修改文件</li></ul></li></ul></li></ul><h5 id="聚焦搜索"><a href="#聚焦搜索" class="headerlink" title="聚焦搜索"></a>聚焦搜索</h5><ul><li>文件搜索，按住option点击跳转到文件所在的文件夹</li><li>应用搜索打开，不需要进入启动台找</li><li>单位换算 100美元 = …</li><li><strong>搜索引擎 内容搜索</strong>：内容（ 海贼王） + comand + b </li></ul><h5 id="程序坞"><a href="#程序坞" class="headerlink" title="程序坞"></a>程序坞</h5><ul><li>图标向上拖动，停留一下——在程序坞中删除</li></ul><h5 id="mac虚拟机——-parallels"><a href="#mac虚拟机——-parallels" class="headerlink" title="mac虚拟机—— parallels"></a>mac虚拟机—— parallels</h5><ul><li>虚拟机的状态操控<ul><li>关闭——正常关机</li><li>中止——可读条恢复到中止前的状态</li><li>暂停 ——无需读条恢复到暂停前的状态</li><li>停止——强制关机</li><li>重置——强制关机并启动</li></ul></li><li>文件共享<ul><li>win访问mac文件：Home on Mac 盘符为mac的文件空间</li><li>mac访问win文件： <img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20221204232213.png" alt="image-20210417184031340"></li><li>win的文件在mac中显示路径：<img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20221204232220.png" alt="image-20210417184209656"></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 电脑使用tips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mac </tag>
            
            <tag> 效率 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>“python2下安装qi和almath库import出错”问题解决</title>
      <link href="/2021/08/14/%E2%80%9Cpython2%E4%B8%8B%E5%AE%89%E8%A3%85qi%E5%92%8Calmath%E5%BA%93import%E5%87%BA%E9%94%99%E2%80%9D%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
      <url>/2021/08/14/%E2%80%9Cpython2%E4%B8%8B%E5%AE%89%E8%A3%85qi%E5%92%8Calmath%E5%BA%93import%E5%87%BA%E9%94%99%E2%80%9D%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="出现的问题"><a href="#出现的问题" class="headerlink" title="出现的问题"></a>出现的问题</h2><p>在Pycharm虚拟环境python2.7下，安装Softbank公司Nao机器人库：qi 和 almath 失败</p><h3 id="import-qi"><a href="#import-qi" class="headerlink" title="import qi"></a>import qi</h3><p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20210814141153.png" alt="image-20210622214642779"></p><h3 id="import-almath"><a href="#import-almath" class="headerlink" title="import almath"></a>import almath</h3><p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20210814141203.png" alt="image-20210622214732844"></p><blockquote><p>出现这种错误是因为，python2.7下almath版本太高，需要安装低版本almath=1.6.6。</p></blockquote><p>安装低版本后，又出现新错误</p><p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20210814141210.png" alt="image-20210622214928535"></p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>使用系统自带的python解释器，不要用虚拟环境。</p><blockquote><p>Softbank官方在python库安装的时候已经说了要使用系统自带的python解释器（<a href="http://doc.aldebaran.com/2-5/dev/python/install_guide.html%EF%BC%89">http://doc.aldebaran.com/2-5/dev/python/install_guide.html）</a></p><p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20210814141222.png" alt="image-20210622215254682"></p></blockquote><h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>太不仔细了，我的项目之前在python3虚拟环境下没有问题。所以，想着python2继续用虚拟环境，结果被SoftBank官方教训了，卡了我好久，哈哈。</p>]]></content>
      
      
      <categories>
          
          <category> Nao开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> qi </tag>
            
            <tag> almath </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>宅在家系列Tips——煮饺子笔记</title>
      <link href="/2021/08/14/%E5%AE%85%E5%9C%A8%E5%AE%B6%E7%B3%BB%E5%88%97Tips%E2%80%94%E2%80%94%E7%85%AE%E9%A5%BA%E5%AD%90%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/08/14/%E5%AE%85%E5%9C%A8%E5%AE%B6%E7%B3%BB%E5%88%97Tips%E2%80%94%E2%80%94%E7%85%AE%E9%A5%BA%E5%AD%90%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>广东这边的饺子，蘸料真不习惯。没有辣椒，醋也不带劲。所以准备些料，平时自己做蘸料。简单记一下，方便以后忘记怎么做了会看，毕竟有食堂和外卖吃，一般不动手。</p><h2 id="煮"><a href="#煮" class="headerlink" title="煮"></a>煮</h2><h3 id="速冻饺子"><a href="#速冻饺子" class="headerlink" title="速冻饺子"></a>速冻饺子</h3><p>凉水下锅，这样可以保证水开后，饺子内部和外部的温度接近，里面的馅熟的更快。不会容易出现开水煮时的皮熟馅不熟的情况。</p><h3 id="现包饺子"><a href="#现包饺子" class="headerlink" title="现包饺子"></a>现包饺子</h3><p>沸水下锅，这样皮不容易糊。</p><h3 id="煮时候不粘不破皮的方法"><a href="#煮时候不粘不破皮的方法" class="headerlink" title="煮时候不粘不破皮的方法"></a>煮时候不粘不破皮的方法</h3><ul><li><p>首先，水开后，加入一勺 食盐，使饺子皮有韧度，不易破。</p></li><li><p>然后，放入饺子，轻轻搅动，防止粘锅或粘连再一起。</p></li><li><p>接着， 盖上锅盖，等待煮开。煮开后，加入一碗凉水（使饺子里外受热均匀，面皮劲道，肉馅 口感更好，防止饺子一直滚水，碰撞皮破裂） ，再次盖上锅盖，等待开过再加凉水烧开，一般加三次冷水，就煮好了。（三开三点水） </p></li></ul><p>参考：</p><iframe width="656" height="369" src="https://www.youtube.com/embed/AE8sCbusjdM" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><h2 id="饺子的蘸料"><a href="#饺子的蘸料" class="headerlink" title="饺子的蘸料"></a>饺子的蘸料</h2><p>备料： </p><p>​    小葱、小米椒、大蒜、</p><p>​    盐、鸡精、糖、生抽、陈醋、油泼辣子、香油</p><p>做法：</p><ol><li><p>小葱和小米椒切成圈</p></li><li><p>大蒜拍碎并剁成蒜末</p></li><li><p>碗中放入小米椒、小葱和大蒜末， 泠上适量热油，搅拌均匀</p></li><li><p>加入适量 盐、鸡精、糖，搅拌均匀。加入两勺生抽，两勺陈醋，一勺油泼辣子，适量香油。</p></li></ol><p>参考</p><iframe width="656" height="369" src="https://www.youtube.com/embed/r3CqpIsQaSE" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>]]></content>
      
      
      <categories>
          
          <category> 简餐 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 饺子 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客自定义Live2d挂件</title>
      <link href="/2021/08/11/Hexo%E5%8D%9A%E5%AE%A2%E8%87%AA%E5%AE%9A%E4%B9%89Live2d%E6%8C%82%E4%BB%B6/"/>
      <url>/2021/08/11/Hexo%E5%8D%9A%E5%AE%A2%E8%87%AA%E5%AE%9A%E4%B9%89Live2d%E6%8C%82%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>想给自己搭建好的博客，设置Live2d挂件是比较简单的。</p><p>如下：</p><h3 id="配置live2d模型库提供的模型"><a href="#配置live2d模型库提供的模型" class="headerlink" title="配置live2d模型库提供的模型"></a>配置live2d模型库提供的模型</h3><ol><li><p>安装 hexo helper live2d插件</p><p><code>npm install --save hexo-helper-live2d</code></p></li><li><p>下载live2d仓库中的模型 (下面下载的是<strong>hibiki</strong>模型)</p><p><code>npm install live2d-widget-model-hibiki</code></p><p>如何知道模型库中的模型是效果? 这里给出<a href="https://github.com/xiazeyu/live2d-widget-models">模型库</a>，并提供该库中模型的<a href="https://huaji8.top/post/live2d-plugin-2.0/">在线浏览的网址</a>，方便自己选择。</p></li><li><p>在hexo博客中添加配置信息，使用你下载的模型。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">live2d:</span></span><br><span class="line"><span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">scriptFrom:</span> <span class="string">local</span></span><br><span class="line"><span class="attr">model:</span> </span><br><span class="line"><span class="attr">use:</span> <span class="string">live2d-widget-model-hibiki</span> <span class="comment">#模型选择</span></span><br><span class="line"><span class="attr">display:</span> </span><br><span class="line"><span class="attr">position:</span> <span class="string">right</span>  <span class="comment">#模型位置</span></span><br><span class="line"><span class="attr">width:</span> <span class="number">150</span>       <span class="comment">#模型宽度</span></span><br><span class="line"><span class="attr">height:</span> <span class="number">300</span>      <span class="comment">#模型高度</span></span><br><span class="line"><span class="attr">mobile:</span> </span><br><span class="line"><span class="attr">show:</span> <span class="literal">false</span>      <span class="comment">#是否在手机端显示</span></span><br><span class="line">  <span class="attr">react:</span></span><br><span class="line"><span class="attr">opacity:</span> <span class="number">1</span> <span class="comment"># 透明度设置（1为不透明）</span></span><br></pre></td></tr></table></figure><p>然后hexo s 。就可以看到挂件在博客中的效果了。<img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20210811191634.png" alt="image-20210808235427984"></p></li></ol><p>但是，你可能觉得上面提供可以直接下载的模型比较少，像找一些其他人提供的模型，下载，然后配置进去。这就是本文要说明的情况。</p><h2 id="配置自己下载的模型"><a href="#配置自己下载的模型" class="headerlink" title="配置自己下载的模型"></a>配置自己下载的模型</h2><ol><li><p>下载自己喜欢的模型（目前hexo中的live2d是Live2d Cubism 2 ，Live2d Cubism 3的模型不支持）</p><p>这里提供一个<a href="https://github.com/imuncle/live2d">模型库</a></p></li></ol><ol start="2"><li><p>将自己下载好的模型配置到博客中</p><p>a. 在博客根目录下新建 live2d_models目录</p><p>b. 将下载好的模型解压，丢到live2d_models目录中，同时保证模型的文件夹名和模型目录下的.model.json文件名一致<img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20210811191634.png" alt="image-20210809001404469"></p><p>c. 设置博客配置文件_config中live2d配置下的use的值为模型文件夹名。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">live2d:</span></span><br><span class="line"><span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">scriptFrom:</span> <span class="string">local</span></span><br><span class="line"><span class="attr">model:</span> </span><br><span class="line"><span class="attr">use:</span> <span class="string">Violet</span> <span class="comment">#模型选择</span></span><br><span class="line"><span class="attr">display:</span> </span><br><span class="line"><span class="attr">position:</span> <span class="string">right</span>  <span class="comment">#模型位置</span></span><br><span class="line"><span class="attr">width:</span> <span class="number">150</span>       <span class="comment">#模型宽度</span></span><br><span class="line"><span class="attr">height:</span> <span class="number">300</span>      <span class="comment">#模型高度</span></span><br><span class="line"><span class="attr">mobile:</span> </span><br><span class="line"><span class="attr">show:</span> <span class="literal">false</span>      <span class="comment">#是否在手机端显示</span></span><br><span class="line">  <span class="attr">react:</span></span><br><span class="line"><span class="attr">opacity:</span> <span class="number">1</span> <span class="comment"># 透明度设置（1为不透明）</span></span><br></pre></td></tr></table></figure></li><li><p>hexo s。即可在本地查看效果<img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20210809002410.png" alt="image-20210809002410227"></p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 博客美化 </tag>
            
            <tag> live2d </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Webots2019a revision1下naoqisim连接Nao</title>
      <link href="/2021/08/10/webots2019a-revision1%E4%B8%8Bnaoqisim%E8%BF%9E%E6%8E%A5Nao/"/>
      <url>/2021/08/10/webots2019a-revision1%E4%B8%8Bnaoqisim%E8%BF%9E%E6%8E%A5Nao/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前我在Webots7.4.3上进行过Nao的仿真。（具体如何构建此仿真环境可以参考<a href="https://www.codenong.com/cs105901615/%EF%BC%89%E3%80%82">https://www.codenong.com/cs105901615/）。</a></p><p>Webots7.4.3上Nao的naoqi版本是1.14.3，走起路容易摔倒，左转、右转也转不到位。所以想试试Webots新版下，会不会优化的好一些，毕竟naoqi升级到了2.1.4。</p><p>结论：</p><p>得益于naoqi大版本的升级，效果还是挺明显的。在同样一个场景下，机器人走路再也没有摔倒过，摇晃也基本没有。左右转、后转比之前有好转，有时能够转到位，有时没有办法转到位，但是比以前到达预期位置的误差角度小多了。</p><blockquote><p>本文提供了编译好的naoqisim文件（见标题二末尾），可以直接下载使用。</p></blockquote><hr><p>在Webots 2019a revision 1下，使用Naoqi控制虚拟环境中的Nao机器人。</p><p>平台：windows10</p><h2 id="编译Naoqisim，并导入到Webots中"><a href="#编译Naoqisim，并导入到Webots中" class="headerlink" title="编译Naoqisim，并导入到Webots中"></a>编译Naoqisim，并导入到Webots中</h2><p>naoqisim是Nao机器人在Webots平台上的controller。</p><p>准备材料：</p><ol><li>naoqisim源码</li><li>MSYS2——window下的包管理软件，用来安装一些库或软件（gcc、make等）</li><li>Microsoft Visual Studio C++ 2010 Express</li></ol><blockquote><p>第三个文件不好下载。网上大部分给的都是在线安装的exe，容易出问题退出。</p><p>这里给一个目前（2021年）可以用的下载教程（<a href="https://blog.csdn.net/baojining/article/details/117433410?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-10.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-10.control">Visual c++ 2010 express 学习版离线安装方法</a>）。</p></blockquote><p>步骤：</p><ol><li>首先，使用MYSY2进入下载好的naoqisim根目录下，执行make。脚本会自动下载Nao Simulator SDK并安装。</li><li>然后，使用下载的Visual Studio 2010 打开controllers/naoqisim/naoqisim.sln`,进行编译，这样就得到了naoqisim这个controller。</li><li>接着，将naoqisim根目录下的aldebaran文件夹（其中有SDK）复制到Webots下的<code>projects/robots/softbank/nao/</code>目录中，再将刚才编译的<code>controllers/naoqisim</code>文件夹复制到<code>projects/robots/softbank/nao/controllers/</code>下。</li><li>最后，打开适用于nao机器人的world文件，在场景数中找到Nao机器人元素，设置其中的contorller和naoqi运行的端口（见下图）。<img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20210810001737.png" alt="image-20210810001130466"></li></ol><blockquote><p>这里给一个<a href="https://pan.baidu.com/s/1ujW67u_gyda6zBYuv3sSCg">编译好的文件链接</a>（提取码：evk5），下载并将对应的文件夹移入Webots Nao机器人目录中，直接使用。</p></blockquote><h2 id="Troubleshooting"><a href="#Troubleshooting" class="headerlink" title="Troubleshooting"></a>Troubleshooting</h2><ol><li><p>MSYS2如何进入到你下载好的naoqisim目录。</p><p>如何你打开MYSY2 console，<code>pwd</code>发现是在<code>/home/[Username]</code>目录。</p><p>写绝对路径，来访问吧。</p><p><code>cd /c/User/[Username]/Downlaods/naoqisim-master</code></p><blockquote><p>注意这里，是linux下的文件分割符“/”，同时盘符前需要加“/”。</p></blockquote></li><li><p>在naoqisim目录下，make。提示command not found；</p><p><code>pacman -S make</code></p><p><code>pacman -S unzip</code>(我系统下这个也没有，make不下去了)</p></li><li><p>再次make，报错</p><p>从错误前的log信息可以看出此时simulator-sdk已经有了。报错主要是应为controller的问题。就是说controlelr中编译有问题。</p><p>naoqisim项目的readme文件，提示我们。有了sdk之后，需要在vs2010中打开项目来编译controller</p></li><li><p>vs2010中打开naoqisim.sln，生成。再次报错 error MSB8008。</p><p>按照<a href="https://blog.csdn.net/liuqiyao_01/article/details/38656873">这个博客</a>的方法，将平台工作集设置为v100，即使用VS2010打开工程。</p></li></ol><h2 id="温馨提示"><a href="#温馨提示" class="headerlink" title="温馨提示"></a>温馨提示</h2><p>choregraphe要装对应版本的，也就是2.1.4，新版本无法连接虚拟环境中的Nao。</p>]]></content>
      
      
      <categories>
          
          <category> Nao开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nao </tag>
            
            <tag> Webots </tag>
            
            <tag> naoqisim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python下包管理与虚拟环境</title>
      <link href="/2021/08/07/python%E4%B8%8B%E5%8C%85%E7%AE%A1%E7%90%86%E4%B8%8E%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"/>
      <url>/2021/08/07/python%E4%B8%8B%E5%8C%85%E7%AE%A1%E7%90%86%E4%B8%8E%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>使用python，我们经常需要安装一些我们库/包，基于这些库提供的函数来构建自己的程序。这个时候就需要知道怎么来安装这些库。</p><p>并且我们在开发过程中，不同的项目用到的python版本不一致，如果直接在系统下安装python环境，在开发不同项目时安装库会因为python的版本问题产生冲突，而常用的方式是为每个项目创建env虚拟环境，在虚拟环境中安装项目需要的python版本和对应版本的库。每个项目使用自己的虚拟环境，自然不会产生冲突。</p><h2 id="包安装"><a href="#包安装" class="headerlink" title="包安装"></a>包安装</h2><blockquote><p>注意python在安装包时需要首先知道python的版本（python2/python3）和位数（32/64位）</p><p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/image-20210625152102894.png" alt="image-20210625152102894"></p><p>包下载之前，先将<code>pip</code>和<code>setuptools</code>包更新到最新，减少包安装过程中的错误。</p></blockquote><h3 id="pip安装"><a href="#pip安装" class="headerlink" title="pip安装"></a>pip安装</h3><p>python安装后默认就带有pip包管理工具</p><h6 id="1-配置pip包的国内源"><a href="#1-配置pip包的国内源" class="headerlink" title="1. 配置pip包的国内源"></a>1. 配置pip包的国内源</h6><p>pip默认的包资源都是通过国外的pip官方网站，国内使用网速不好。因此，使用国内的镜像网站（清华pip源、豆瓣pip源）下载更加高效。</p><p><code>pip config set global.index-url http://mirrors.aliyun.com/pypi/simple</code></p><p><code>pip config set global.trusted-host mirrors.aliyun.com</code></p><p>or</p><p><code>pip config set global.index-url https://mirrors.aliyun.com/pypi/simple</code></p><h6 id="2-pip安装第三方包"><a href="#2-pip安装第三方包" class="headerlink" title="2. pip安装第三方包"></a>2. pip安装第三方包</h6><p>pip search xxx</p><blockquote><p>pip search 命令已被弃用。现在需要安装 pip-search包，使用<code>pip_search xxx</code></p></blockquote><p><code>pip install xxx</code></p><p><code>pip install xxx==1.01</code></p><blockquote><p>pip install 安装python相关包时，常常会由于网络问题，导致超时，下载失败，而且换成国内源的时候，也有可能出现这种情况。这个时候可以通过修改timeout加长download的下载时间，缓解超时的问题：<code>--timeout=100</code></p><p>pip install -i <a href="http://mirrors.aliyun.com/pypi/simple">http://mirrors.aliyun.com/pypi/simple</a> –trusted-host mirrors.aliyun.com 指定镜像源</p></blockquote><p><code>pip list</code>   列出当前已安装的第三方包</p><p><code>pip install --upgrade xxx</code> 更新包</p><p><code>pip  uninstall xxx</code> 卸载包</p><p><code>pip show xxx</code> 查看安装好的包信息</p><p><code>pip -V </code>查看当前使用的pip的版本和位置</p><h3 id="whell安装"><a href="#whell安装" class="headerlink" title="whell安装"></a>whell安装</h3><p>wheel文件本质上就是zip或者rar,只不过它更加方便python的安装以及使用</p><ol><li><p>下载xxx包的压缩文件xxx.whl</p></li><li><p>pip install xxx.whl</p></li></ol><blockquote><p>一般的包的whell文件都有收录在pypi.org中收录，所以从pypi下载即可。</p></blockquote><h3 id="source源码安装"><a href="#source源码安装" class="headerlink" title="source源码安装"></a>source源码安装</h3><ol><li><p>下载xxx包的源码文件</p></li><li><p>python setup.py install</p></li></ol><p><strong>说明</strong>：</p><p>其实当我们使用pip安装时，都是whl和source的安装方式，只不过是pip命令自动帮我们下载whl文件或源码，然后自动安装。可以仔细看一下pip install过程中输入的console信息。</p><h2 id="虚拟环境"><a href="#虚拟环境" class="headerlink" title="虚拟环境"></a>虚拟环境</h2><h3 id="Conda-包管理-虚拟环境"><a href="#Conda-包管理-虚拟环境" class="headerlink" title="Conda: 包管理 + 虚拟环境"></a>Conda: 包管理 + 虚拟环境</h3><h4 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h4><p>配置国内源</p><pre><code>添加：conda config --add channels https://mirrors.aliyun.com/pypi/simple/删除：conda config --remove channels https://mirrors.aliyun.com/pypi/simple/查看源：conda config --show-sourcec</code></pre><ul><li><p>查看安装的包： conda list</p></li><li><p>安装包：</p><p>conda search xxx</p><p>conda install xxx</p></li></ul><h4 id="虚拟环境-1"><a href="#虚拟环境-1" class="headerlink" title="虚拟环境"></a>虚拟环境</h4><p>创建虚拟环境：conda create –name envname python=2.7.10</p><blockquote><p>如何创建不同位数的python环境？</p><p>![image-20210720225219101](/Users/lifeisbinary/Library/Application Support/typora-user-images/image-20210720225219101.png)</p></blockquote><p>进入虚拟环境：conda activate envname</p><p>退出当前虚拟环境：conda deactivate</p><p>查看当前存在的虚拟环境：conda env list</p><p>删除虚拟环境 ：conda env remove -n envname</p><blockquote><p>有些包在conda的虚拟环境中安装后，在导入时会出现<code>SystemError: dynamic module not initialized properly</code>的错误，但是virtualenv创建的环境中却没有问题。如qi库（softbank机器人库），不知道怎么回事</p><p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/20210808001202.png" alt="image-20210615005905639"></p></blockquote><p><strong>虚拟环境（env）迁移：</strong></p><p>场景：想将conda创建env环境,copy到另一台同样操作系统的电脑上，方便继续在新电脑上开发。</p><p>首先要明白，迁移的内容是env环境，而env中安装过的库的pkg都在<code>anaconda/pkgs</code>目录下，因此迁移时，需要将env和库的pkg复制到另一台需要创建同样环境的电脑上。</p><blockquote><p>复制pkg后，就不需要在新电脑上重新下载了，会快很多。</p></blockquote><p>步骤如下：</p><ol><li><p>复制 <code>anaconda\envs</code>目录下需要拷贝的虚拟环境文件夹到新电脑上</p></li><li><p>复制<code>anaconda\pkgs</code>目录下的内容到新电脑上的<code>anaconda\pkgs</code>下。</p></li><li><p>通过 拷贝的虚拟环境 来构建新电脑上的虚拟环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create -n 新建虚拟环境名字 --clone path/to/要拷贝的虚拟环境名字 --offline</span><br></pre></td></tr></table></figure></li></ol><h3 id="virtualenv"><a href="#virtualenv" class="headerlink" title="virtualenv"></a>virtualenv</h3><p><code>virtualenv envname</code> 创建</p><p>运行envname\Script\acitvate来激活虚拟环境</p><p><code>deactivate</code> 推出虚拟环境</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://ckfanzhe.github.io/About_conda/">https://ckfanzhe.github.io/About_conda/</a></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 包管理 </tag>
            
            <tag> 虚拟环境 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提升效率的Windows 虚拟桌面（转载）</title>
      <link href="/2021/08/06/%E6%8F%90%E5%8D%87%E6%95%88%E7%8E%87%E7%9A%84Windows-%E8%99%9A%E6%8B%9F%E6%A1%8C%E9%9D%A2%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/"/>
      <url>/2021/08/06/%E6%8F%90%E5%8D%87%E6%95%88%E7%8E%87%E7%9A%84Windows-%E8%99%9A%E6%8B%9F%E6%A1%8C%E9%9D%A2%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>本文转载自少数派作者<a href="https://sspai.com/u/u9vvthsl/updates">火箭君CC</a>的文章，如果喜欢可以去点赞支持。</p><hr><div data-v-3e67f99b="" class="content wangEditor-txt minHeight"><p>Windows 10 发布后，微软终于在自家的操作系统里面内置了<strong>虚拟桌面</strong>功能，而这是 macOS 上早已标配的功能。</p><p>这个功能确实有很强的需求，在没有虚拟桌面之前，对于主力设备是 Windows 的我来说，经常要频繁切换浏览器、日历软件、任务管理软件、聊天软件和邮件客户端……的窗口。窗口之间的重合交叠让人感到「邋遢」和不爽：</p><p></p><figure tabindex="0" class="ss-img-wrapper"><img src="https://cdn.sspai.com/2018/07/27/f5c41ef192c5fdea3d1aeed855cd0573.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="窗口重合交叠的屏幕" title="窗口重合交叠的屏幕" data-original="https://cdn.sspai.com/2018/07/27/f5c41ef192c5fdea3d1aeed855cd0573.png" data-index="0" class="lazyLoadEnd"><figcaption class="ss-image-caption">窗口重合交叠的屏幕</figcaption></figure><p></p><p>虽然说「切换窗口任务」只是按按手指的事情，但是思路却很可能被打断。例如，我正要写一封邮件给 Anna，可能会有以下几件事发生：</p><ol><li>当我想查找之前对话记录时，我要从任务栏的编辑/网页/文件管理器……一堆窗口中挑选一个聊天窗口并点击打开。</li><li>看了聊天后，我突然意识到日程还要定一下，才能通知 Anna，于是再到任务栏的一堆窗口里找日历窗口。</li><li>等我找齐了窗口，弄清了事情，还要重新切换回邮件窗口，等等，我本来想和 Anna 说什么来着？</li></ol><p>一个比较理想的解决方法是：多买几个显示器。这样，你可以把 Windows 桌面扩展到好几个屏幕上。每个屏幕都平铺几个任务窗口备用，扭扭自己的脖子就能「切换」桌面。</p><p>而有了虚拟桌面的功能之后，你也许可以先省下这笔买显示器扩展桌面的预算。</p><h2 id="ss-2-1532922472046" class="ss-hId-1" hid="ss-hId-1">虚拟桌面能干什么？</h2><p>每个虚拟桌面可以被看成是一个独立的工作空间（Workspace）。</p><p>每创建一个虚拟桌面，就像打开了一个新的工作空间。在新的空间中，你能够开启一套完全不同的任务，而不用担心和以前的任务窗口混杂陈列。</p><p></p><figure tabindex="0" class="ss-img-wrapper"><img src="https://cdn.sspai.com/2018/07/10/9a2d8967d19026baf1a5f3fccde00945.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="虚拟桌面的管理界面" title="虚拟桌面的管理界面" data-original="https://cdn.sspai.com/2018/07/10/9a2d8967d19026baf1a5f3fccde00945.png" data-index="1" class="lazyLoadEnd"><figcaption class="ss-image-caption">虚拟桌面的管理界面</figcaption></figure><p></p><p>在使用过程中，我发现三个桌面恰到好处。 我称之为<strong>「三桌面流」 </strong>，这三个桌面分别是：</p><ul><li><strong>工作桌面</strong>：用于放置 开发/创作等编辑器 等软件的窗口</li><li><strong>参考桌面</strong>：用于放置 GTD / 日历 / 参考笔记 等软件的窗口</li><li><strong>通讯桌面</strong>：用于放置 微信 / Slack / 邮件 等软件的窗口</li></ul><p>这样一来，当我要专注创作时，我根本不用关心，也看不到另两个桌面上的窗口内容。当我需要参考信息时直接切换到「参考桌面」即可，上面已经是前次打开状态的参考窗口，不用再去任务栏找窗口了。 想找人微信商量事也一样，直接切换到「通讯桌面」，已经打开的微信窗口，就在那里等着我。</p><p>很大程度上，<strong>避免了频繁最大化、最小化、切换窗口带来的「打断感」</strong>。</p><p></p><figure tabindex="0" class="ss-img-wrapper"><img src="https://cdn.sspai.com/2018/07/12/5faf306b3254fc37ed03d6a5da9f68bb.gif" alt="「三桌面流」的一个例子" title="「三桌面流」的一个例子" data-original="https://cdn.sspai.com/2018/07/12/5faf306b3254fc37ed03d6a5da9f68bb.gif" data-index="2" class="lazyLoadEnd"><figcaption class="ss-image-caption">「三桌面流」的一个例子</figcaption></figure><p></p><h2 id="ss-2-1532922472046" class="ss-hId-2" hid="ss-hId-2">虚拟桌面怎么用？</h2><p>Windows 10 的虚拟桌面虽好，但启动入口略有些隐蔽。以下是几种常用的启动和切换虚拟桌面的方式：</p><h3 id="ss-3-1532922472046" class="ss-hIdChildren-1">可视化入口</h3><p>如果想要启动虚拟桌面的话，最直观的入口就是 <strong>Windows 任务栏上的「任务视图」按钮</strong>。根据我的观察，不同的 Windows10 迭代版本下，这个小按钮会略有不同。</p><ol><li><p>首先，这个按钮需要在 Windows 任务栏上右键呼出菜单，从中选择「显示“任务视图”按钮」才行。</p><p> </p><figure tabindex="0" class="ss-img-wrapper"><img src="https://cdn.sspai.com/2018/07/10/f78c01014a9fee3d1e9533aa274fdd6d.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="打开「任务视图」按钮选项" title="打开「任务视图」按钮选项" width="380" data-original="https://cdn.sspai.com/2018/07/10/f78c01014a9fee3d1e9533aa274fdd6d.png" data-index="3" class="lazyLoadEnd"><figcaption class="ss-image-caption">打开「任务视图」按钮选项</figcaption></figure><p></p></li><li><p>然后，任务栏上会出现这样的图标。</p><p> </p><figure tabindex="0" class="ss-img-wrapper"><img src="https://cdn.sspai.com/2018/07/10/436692fe5affe51b1ac7e189c5f8b14f.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="「任务视图」按钮" title="「任务视图」按钮" width="380" data-original="https://cdn.sspai.com/2018/07/10/436692fe5affe51b1ac7e189c5f8b14f.png" data-index="4" class="lazyLoadEnd"><figcaption class="ss-image-caption">「任务视图」按钮</figcaption></figure><p></p></li><li><p>一旦点击，就会出现「任务视图」，从中就可以切换或创建 「虚拟桌面」了。</p><p> </p><figure tabindex="0" class="ss-img-wrapper"><img src="https://cdn.sspai.com/2018/07/12/79ea65bd16d88f2022420a0af2281118.gif" alt="来自微软官方支持站点的演示" title="来自微软官方支持站点的演示" width="380" data-original="https://cdn.sspai.com/2018/07/12/79ea65bd16d88f2022420a0af2281118.gif" data-index="5" class="lazyLoadEnd"><figcaption class="ss-image-caption">来自微软官方支持站点的演示</figcaption></figure><p></p></li></ol><h3 id="ss-3-1532922472046" class="ss-hIdChildren-2">快捷键入口</h3><p>如果，我正在进行打字编辑类的键盘操作，一般我会采用<strong>快捷键</strong>的方式来切换虚拟桌面。</p><p>快捷键可以让我操作更流畅，双手不会因为「切换」这个动作而随便离开键盘，然后再度返回键盘，造成打断。</p><p>比起可视化入口的操作，以下 5 个「快捷键」可能会实用许多：</p><ol><li><code>Win 键-Tab</code>：打开「任务视图」，相当于点击「可视化入口」。</li><li><code>Win 键-Ctrl-D</code>：创建新的虚拟桌面。</li><li><code>Win 键-Ctrl-F4</code>：删除当前虚拟桌面。</li><li><code>Win 键-Ctrl-左键</code>：切换到相邻左侧的虚拟桌面。</li><li><code>Win 键-Ctrl-右键</code>：切换到相邻右侧的虚拟桌面。</li></ol><p>其中，第 4 和第 5 这两个快捷键尤为实用，几乎相当于传说中的 Boss 键了，如果老板来了，可以让人立刻从「放羊」桌面切换到「工作」桌面。</p><h2 id="ss-2-1532922472047" class="ss-hId-4" hid="ss-hId-4">写在最后</h2><p>相信看到这里，每个人心里都有一套划分自己虚拟桌面创建工作空间（Workspace）的想法。如果没有想法，可以先试试上文中提到的「三桌面流」（即工作桌面、参考桌面、通讯桌面），也许能打开一些思路。</p><p>&gt; 下载 <a href="http://sspai.com/s/nqQk" title="少数派 iOS 客户端">少数派 iOS 客户端</a>、关注 <a href="http://sspai.com/s/KEPQ" title="少数派公众号">少数派公众号</a>，了解更多实用的技巧 💡</p>]]></content>
      
      
      <categories>
          
          <category> 电脑使用tips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> win </tag>
            
            <tag> 虚拟桌面 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac To Win | 不完全迁移体验指北(转载)</title>
      <link href="/2021/08/05/Mac-To-Win-%E4%B8%8D%E5%AE%8C%E5%85%A8%E8%BF%81%E7%A7%BB%E4%BD%93%E9%AA%8C%E6%8C%87%E5%8C%97/"/>
      <url>/2021/08/05/Mac-To-Win-%E4%B8%8D%E5%AE%8C%E5%85%A8%E8%BF%81%E7%A7%BB%E4%BD%93%E9%AA%8C%E6%8C%87%E5%8C%97/</url>
      
        <content type="html"><![CDATA[<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>本文转载自少数派作者<a href="https://sspai.com/u/spencerwoo/updates">SpencerWoo</a>的文章，如果喜欢可以去点赞支持。</p><hr><div data-v-3e67f99b="" class="content wangEditor-txt minHeight"><p>操作系统的变迁，很多人都会遇到：</p><ul><li>学生因为专业软件不适配 macOS，只能使用 Windows；</li><li>上班族由于业务需求，必须从使用多年的 macOS 切换到 Windows；</li><li>……</li></ul><p>最近，我也将自己的全部家当从 macOS 迁移到了 Windows，开始了从一个系统切换到另一个系统的「折腾」。作为曾经的 macOS 用户，我用它完成了很多工作，现在我依然喜欢这个优秀、有设计感的系统。但与此同时，出于对部分专业软件的需求，也为了性能提升和接口兼容，我将服役两年有余的 12 寸 MacBook 淘汰，迁移到了 Windows 平台，开始拥抱 Windows 的生态圈。🐾</p><h2 class="ss-hId-1" hid="ss-hId-1">我怀念 macOS 的哪些功能</h2><p>从 macOS 迁移到 Windows 的过程中，必然有体验上的差别，下面这些在 Apple 生态系统中使用 Mac 的体验让我尤其怀念：</p><ul><li><strong>桌面美学：</strong>macOS 具有设计感的桌面和 Dock</li><li><strong>macOS 系统原生工具的体验：</strong></li><ul><li>空格键「预览（Quicklook）」</li><li>「Handoff」、「Airdrop」等与其他苹果设备的无缝联动</li><li>方便的原生截图、窗口检测与有质感的背景阴影</li></ul>* macOS 上的效率工具：  <ul><li>全局启动器 Alfred（或者原生的 Spotlight）</li><li>类似 iPic 的图床工具</li><li>各路体验优秀的 Markdown 写作工具</li></ul><ul><li><strong>开发环境：</strong>得益于 macOS 类 Unix 系统的属性而有的一套可以媲美 Linux 的开发环境（比如 <code>Homebrew</code> 与原生的 <code>git</code> 和 <code>ssh</code>）</li></ul><p>那么在使用 Windows 与 iPhone 的时候，我能不能找回一些如此顺滑的体验呢？我在 Windows 上做了这样的折腾。 🐟</p><h2 class="ss-hId-2" hid="ss-hId-2">在 Windows 上的折腾</h2><p id="ss-P-1532595188277">针对前面提到的桌面美学、系统工具、效率工具和开发环境这四个方面，我分别针对性地用了不同的工具来尝试性地还原 macOS 上的体验。</p><figure><br><img src="https://cdn.sspai.com/minja/2018-07-24-Wox.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="" data-original="https://cdn.sspai.com/minja/2018-07-24-Wox.png" data-index="0" class="lazyLoadEnd"></figure><h3 class="ss-hIdChildren-1">设计桌面</h3><p>Apple 是一家标榜设计的公司，macOS 的桌面美学确实让包括我在内的很多人赞叹。当然，我在使用 Windows 的这一周以来，发现经过 Fluent Design 重新设计的 Windows 10 也相比之前的老一代 Windows 有着巨大的美学改善。进一步借助下面这些小工具和，我找回了不输 macOS 的美观桌面。</p><figure tabindex="0" draggable="false" class="ss-img-wrapper" contenteditable="false"><img src="https://cdn.sspai.com/minja/2018-07-24-%E6%88%91%E7%9A%84%E6%A1%8C%E9%9D%A2.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="" data-original="https://cdn.sspai.com/minja/2018-07-24-%E6%88%91%E7%9A%84%E6%A1%8C%E9%9D%A2.png" data-index="1" class="lazyLoadEnd"><figcaption class="ss-image-caption">我的桌面</figcaption></figure><h4>① <a href="https://github.com/TranslucentTB/TranslucentTB/">TranslucentTB</a>：开源的任务栏透明工具&nbsp;</h4><p>美化桌面的步骤中，必不可少修改任务栏，改掉它不透明的生硬效果。有人会选择修改注册表，这不仅很危险，还只能将任务栏半透明化，而另外一些如 StarDock 的美化软件又很占内存。这个开源的 TranslucentTB 则不然，既小巧、不占内存、还可以将任务栏透明、半透明、模糊、或是直接显示纯色，可以说是功能全面了。<b>显示效果就像上图那样，能够完整的呈现我们的壁纸而不必担心任务栏挡掉一部分。</b></p><h4>②&nbsp;<a href="https://www.rainmeter.net/" target="_blank" class="insert-link">Rainmeter</a>：Windows 桌面美化插件</h4><p>对于深度美化 Windows 桌面的同学来说，Rainmeter 的重要性可想而知。在 Rainmeter 的 <a href="https://www.rainmeter.net/">官网</a>、<a href="https://forum.rainmeter.net/">官方用户社区</a>、和 <a href="https://www.deviantart.com/rainmeter">DeviantArt 设计站点</a>，都有大量设计精美的 Rainmeter 插件，但是我也并不推荐将插件直接堆砌在桌面上，一团糟的样子不仅不美观，还占用了大量的系统资源。<b>我只小小利用了其桌面时钟、日期的显示。</b></p><figure tabindex="0" draggable="false" class="ss-img-wrapper" contenteditable="false"><img src="https://cdn.sspai.com/minja/2018-07-24-02_Rainmeter.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="" data-original="https://cdn.sspai.com/minja/2018-07-24-02_Rainmeter.png" data-index="2" class="lazyLoadEnd"><figcaption class="ss-image-caption">Rainmeter</figcaption></figure><p>我目前使用的 Rainmeter 主题在这里可以下载到 → <a href="https://www.deviantart.com/lilshizzy/art/Rainmeter-Elegance-2-244373054">Rainmeter Elegance 2.0</a></p><h4>③ <a href="http://simpledesktops.com/browse/">Simple Desktops</a>：壁纸提供站</h4><p>美化桌面方面，壁纸可以说是重中之重。一张简单可爱的壁纸可以奠定整个工作的态度。在 Simple Desktops 里我总能找到可爱的壁纸。</p><figure tabindex="0" draggable="false" class="ss-img-wrapper" contenteditable="false"><img src="https://cdn.sspai.com/minja/2018-07-24-03_Simple%20Desktop.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="" data-original="https://cdn.sspai.com/minja/2018-07-24-03_Simple%20Desktop.png" data-index="3" class="lazyLoadEnd"><figcaption class="ss-image-caption">Simple Desktop</figcaption></figure><p>除此之外，无版权图片社区 <a href="https://unsplash.com">Unsplash</a>、免费图片社区 <a href="https://pixabay.com/zh/">Pixabay</a>、甚至是必应每日壁纸等等都是优秀的壁纸来源。</p><h4>④ 文件管理和日常清理的习惯</h4><p>简洁的文件管理、不复杂凌乱的桌面和常清理的使用习惯自然会让你的 Windows 使用体验蒸蒸日上。💗</p><p>参考：《<a href="https://sspai.com/series/13" target="_blank" class="insert-link">每个人都应该学会正确管理文件</a>》（<span style="font-family: &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif; font-size: 16px;">少数派付费教程</span>）</p><h3 class="ss-hIdChildren-2">系统工具</h3><h4>① <a href="https://github.com/Wox-launcher/Wox">WoX</a>&nbsp;和 <a href="https://www.voidtools.com/">Everything</a>：启动器工具</h4><figure tabindex="0" draggable="false" class="ss-img-wrapper" contenteditable="false"><img src="https://cdn.sspai.com/minja/2018-07-24-Wox.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="" data-original="https://cdn.sspai.com/minja/2018-07-24-Wox.png" data-index="4" class="lazyLoadEnd"><figcaption class="ss-image-caption">Wox</figcaption></figure><p>WoX 是 Windows 上大名鼎鼎的开源启动器，我派对它有详尽的介绍 → 在<a href="https://sspai.com/post/33460">这里</a>。</p><p>WoX 的看家功夫是基于 Everything 的基本文件搜索功能，它能在不到一秒钟的时间内将你想要的文件进行搜索并展现出来，快如闪电，当然这也包括将你要打开的应用快捷方式搜索出来，因而 WoX 可以充当应用程序的快捷启动器。除此之外，WoX 还可以调用计算器、预览颜色、打开控制面板的某项选项、直接调用搜索引擎搜索内容和直接运行 Shell 命令等等，而这些功能都归功于其强大的 Plugin 插件功能。当然 WoX 也提供了外观主题的定制功能。</p><p>WoX 和 Everything 两工具的完美结合，在使用体验上可以媲美 macOS 上的 Spotlight、Alfred 等效率启动器。</p><h4>② QuickLook ：空格键预览工具</h4><figure tabindex="0" draggable="false" class="ss-img-wrapper" contenteditable="false"><img src="https://cdn.sspai.com/minja/2018-07-24-05_QuickLook.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="" data-original="https://cdn.sspai.com/minja/2018-07-24-05_QuickLook.png" data-index="5" class="lazyLoadEnd"><figcaption class="ss-image-caption">QuickLook</figcaption></figure><p>macOS 上的「一指禅」—— 空格预览文件内容，绝对是一个经典、令人印象深刻的功能。在 Windows 上，QuickLook 可以实现空格预览的功能，并且支持的格式也很丰富，能够预览图片、文本、docx 文档、甚至是各种源码等等一系列文件。macOS 一指禅在 Windows 上也能完美践行了。🦄</p><figure tabindex="0" draggable="false" class="ss-img-wrapper" contenteditable="false"><img src="https://cdn.sspai.com/minja/2018-07-24-%E7%A9%BA%E6%A0%BC%E9%A2%84%E8%A7%88%E5%9B%BE%E7%89%87%E3%80%81%E6%96%87%E6%9C%AC%E5%92%8C%20Markdown.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="" data-original="https://cdn.sspai.com/minja/2018-07-24-%E7%A9%BA%E6%A0%BC%E9%A2%84%E8%A7%88%E5%9B%BE%E7%89%87%E3%80%81%E6%96%87%E6%9C%AC%E5%92%8C%20Markdown.png" data-index="6" class="lazyLoadEnd"><figcaption class="ss-image-caption">空格预览图片、文本和 Markdown</figcaption></figure><p>QuickLook 可以直接在 Windows 应用商店免费下载得到。</p><h4>③&nbsp;<a href="http://clipber.com/" target="_blank" class="insert-link">快贴</a>：云剪贴板工具<br></h4><p>快贴是一个免费的跨平台的剪贴板同步工具，能够在多端设备同步剪贴板，并对剪贴板涉密内容进行自动识别、加密传输。</p><figure tabindex="0" draggable="false" class="ss-img-wrapper" contenteditable="false"><img src="https://cdn.sspai.com/minja/2018-07-24-%E5%BF%AB%E8%B4%B4.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="" data-original="https://cdn.sspai.com/minja/2018-07-24-%E5%BF%AB%E8%B4%B4.jpg" data-index="7" class="lazyLoadEnd"><figcaption class="ss-image-caption">快贴</figcaption></figure><p>我在 iOS 和 Windows 端同时下载了快贴，在 iOS 保持后台运行的情况下，我在手机上复制的内容，能够很快的同步到云端，进而在 Windows 端能够粘贴。但是这个过程比 macOS 繁琐的地方在于，我需要通过全局快捷键来手动触发粘贴端的同步，这样的多一步操作虽说影响体验，也肯定不如 macOS 闭源的生态系统好，但是至少我不必用微信、QQ 之流当作我电脑与手机沟通的渠道了。</p><p>参考：<a href="https://sspai.com/post/43775" target="_blank" class="insert-link" style="font-family: &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif; font-size: 16px; font-style: inherit; font-variant-caps: inherit;">好用的全平台剪切板工具，我们为你找到了这&nbsp;3&nbsp;款</a></p><h4>④ <a href="https://send-anywhere.com/file-transfer">Send Anywhere</a>：文件传输工具</h4><p>Send Anywhere 将文件上传到一个 p2p 网络上面，并非其服务器上，接受端通过随机六位接收码进行文件接受。这样的传输方式保证了文件的安全性和完整性，又能有相当的上传、下载和传输速度。Send Anywhere 可以说是全平台 Airdrop 了。</p><figure tabindex="0" draggable="false" class="ss-img-wrapper" contenteditable="false"><img src="https://cdn.sspai.com/minja/2018-07-24-08_Send%20Anywhere.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="" data-original="https://cdn.sspai.com/minja/2018-07-24-08_Send%20Anywhere.jpg" data-index="8" class="lazyLoadEnd"><figcaption class="ss-image-caption">Send Anywhere</figcaption></figure><p>同时 Send Anywhere 有设备记忆功能，在曾经传输过文件的设备上，下一次传输的时候，六位接收码都不必输入。这样的分享文件的特性可以说是跨平台的救命稻草了。我在使用过程中除了在 Windows 平台传输结束之后 Send Anywhere 本身有几次会卡死，其他体验都极佳。</p><p>参考：<a href="https://sspai.com/post/40047" target="_blank" class="insert-link" style="font-family: &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif; font-size: 16px; font-style: inherit; font-variant-caps: inherit;">免费全平台的文件分享利器：SendAnywhere</a></p><h3 class="ss-hIdChildren-3">效率工具</h3><h4>① smpic：sm.ms 图床上传软件</h4><p>我的博客图片全部都放到了第三方的图床上面，这让我需要有一个便捷的图片上传途径。</p><p>smpic 通过 SM.MS 图床的 API 与大名鼎鼎的 AutoHotKey 脚本实现了这样的图片上传利器，我将快捷键绑定为 <code>Ctrl</code> + <code>Alt</code> + <code>U</code>，这样点击图片按下快捷键直接就可以将图片上传至图床，并同时返回相应的图片引用链接，一气呵成。</p><p>smpic 同样，是一款开源、免费的软件，可以在其&nbsp;<a href="https://github.com/kookob/smpic" target="_blank" class="insert-link">Github 页面</a>进行下载。</p><h4>②&nbsp;<a href="https://typora.io/" target="_blank" class="insert-link">Typora</a>： Markdown 编辑器</h4><figure tabindex="0" draggable="false" class="ss-img-wrapper" contenteditable="false"><img src="https://cdn.sspai.com/minja/2018-07-24-09_Typora.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="" data-original="https://cdn.sspai.com/minja/2018-07-24-09_Typora.png" data-index="9" class="lazyLoadEnd"><figcaption class="ss-image-caption">Typora</figcaption></figure><p>Typora&nbsp;不必多说了，基本上是 Windows 上写 Markdown 的必备利器了。我的这篇文章就是在 Windows 的 Typora 上面编写完成的。我派对 Typora 也有详尽的介绍：<a href="https://sspai.com/post/30292">让 Markdown 写作更简单，免费极简编辑器：Typora</a></p><h4>③&nbsp;<a href="https://www.snipaste.com" target="_blank" class="insert-link">Snipaste</a>：截图工具</h4><figure tabindex="0" draggable="false" class="ss-img-wrapper" contenteditable="false"><img src="https://cdn.sspai.com/minja/2018-07-24-10_Snipaste.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="" data-original="https://cdn.sspai.com/minja/2018-07-24-10_Snipaste.png" data-index="10" class="lazyLoadEnd"><figcaption class="ss-image-caption">Snipaste</figcaption></figure><p>Snipaste&nbsp;着实是 Windows 上最好的截图工具。但 Snipaste 除了我们常见的截图标注、窗口检测、全局快捷键等等简朴必备技能，还有贴图、取色等等高阶可玩性。目前 Snipaste 在 Windows 商店就可以下载得到，并且就在最近几天 Snipaste 也发布了 Pro 版本，增加了更多的玩法。</p><figure tabindex="0" draggable="false" class="ss-img-wrapper" contenteditable="false"><img src="https://cdn.sspai.com/minja/2018-07-24-11_Snipaste%20In%20Action.gif" alt="" data-original="https://cdn.sspai.com/minja/2018-07-24-11_Snipaste%20In%20Action.gif" data-index="11" class="lazyLoadEnd"><figcaption class="ss-image-caption">Snipaste In Action</figcaption></figure><p>Snipaste 的开发者对 Snipaste 很是上心，我派单独采访了这位同学，在这里有更加具体的介绍 →&nbsp;<a href="https://sspai.com/post/35097">幕后丨他做了最强免费「截图」工具 Snipaste 后，还有上万字的话想说</a></p><p>上面介绍的工具中，除了 Typora 和图床上传工具 smpic 以外（smpic 因为免安装，所以不支持开机自启动），剩下的都有幸被我加入开机自启动名单。🎉</p><h3 class="ss-hIdChildren-4">开发环境</h3><p>经过近两年的开发，目前 Windows Subsystem For Linux（以下简称 WSL）已经十分完善。我从微软商店下载安装了 Ubuntu 18.04 作为 WSL 的系统，并使用 Ubuntu 下的 <code>aptitude</code> 包管理工具链配置了我的开发环境。安装 WSL 的详细步骤在 →&nbsp;<a href="https://docs.microsoft.com/zh-cn/windows/wsl/install-win10">这里</a>。</p><figure tabindex="0" draggable="false" class="ss-img-wrapper" contenteditable="false"><img src="https://cdn.sspai.com/minja/2018-07-24-12_Ubuntu%20WSL.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="" data-original="https://cdn.sspai.com/minja/2018-07-24-12_Ubuntu%20WSL.png" data-index="12" class="lazyLoadEnd"><figcaption class="ss-image-caption">Ubuntu WSL</figcaption></figure><p>在 WSL 中我安装了我的必备开发工具：</p><ul><li><code>git</code> 代码版本控制</li><li><code>ssh</code> 远程服务器连接 🔗</li><li><code>zsh</code> 与 <code>oh-my-zsh</code> Shell 环境</li></ul><p>在 Windows 中我通过 Hyper 终端环境进行实战。</p><p>Hyper 是一个基于 Election 的终端 Terminal Emulator，是一个插件丰富的、跨平台的终端。我写过一个有关它的详细介绍&nbsp;<a href="https://spencerwoo.com/2018/06/16/Terminal/">HOW TO | 让自己的终端漂亮得不像实力派</a>。在 Windows 下，可以通过 Hyper 调用 WSL 中的 <code>bash.exe</code>，这样就不用面对万恶的小黑框了。😈</p><figure tabindex="0" draggable="false" class="ss-img-wrapper" contenteditable="false"><img src="https://cdn.sspai.com/minja/2018-07-24-13_%C5%92%E2%80%9C%C2%B5%C6%92%C2%B5%C2%B1%C2%AB%E2%88%9E%C3%B8%E2%84%A2%E2%88%91%C2%A2%C2%AA%E2%88%91%C3%A6%E2%89%A5.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="" data-original="https://cdn.sspai.com/minja/2018-07-24-13_%C5%92%E2%80%9C%C2%B5%C6%92%C2%B5%C2%B1%C2%AB%E2%88%9E%C3%B8%E2%84%A2%E2%88%91%C2%A2%C2%AA%E2%88%91%C3%A6%E2%89%A5.png" data-index="13" class="lazyLoadEnd"><figcaption class="ss-image-caption">我当前的开发环境</figcaption></figure><p>这样折腾之后，一套可用的基于命令行的开发环境也处于可用状态了。目前存在的问题是从 Windows 端调用 Linux 内部的指令还是有些问题，比如我在 Visual Studio Code 中试图调用 Linux 环境下的 Python 解释器进行调试就异常麻烦，目前 Visual Studio Code 团队对 C/C++ 和 Node.js 的调试都已经适配完成，至于 Python、Go 等语言，我相信未来的适配也会越来越完善。</p><p>参考：<a href="https://github.com/lloydstubber/my-wsl-setup" target="_blank" class="insert-link" style="font-family: &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif; font-size: 16px; font-style: inherit; font-variant-caps: inherit;">My&nbsp;WSL&nbsp;Setup&nbsp;by&nbsp;lloydstubber</a></p><h2 class="ss-hId-3" hid="ss-hId-3">最后的体验</h2><p>经过这样的折腾，我在 Windows 上面的效率工具和开发环境体验也和 macOS 上的体验已经相差无几，也基本上实现了&nbsp;iPhone&nbsp;和&nbsp;Windows&nbsp;的无缝联动。</p><p>当然，为了习惯去让一个系统无谓地模拟另一个系统的体验是毫无意义的，我找回 macOS 特点的同时也在享受 Windows 的特色功能，比如用 OneDrive 方便地同步我的文件、用手写笔对 PDF 进行标注、在 OneNote 上进行笔记书写，甚至还能用手写笔在 Autodesk SketchBook 中绘画，这些体验都比 macOS 更好。还有一点很重要，Windows 能用上功能完整的 Office 套件。</p><p>现在对我而言，Windows 也有不方便的地方，下载软件开发所需要的依赖就比较麻烦，毕竟它不是原生的 Unix，但综合体验上，无论是美学、还是效率，我给我目前的 Windows 打五星。⭐⭐⭐⭐⭐</p><figure tabindex="0" draggable="false" class="ss-img-wrapper" contenteditable="false"><img src="https://cdn.sspai.com/minja/2018-07-24-14_My%20ThinkPad.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="" data-original="https://cdn.sspai.com/minja/2018-07-24-14_My%20ThinkPad.jpg" data-index="14" class="lazyLoadEnd"><figcaption class="ss-image-caption">我的 ThinkPad</figcaption></figure><p>题图来自 <a href="https://www.freepik.com/free-vector/cloud-storage-concept_1063667.htm">Freepik</a></p><p>&gt; 下载 <a href="https://sspai.com/page/client">少数派客户端</a>、关注 <a href="http://sspai.com/s/KEPQ">少数派公众号</a>，读更多有趣的内容 🎉</p></div>]]></content>
      
      
      <categories>
          
          <category> 电脑使用tips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> win </tag>
            
            <tag> macToWin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器人仿真平台——Webots使用的一些背景信息</title>
      <link href="/2021/08/03/%E6%9C%BA%E5%99%A8%E4%BA%BA%E4%BB%BF%E7%9C%9F%E5%B9%B3%E5%8F%B0%E2%80%94%E2%80%94Webots%E4%BD%BF%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E8%83%8C%E6%99%AF%E4%BF%A1%E6%81%AF/"/>
      <url>/2021/08/03/%E6%9C%BA%E5%99%A8%E4%BA%BA%E4%BB%BF%E7%9C%9F%E5%B9%B3%E5%8F%B0%E2%80%94%E2%80%94Webots%E4%BD%BF%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E8%83%8C%E6%99%AF%E4%BF%A1%E6%81%AF/</url>
      
        <content type="html"><![CDATA[<p>最近做实验，需要使用Webots仿真平台。记录一下Webots中的一些概念和常用的操作。</p><h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><ul><li>world：整个你可以看见的仿真环境，包括机器人和机器人所在的场景，以.wbt为扩展名，存储在world目录中。</li><li>controller：控制仿真环境中虚拟机器人的控制器，可以是C++、python、java、matlab等语言编写，放置在每个Webots项目的“ controllers”子目录中。</li><li>motion：定义的一些列的虚拟机器人动作，比如，前进，后退，左转、右转，握手等等。</li></ul><hr><ul><li><p>场景树：描述整个仿真环境的一种结构,如下图：<img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/image-20210803200917964.png" alt="image-20210803200917964"></p><ul><li>WorldInfo：包含模拟场景的全局参数。</li><li>Viewpoint：定义主要视点相机参数。</li><li>TexturedBackground：定义场景的背景。</li><li>TexturedBackroundLight：定义与上述背景关联的光。</li><li>RectangleArena：定义场景中的方形棋盘。</li><li>WoodBox：定义场景中的三个木箱。</li></ul><p>每个节点都是场景中的元素，可以改元素下的属性(物体的大小、墙体的厚度、物体的位置等)，来调整仿真环境。</p></li></ul><h2 id="world的操作查看方式"><a href="#world的操作查看方式" class="headerlink" title="world的操作查看方式"></a>world的操作查看方式</h2><p>使用鼠标在3D视图中移动视点：</p><ul><li><p>视图旋转：左按钮移动</p></li><li><p>视图平移：右按钮移动</p></li><li><p>视图缩放：滚轮</p></li><li><p>物体位置调整——移动：选中物体，鼠标移动到物体的坐标轴箭头处，可以激活当前该轴向的物体位置调节功能。拖过鼠标可以调节物体位置。<img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/image-20210803202027162.png" alt="image-20210803202027162"></p></li><li><p>物体姿态调整——转动：同理。选中物体，鼠标移动到物体的转动坐标轴处，可激活当前该转轴向的物体姿态调节功能。鼠标拖动可以调节物体姿态。</p></li></ul><p>当然，最方便的还是选中物体，<code>shift+鼠标左键移动</code>来将物体移动到某位置位置，<code>shift+鼠标右键移动</code> 来控制物体的旋转。</p><h2 id="你需要做的事情"><a href="#你需要做的事情" class="headerlink" title="你需要做的事情"></a>你需要做的事情</h2><ol><li>搭建wrold（环境 + 机器人 + 物体等）</li><li>编写控制机器人的控制器controller，来完成你需要实现的机器人行为功能。</li><li>设置机器人的控制器为你写好的controller。设置方式如下图<img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/image-20210803205502071.png" alt="image-20210803205502071"></li></ol><h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><ul><li>修改Webots world保存时，首先要暂停模拟并将其重新加载到初始状态,即主虚拟计时器应显示0：00：00：000。否则，每次保存时，每个3D对象的位置都会累积错误。因此，对wrold的修改都应按以下顺序执行：暂停，重置，修改和保存仿真。</li></ul><h2 id="Webots教程"><a href="#Webots教程" class="headerlink" title="Webots教程"></a>Webots教程</h2><p>推荐csdn博主<a href="https://blog.csdn.net/weixin_41045354/article/details/105072630">“我是。”的教程</a> 和<a href="https://rupingcen.blog.csdn.net/article/details/106396478">“熊猫飞天”的教程</a><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/image-20210803212647750.png" alt="image-20210803212647750"><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/image-20210803214508910.png" alt="image-20210803214508910"></p>]]></content>
      
      
      
        <tags>
            
            <tag> ROS仿真 </tag>
            
            <tag> Webots </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>非侵入式脑机接口落地情况报告</title>
      <link href="/2021/08/01/%E9%9D%9E%E4%BE%B5%E5%85%A5%E5%BC%8F%E8%84%91%E6%9C%BA%E6%8E%A5%E5%8F%A3%E8%90%BD%E5%9C%B0%E6%83%85%E5%86%B5%E6%8A%A5%E5%91%8A/"/>
      <url>/2021/08/01/%E9%9D%9E%E4%BE%B5%E5%85%A5%E5%BC%8F%E8%84%91%E6%9C%BA%E6%8E%A5%E5%8F%A3%E8%90%BD%E5%9C%B0%E6%83%85%E5%86%B5%E6%8A%A5%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<h2 id="写作目的"><a href="#写作目的" class="headerlink" title="写作目的"></a>写作目的</h2><p>&emsp;&emsp;本文梳理了脑机接口技术在各个领域的应用情况。通过各领域的成熟应用案例和当前学术研究进展情况，分析非侵入式脑机接口技术落地情况。</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><h3 id="脑机接口"><a href="#脑机接口" class="headerlink" title="脑机接口"></a>脑机接口</h3><p>&emsp;&emsp;<strong>脑机接口（Brain-computer interface, BCI）是在大脑与外部环境之间建立一种全新的不依赖于外周神经和肌肉的交流与控制通道，从而实现大脑与外部设备的直接交互。</strong>该技术能够在人脑与外部环境之间建立沟通以达到控制设备的目的，进而起到监测、替代、改善/恢复、增强、补充的作用。作为一门多学科交叉的研究领域，涉及神经科学、认知科学、心理学、影像医学、生物医学工程、材料科学、电子工程、信号处理与模式识别等多个学科，是一项复杂的系统工程。</p><p>&emsp;&emsp;构建一个脑机接口系统需要实现四部分功能：<strong>信号采集、信息解码、再编码和反馈。</strong>通过布置在脑部的电极采集脑电信号，经过预处理、特征提取和分类，识别出特定的脑模式。根据应用场景下脑模式或脑模式序列编码的规则，将脑模式特征转译为外部设备可理解的控制信号。用户通过反馈环节获得外部环境和设备的状态信息，形成控制——感知——控制的闭环方式。</p><p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/bci%E6%AD%A5%E9%AA%A4-20210801124547229.jpg"></p><center>图1 BCI系统示意图</center><h3 id="侵入式和非侵入式脑机接口"><a href="#侵入式和非侵入式脑机接口" class="headerlink" title="侵入式和非侵入式脑机接口"></a>侵入式和非侵入式脑机接口</h3><p>&emsp;&emsp;根据脑机接口系统信号采集时电极的布置位置，可分为侵入式脑机接口（大脑皮层或灰质处布置电极）和非侵入式脑机接口（大脑头皮处布置电极）。</p><ul><li>侵入式BCI可以直接记录神经元电活动，信号衰减小，信噪比和空间分辨率高，能够区分。但植入有创伤，技术难度大，存在继发感染的可能性。</li><li>非侵入式BCI通过附着在头皮上的穿戴设备测量大脑的电活动或代谢活动，无需手术，安全无创。其中脑电帽是最常用的非侵入式传感器，可以在头皮上监测到群体神经元的放电活动，时间分辨率高，但空间分辨率低，且受大脑容积导体效应的影响，传递至头皮表面时衰减较大，易被噪声污染，信噪比低。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/image-20210722164811563-20210801124604533.png"></p><center>图2     侵入式与非侵入式BCI电极布置位置</center><p>&emsp;&emsp;目前，非侵入式脑机接口的研究和应用占主导地位。非侵入式BCI根据采用的脑模式又可分为P300-BCI、SSVEP-BCI 和MI-BCI。</p><ul><li><p>P300-BCI：P300 是一种事件相关电位，实验证实当人脑受到小概率新奇事件刺激后300ms 左右脑电信号会出现一个正向波峰。基于P300 信号特征的脑机接口系统具有<strong>目标多、个体差异较少</strong>的优点,已被广泛研究并测试应用，需要注意的是，该类BCI 需要多次重复闪烁,而<strong>长时间的重复闪烁</strong>,会影响患者的使用体验。</p><p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/image-20210722210050859-20210801124622027.png"></p><center>图3     P300电位（红色垂直线代表出现字符w的刺激，绿色和橙色的脑电波分别代表刺激产生后有P300的脑电波和没有P300的脑电波）</center></li><li><p>SSVEP-BCI：SSVEP （视觉稳态诱发电位）是当人眼视网膜受到恒定频率（大于6HZ）的闪光或图形刺激时，会诱发大脑视觉皮层产生可记录到的电位变化，该变化与刺激频率及其谐波频率一致。基于SSVEP 的BCI 特征提取简单、准确率和<strong>信息传输率高</strong>，用户不需要训练。这类BCI 的<strong>控制命令数量受刺激频率及其他因素影响</strong>,特别是当命令数增加时，分类精度下降。</p><p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/image-20210722211214229-20210801124641132.png"></p><center>图4    SSVEP信号特征（红色实心圆圈表示不同频率的刺激源，图中的波形对应注意到刺激后产生的脑电波功率谱）</center></li><li><p>MI-BCI：MI （运动想象）是人在心理感觉一个动作过程但不发生实际运动，是一种内隐性心理活动，<strong>无需外界刺激</strong>。研究表明运动想象会在感觉运动皮层诱发事件相关去同步/同步（ERD/ERS）响应。基于运动想象脑信号特征的脑机接口系统可用于运动障碍康复训练、假肢和轮椅控制等。该类脑机接口系统的用户需要一定量的训练，其性能不仅取决于解码算法，还取决于用户的运动想象表现，此外目前<strong>可辨识的运动想象的模式有限</strong>，只有六种，很难产生数量较多的外部设备控制命令。</p><p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/image-20210722211658567-20210801124658321.png"></p><center>图5  MI信号特征（图中脑部的热力图为不同位置电极在运动想象时的电压幅值对比情况，左手运动想象时左侧脑部的电极电压幅值明显降低，右侧脑补的电极电压幅值变高。出现左侧去同步化，右侧同步化响应的情况。同理右手运动想象时会出现右侧去同步化，左侧同步化的现象）</center></li></ul><h3 id="非侵入式脑机接口应用方向"><a href="#非侵入式脑机接口应用方向" class="headerlink" title="非侵入式脑机接口应用方向"></a>非侵入式脑机接口应用方向</h3><p>脑机接口技术的功效可以归结为如下5 类：</p><ul><li>监测：使用脑机接口系统监测部分人体意识状态。</li><li>替代：脑机接口系统的输出可以取代由于损伤或疾病而丧失的自然输出。</li><li>改善/恢复：主要针对康复领域，改善某种疾病的症状或恢复某种功能。</li><li>增强：主要是针对健康人而言，实现机能的提升和扩展。</li><li>补充：主要针对控制领域，增加脑控方式，作为传统单一控制方法的补充，实现多模态控制。</li></ul><p>围绕上述5 大功效，脑机接口技术的应用方向主要有医疗健康、娱乐、智能家居和其他。</p><ol><li><p>医疗健康</p><p>&emsp;&emsp;医疗健康领域是脑机接口最初、最直接和最主要的应用领域，也是目前最接近商业化的应用领域。医疗健康领域的应用案例主要集在“监测”、“改善/恢复”、“替代”、和“增强”4 大功效上，这些主要是以输出为主狭义BCI 的功效。</p><p>&emsp;&emsp;“监测”是指通过脑机接口系统完成对<strong>人体神经系统状态的实时监控与测量</strong>。例如，脑机接口可应用于陷入深度昏迷等微小意识状态的患者，帮助测量并评定其意识等级。</p><p>&emsp;&emsp;“改善/恢复”方向主要是指可以<strong>针对中风、癫痫等疾病做对应的恢复训练</strong>。例如，对于感觉运动皮层相关部位受损的中风病人，脑机接口可以从受损的皮层区采集信号，然后刺激失能肌肉或控制矫形器，改善手臂运动。癫痫病人的大脑会出现某个区域的神经元异常放电，通过脑机接口技术检测到神经元异常放电后，可以对大脑进行相应的电刺激，从而抑制癫痫发作。</p><p>&emsp;&emsp;“替代”方向主要针对因为损伤或疾病而丧失某种功能的患者。例如，丧失说话能力的人<strong>通过脑机接口输出文字</strong>，或通过语音合成器发声。脊髓侧索硬化症患者、重症肌无力患者、以及因事故导致高位截瘫的患者等重度运动障碍患者群体，可通过脑机接口系统将自己脑中所想的信息传达出来。</p><p>&emsp;&emsp;“增强”方向主要是指将芯片植入大脑，以增强记忆、推动人脑和计算设备的直接连接等</p></li><li><p>娱乐</p><p>&emsp;&emsp;脑机接口在娱乐领域的应用主要集中在“补充”方向。例如，脑机接口为游戏玩家提供了<strong>独立于传统游戏控制方式之外的新的操作维度</strong>，可以用意念来控制虚拟现实界面的菜单导航和选项控制，极大的丰富了游戏内涵并提升了游戏体验。</p></li><li><p>智能家居</p><p>&emsp;&emsp;脑机接口在智能家居领域的应用主要集中在“补充”方向。智能家居是脑机接口与物联网跨领域结合的一大想象空间。例如，脑机接口可类似于“遥控器”，帮助人们用<strong>意念控制</strong>开关灯、开关门和开关窗帘等，进一步可以控制家庭服务机器人。</p></li><li><p>其他</p><p>&emsp;&emsp;脑机接口在其他方向的应用主要针对健康人群的“增强”和“补充”，实现机能的扩展。例如，澳大利亚的SmartCap 公司通过在棒球帽内植入电极，可以实时<strong>监测用户的疲劳状态</strong>，同时也有部分公司将脑机接口应用于驾驶状态监测，随时关注驾驶员的疲劳状态，以降低由于疲劳驾驶而发生事故的概率。在教育领域，脑机接口技术可对学生<strong>注意力表现实时探测</strong>，从而帮助教师及时了解课堂情况以改变教学方法。</p></li></ol><h2 id="非侵入式脑机接口应用案例"><a href="#非侵入式脑机接口应用案例" class="headerlink" title="非侵入式脑机接口应用案例"></a>非侵入式脑机接口应用案例</h2><h3 id="医疗健康"><a href="#医疗健康" class="headerlink" title="医疗健康"></a>医疗健康</h3><h4 id="假肢控制"><a href="#假肢控制" class="headerlink" title="假肢控制"></a>假肢控制</h4><p>&emsp;&emsp;BrainCo公司研发的BrainRobotics智能仿生手，可以通过手臂上肌肉神经信号，识别佩戴者的运动意图，再将运动意图转化成相应的运动指令，从而完成佩戴者想要完成的动作。BrainRobotics已经实现握手、抓杯子等日常操作，并且已有残疾患者通过练习实现了写毛笔字、弹钢琴等更为复杂的操作。<img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/brainRobotics-20210801124717626.gif"></p><center>图6    BrainRobotic智能仿生手</center><h4 id="康复训练"><a href="#康复训练" class="headerlink" title="康复训练"></a>康复训练</h4><p>&emsp;&emsp;专注于虚拟显示和运动捕捉的MindMaze公司，将自身技术与脑机接口结合发布了一款用于医疗商业领域的VR头显，用于中风后运动麻痹的病人恢复，并且已获得美国食品和药物管理局（FDA）批准，进入美国市场。</p><p>&emsp;&emsp;如果中风病人的左手不能动了，但右手能动，相机就会捕捉他右手的动作，然后当他试图控制左手时，会把右手的动作移植到虚拟化身的左手上，让病人观看虚拟化身的左手在动，从而欺骗病人的大脑，让大脑相信自己的左手也能动，从而提高神经的可塑性。所以，当脑机接口检测到用户的运动意图后，通过动作捕捉技术和VR技术，我们可以欺骗大脑，加速病人恢复。这就是这款VR头显中风恢复理疗的原理。<img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/1bc81b64fac44d728370584a0e97a6cb_th-20210801092700836-20210801124751087.jpg"></p><center>图7    中风恢复治疗</center><h4 id="睡眠监测"><a href="#睡眠监测" class="headerlink" title="睡眠监测"></a>睡眠监测</h4><p>&emsp;&emsp;国外InteraXon公司和国内的脑陆科技都推出了消费级的睡眠监测可穿戴EEG设备，通过分析脑电、心率、血氧和体动等睡眠过程中的重要指标，融合多模态生物信号，为用户提供精准的睡眠管理方案。展示量化的睡眠日报、周报、月报，可以随时掌握自身睡眠状态。特别是脑陆科技推出的脑电仪设备，能够将用户的睡眠脑电进行分期，分为清醒期、浅睡期、中度睡眠期、深度睡眠期和快速眼动期。采集的数据可供专业医生诊断提供参考，并且可以为后续通过粉噪音、白噪音等节律声波对神经实时调控，优化深度睡眠的应用场景提供可靠调控指标。</p><h4 id="信息表达"><a href="#信息表达" class="headerlink" title="信息表达"></a>信息表达</h4><p>&emsp;&emsp;脑机接口的一个重要应用领域是意念打字，自从1988年Farewell和Donchin提出的第一款脑机接口字符输入系统——P300 Speller开始，基于BCI的字符输入系统一直在发展迭代。目前，世界上字符输入速度最快的非侵入式BCI Speller是国内博睿康公司和清华大学合作开发的基于SSVEP的字符输入系统，该系统能够在一分钟类输入12个英文单词。该系统还处于实验室阶段，在此研究基础之上，北京邮电大学将中文双拼输入法与SSVEP字符输入系统结合，构建了基于SSVEP的中文字符输入系统。该系统目前正在产业化过程中。</p><p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/SSVEPspeller.gif" alt="SSVEPspeller-20210801124833980"></p><center>图8    清华大学基于SSVEP的字符输入系统</center><h3 id="娱乐"><a href="#娱乐" class="headerlink" title="娱乐"></a>娱乐</h3><h4 id="面部情绪识别"><a href="#面部情绪识别" class="headerlink" title="面部情绪识别"></a>面部情绪识别</h4><p>&emsp;&emsp;位于瑞士洛桑的MindMaze公司展示了一种在VR中读取脸部情绪的设备，名为MASK。戴上集成MASK的头显后，你马上可以看到屏幕上的虚拟化身在模仿你的表情。产品的电极被安装在泡沫衬垫面板上，而这些电极可以感觉到你的面部肌肉，甚至可以在完全作出表情之前进行预测。该设备目前可以追踪的情绪有限，包括微笑、皱眉、眨眼、嘲笑和扬眉。</p><p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/b4b4cc6c-5ddf-4a6d-88ff-47e213f3b8f0-7499262-20210801124925673.jpg"></p><center>图9    VR中的表情识别</center><h3 id="智能家居"><a href="#智能家居" class="headerlink" title="智能家居"></a>智能家居</h3><p>&emsp;&emsp;广州华南脑控公司针对手脚及身体不便人群,打造了一套脑机智能护理应用系统。该系统能够让用户随时掌握护理床各活动部件的升降开关，实现自主控制起坐、抬腿、屈腿、翻身、便盘等。结合护理场景下的智能电器设备，对所在房间空调、窗帘、电视等家居设备进行控制<img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/IMG_1718-20210801125008237.JPG"></p><center>图10    基于BCI的智慧床控制</center>                                                        <h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="注意力实时检测"><a href="#注意力实时检测" class="headerlink" title="注意力实时检测"></a>注意力实时检测</h4><p>&emsp;&emsp;在注意力监测方面，BrainCo公司开发的一款Focus1注意力检测头环，可以实时显示佩戴者的当前的注意水平。该产品可用于教育领域，对于学生上课专注的评估，便于教师根据学生对于课堂的接收情况来作出课程的调整。同时也能够通过实时注意力评估值，进行一些注意力集中的调控行为如冥想，帮助学生调整状态以进入最佳的状态，更好的进行课程学习。目前该产品已经销售往15个国家，近15000名学生使用。<img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/image-20210723152007427-20210801124941112-20210801125050909.png"></p><center>图11    BrainCo公司注意力监测头环</center><p>&emsp;&emsp;系统主要用于课堂上使用，分为课前、课中、课后以及常态训练四个阶段。上课之前老师给学生发放头环，打开 Focus EDU 系统，连接网络；然后依次进行不超过三分钟的冥想训练和神经反馈训练，之后进行正常课堂授课，课堂结束后取下头环。老师可以通过BrainCo提供的教育训练平台查看学生一周内的平均专注力报告，来及时作出课程的调整。</p><h4 id="疲劳状况监测"><a href="#疲劳状况监测" class="headerlink" title="疲劳状况监测"></a>疲劳状况监测</h4><p>&emsp;&emsp;脑陆科技提出的BCI智慧安全帽，是一款在传统安全帽或智能安全帽上集成脑机接口的新型智能终端设备。在完成安全防护的同时，对人的精神不安全状况和生理状况进行监测，实时进行安全预警，提升安全管理技术手段。</p><p>&emsp;&emsp;该设备中集成了EEG（脑电图）和fNRIS（功能性性近红外光谱）信号采集传感器，能够对佩戴的疲劳状况、注意力状况、脑血氧、心率和血压进行监测。可以对佩戴者的疲劳和注意力不集中情况进行报警，同时针对使用者缺氧、供血不足、脉搏紊乱和中毒等威胁生命的突发状况进行通报，通过GPS定位来确定佩戴者方位进行及时的抢救措施，保证工作人员施工过程中的生命安全。<img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/image-20210723154806314-20210801125127878.png"></p><center>图12    脑陆科技BCI智慧安全帽的结构功能图</center><h2 id="非侵入式脑机接口成熟技术"><a href="#非侵入式脑机接口成熟技术" class="headerlink" title="非侵入式脑机接口成熟技术"></a>非侵入式脑机接口成熟技术</h2><h3 id="基于脑电的生理情况监测"><a href="#基于脑电的生理情况监测" class="headerlink" title="基于脑电的生理情况监测"></a>基于脑电的生理情况监测</h3><h4 id="睡眠评估"><a href="#睡眠评估" class="headerlink" title="睡眠评估"></a>睡眠评估</h4><p>&emsp;&emsp;可穿戴睡眠监测设备最常使用的信号是脑电图 (EEG) 和光电容积脉搏波 (PPG)。相比与PPG基于 EEG 的系统是最准确的，并且能够识别所有睡眠阶段。 基于EEG的睡眠分期系统能够<strong>实现 80-90% 之间的分类准确率</strong>。目前，多通道信号对于睡眠评估具有优势，但单通道脑电图睡眠分期也取得了很好的性能（针对所有睡眠阶段分期准确率最高可达到86.2%）。单通道EEG设备便于佩戴且成本相对较低，容易普及，<strong>能够满足家庭睡眠评估，用于早期诊断和持续监测</strong>。</p><h4 id="注意力监测"><a href="#注意力监测" class="headerlink" title="注意力监测"></a>注意力监测</h4><p>&emsp;&emsp;大脑的神经振荡是指中枢神经系统自发产生的有节奏的脑电活动，有alpha, theta, delta, gamma等。其中的 alpha和 theta 波段活动与情绪和注意力状态有关。在注意力方面，脑电信号的alpha波段功率与其呈正相关，而脑电信号的θ波段功率同时呈负相关。目前，在研究中使用多通道采集设备结合机器学习算法对注意力的分类准确率达到91.72%。但具有注意力监测功能的产品都是单通道，单通道设备注意力监测的分类准确率平均在80%左右。并且注意力监测的准确率会因使用者不同任务情景（如阅读，听讲，计算），而存在10%左右的波动。</p><h4 id="疲劳程度监"><a href="#疲劳程度监" class="headerlink" title="疲劳程度监"></a>疲劳程度监</h4><p>&emsp;&emsp;根据人在昏昏欲睡时α波和β波减少，而θ波保持不变这一生理特征，可通过监测 EEG 频带的功率谱的变化来检测受试者的困倦情况。目前拥有困倦程度的监测设备很多，Emotiv公司的Epoc、Neurosky的MindWave、OpenBCI 和 InteraXon公司的Muse产品都具有困倦疲劳监测功能。2020年Jones 和 Minh Dong Le写了一篇简短的文章，回顾了几种低成本 EEG 设备及其检测睡意的能力。其中MindWave设备的监测准确度波动最大，波动最小的设备为OpenBCI，<strong>平均准确率为79.4%<strong>。尽管这些系统没有达到研究级或医疗级系统的准确度，但它们</strong>足以部署在某些环境中</strong>。例如，这些系统可以用于发展中国家的小型企业或迫切需要易于获得的困倦检测的劳务派遣公司等。2016年，Wilaiprasitporn 和 Yagi提出了将 EEG 的睡意检测系统集成到防护或职业头盔中的想法。国内的脑陆科技公司根据这一思路实现了一款BCI智慧安全帽，除了加入EEG监测技术外还增加了对佩戴者头部血氧浓度的监测，能够进行疲劳、中毒、缺氧和供血不足等特殊生理状况监控预警。</p><h3 id="基于BCI的外设交互"><a href="#基于BCI的外设交互" class="headerlink" title="基于BCI的外设交互"></a>基于BCI的外设交互</h3><h4 id="基于BCI的字符输入系统"><a href="#基于BCI的字符输入系统" class="headerlink" title="基于BCI的字符输入系统"></a>基于BCI的字符输入系统</h4><p>&emsp;&emsp;非侵入式字符输入系统一直是BCI领域的研究重点。从字符分布界面的设计到采用的刺激范式一些系列的优化与提高，到目前为止基于非侵入式字符输入系统的输入速率还远远达不到正常人的平均水平，仅仅为每分钟40字符（准确率达到91.5%），而正常人的水平为115个字符。因此基于该技术的系统大多还处于实验室阶段或者实验室到商业产品的转换阶段。目前基于BCI技术的字符输入系统中最接近人类输入速度的斯坦福教授Krishna Shenoy发表于《Nature》上的基于侵入式BCI的笔记想象字符输入系统，该系统能够达到每分钟输入90个字符，并且识别准确率高达99%。该系统的速度与在智能手机上打字的速度相当，是BCI字符输入系统领域的重大突破。目前影响该技术应用的是目前侵入式BCI技术还不够成熟，芯片植入后的风险以及后续的维护更换都是待解决的问题。<img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/8db6-kpzzqmz7958767-20210801125225097.gif"></p><center>图13    基于笔记想象的侵入式BCI字符输入系统</center><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;BCI技术最重要的应用是医疗领域，而目前医疗领域非侵入BCI最成熟的技术之一是基于EEG信号生理信息监测，睡眠监测、疲劳状况监测、注意力监测等。在从科研和医疗领域向大众市场的下放的过程中，考虑到便携性、可穿戴性和成本等多方因素，相关设备都牺牲了多通道信号源，采用单通道信号来进行后续一些应用场景分析。这使得产品的准确性和鲁棒性与研究和医疗领域有所差距，但是已经能够用于日常的使用。这类产品面临广泛的使用人群，相比于科研和医疗领域的相对单一可控的使用环境，面临复杂多变环境下的可靠性是产品体验的重要环节。目前由于产品推出不久，还没有广泛的使用人群并形成可靠权威的产品体验报告。</p><p>&emsp;&emsp;作为BCI技术诞生不久后，一直研究的字符输入系统，技术相对成熟，2018清华大学提出的SSVEP字符输入系统每分钟可以输入40个字符，但是目前迟迟没有产品推出，主要还是基于SSVEP的系统对于字符输入这种长时间的任务，不同频率的闪烁刺激方式容易产生疲劳，整体体验还有待优化。而针对BCI的智慧家居、假肢的控制以及基于虚拟现实的康复训练，目前只有极少的公司有产品化。</p><p>&emsp;&emsp;从产品的成熟度来看，脑机接口技术处于初级阶段，未来尚需更加完善的制度和标准来规范产品上市进程，对产品的安全性、有效性进行合理全面的认证。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><p>Current and Future Brain-Computer Interface，Christoph Guger，g.tech medical engineering (2021).</p></li><li><p>Imtiaz, Syed Anas. “A Systematic Review of Sensing Technologies for Wearable Sleep Staging.” Sensors 21.5 (2021): 1562.</p></li><li><p>Yang, Chen, et al. “A dynamic window recognition algorithm for SSVEP-based brain–computer interfaces using a spatio-temporal equalizer.” International journal of neural systems 28.10 (2018): 1850028.</p></li><li><p>LaRocco, John, Minh Dong Le, and Dong-Guk Paeng. “A systemic review of available low-cost EEG headsets used for drowsiness detection.” Frontiers in neuroinformatics 14 (2020).</p></li><li><p>Mohammadpour, Mostafa, and Saeed Mozaffari. “Classification of EEG-based attention for brain computer interface.” 2017 3rd Iranian Conference on Intelligent Systems and Signal Processing (ICSPIS). IEEE, 2017.</p></li><li><p>Wang, Bingbing, et al. “EEG-Based Closed-Loop Neurofeedback for Attention Monitoring and Training in Young Adults.” Journal of Healthcare Engineering 2021 (2021).</p></li><li><p>Willett, Francis R., et al. “High-performance brain-to-text communication via handwriting.” Nature 593.7858 (2021): 249-254.</p></li><li><p>伏云发,郭衍龙, 张夏冰, 李松. 脑-机接口—革命性的人机交互[译]. 北京:国防工业出版社, 2020.</p></li><li><p>伏云发,丁鹏,罗建功,吕晓彤.脑-计算机接口[译]. 国防工业出版社,北京,2021.</p></li><li><p>李静雯, 王秀梅. 脑机接口技术在医疗领域的应用[J]. 信息通信技术与政策, 2021,47(2):87-91.</p></li><li><p><a href="http://lib.ia.ac.cn/documents/17475/0/%E8%84%91%E6%9C%BA%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%9C%A8%E5%8C%BB%E7%96%97%E5%81%A5%E5%BA%B7%E9%A2%86%E5%9F%9F%E5%BA%94%E7%94%A8%E7%99%BD%E7%9A%AE%E4%B9%A6%EF%BC%882021%EF%BC%89.pdf">脑机接口技术在医疗健康领域应用白皮书</a>. 中国人工智能产业发展联盟”,2021.</p></li><li><p><a href="https://zhuanlan.zhihu.com/p/28584797">意念打字、心灵控制、大脑永生…这不是科幻大片，这是过去一年「脑机接口」领域的重磅突破！</a></p></li><li><p><a href="https://space.bilibili.com/1262597880/video?tid=0&page=1&keyword=&order=pubdate">g.tec 脑电产品中国区总代理</a></p></li></ol><p>  ​    </p><p>  ​    </p>]]></content>
      
      
      <categories>
          
          <category> 脑机接口 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 非侵入式BCI </tag>
            
            <tag> BCI应用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>宅在家系列Tips——煮挂面</title>
      <link href="/2021/07/31/Zoella-Cooking%E7%AC%94%E8%AE%B0%E4%B9%8B%E2%80%94%E2%80%94%E7%AE%80%E9%A4%90%E6%8C%82%E9%9D%A2/"/>
      <url>/2021/07/31/Zoella-Cooking%E7%AC%94%E8%AE%B0%E4%B9%8B%E2%80%94%E2%80%94%E7%AE%80%E9%A4%90%E6%8C%82%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<p>作为在广东的一个西北人，已经快一年没有吃过面了。这边的面无法接受，所以还是自己动手煮挂面吧。</p><h3 id="挂面选择"><a href="#挂面选择" class="headerlink" title="挂面选择"></a>挂面选择</h3><p><code>首先</code>是挂面的选择。</p><p>不同的挂面吸水性不同，容易吸水的后面需要加水和盐。<img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/different_noodle.jpg"></p><p>面，中火不盖锅盖煮<strong>五分钟</strong>即可。</p><h3 id="挂面调料"><a href="#挂面调料" class="headerlink" title="挂面调料"></a>挂面调料</h3><p><code>接着</code>主戏——挂面调料：</p><ol><li>两勺生抽</li><li>一勺四川熟油辣子</li><li> 半勺或一勺醋</li><li>一勺花椒油</li><li>加盐</li><li>一小块猪油</li></ol><p>以上调制完成，加入煮面的水，根据咸淡，添加水或盐。</p><p><code>然后</code>，煮五分钟的面，捞入调制好的汤中，加入葱花。</p><p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/noodles.jpg"></p><p><code>最后</code>，开始享用喽～</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><iframe width="950" height="534" src="https://www.youtube.com/embed/TBLF9oBab9k" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>]]></content>
      
      
      <categories>
          
          <category> 简餐 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 挂面 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>国防科技大学周宗潭教授——“基于机器人操作系统（ROS）的脑机接口实现”</title>
      <link href="/2021/01/03/%E5%9B%BD%E9%98%B2%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E5%91%A8%E5%AE%97%E6%BD%AD%E6%95%99%E6%8E%88%E2%80%94%E2%80%94%E2%80%9C%E5%9F%BA%E4%BA%8E%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88ROS%EF%BC%89%E7%9A%84%E8%84%91%E6%9C%BA%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E2%80%9D/"/>
      <url>/2021/01/03/%E5%9B%BD%E9%98%B2%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E5%91%A8%E5%AE%97%E6%BD%AD%E6%95%99%E6%8E%88%E2%80%94%E2%80%94%E2%80%9C%E5%9F%BA%E4%BA%8E%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88ROS%EF%BC%89%E7%9A%84%E8%84%91%E6%9C%BA%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E2%80%9D/</url>
      
        <content type="html"><![CDATA[<div class="news_content" id="objId">     <p style="white-space: normal; text-align: justify; line.height: 1.75em;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;">&nbsp; &nbsp; &nbsp; &nbsp;2020年12月19日，第二届智慧医疗与康复大会暨第五届脑机接口论坛在江苏省昆山举行。大会指导单位为中国生物医学工程学会、中国电子学会，由华东理工大学信息科学与工程学院、西安交通大学人工智能学院、智能医学工程教育部工程研究中心、上海脑科学与类脑研究中心等单位主办。国防科技大学周宗潭教授在脑机交互与控制分会场作“基于机器人操作系统（ROS）的脑机接口实现”的学术报告。</span></p><p style="white-space: normal; text-align: center; line.height: 1.75em;"><img src="http://www.scholat.com/resources/p_picture/fwang8_1609566324579/img/word/media/image1.png" width="700" height="207.2378pt" style="width: 700px; height: 406px;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;">&nbsp;<br></span></p><p style="white-space: normal; text-align: center; line.height: 1.75em;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;">图1&nbsp; “基于机器人操作系统（ROS）的脑机接口实现”学术汇报</span></p><p style="white-space: normal; text-align: center; line.height: 1.75em;"><img src="http://www.scholat.com/resources/p_picture/fwang8_1609566324579/img/word/media/image2.png" width="700" height="747" border="0" hspace="0" vspace="0" title="" style="width: 700px; height: 747px;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;">&nbsp;<br></span></p><p style="white-space: normal; text-align: center; line.height: 1.75em;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;">图2&nbsp; 第五届脑机接口论坛——脑机交互与控制大会演讲题目</span></p><p style="white-space: normal; text-indent: 21pt; text-align: justify; line.height: 1.75em;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;">&nbsp;在脑机交互与控制大会上，国防科技大学胡德文教授、清华大学高小榕教授以及复旦大学王守岩教授讲述脑机接口理论科学研究的最新进展和面临的挑战，是为学术研究中的“学”。作为最后一位演讲者，周教授则以学术研究中的“术”为核心，从动机（构建脑机接口综合应用平台）、动手（设计脑机接口机器人操作系统）、动起来（设计集成多技术的康复车）三个方面进行脑机接口实现的报告<span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; Georgia, Georgia, &quot;Times New Roman&quot;, Times, &quot;Microsoft YaHei&quot;, SimSun, SimHei, serif; color: rgb(51, 51, 51);">。</span></span></p><p style="white-space: normal; line.height: 1.75em;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;"><strong>&nbsp;&nbsp;&nbsp;&nbsp;1. 动机——构建脑机接口综合平台</strong></span></p><p style="white-space: normal; text-align: center; line.height: 1.75em;"><img src="http://www.scholat.com/resources/p_picture/fwang8_1609566324579/img/word/media/image3.png" width="700" height="406" border="0" hspace="0" vspace="0" title="" style="width: 700px; height: 406px;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;">&nbsp;<br></span></p><p style="white-space: normal; text-align: center; line.height: 1.75em;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;">图3&nbsp; 脑机接口系统存在的问题</span></p><p style="white-space: normal; text-align: justify; line.height: 1.75em;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;">&nbsp; &nbsp; &nbsp; &nbsp; 针对目前脑机接口系统存在的三个问题：系统集成有限、运行效率低、使用方便性差，周教授构建了一套脑机接口综合应用平台，通过脑电信号控制康复车运动导航和车上集成机械臂抓取物体，实现了残疾人“去想去的地方，做想做的事”的最低要求。该系统将人的判断、决策和规划能力与推荐算法结合，融入脑机接口中以提高系统工作效率，实现了人类智慧与机器智能的融合。同时，对传统BCI系统接触式测量不便的问题，提出以脑磁为代表的非接触式神经活动信号测量的方案。</span></p><p style="white-space: normal; text-align: center; line.height: 1.75em;"><img src="http://www.scholat.com/resources/p_picture/fwang8_1609566324579/img/word/media/image4.png" width="700" height="406" border="0" hspace="0" vspace="0" title="" style="width: 700px; height: 406px;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;">&nbsp;<br></span></p><p style="white-space: normal; text-align: center; line.height: 1.75em;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;">图4&nbsp; 脑控康复车抓取物体</span></p><p style="white-space: normal; line.height: 1.75em;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;"><strong>&nbsp;&nbsp;&nbsp;&nbsp;2. 动手——设计脑机接口机器人操作系统</strong></span></p><p style="white-space: normal; text-align: justify; line.height: 1.75em;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; Georgia, Georgia, &quot;Times New Roman&quot;, Times, &quot;Microsoft YaHei&quot;, SimSun, SimHei, serif;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;脑机接口机器人操作系统（BCIROS）由脑机接口（BCI）软件框架和机器人操作系统（ROS）两个部分构成。在软件框架方面，现有的脑机接口软件框架主要有BCI2000、OpenVibe、Tobi、BCILab和XBCI等，其中行业内使用最多的是BCI2000。BCI2000框架中各个模块间的采用TCP的方式通信，支持跨平台部署，并且可以使用C++、Python等多种程序设计语言进行开发。但其软件框架与应用分离，无法实现BCI系统与其他系统的深度融合，且软件平台封闭，所使用的私有协议使得扩展开发困难。ROS是用于编写机器人软件程序的一种高度灵活性软件架构，它提供了广泛的库文件实现以机动性、操作控制、感知为主的机器人功能。依托强大的社区，ROS提供了一套“一站式”的方法使得用户得以搜索并使用来自全球开发者数以千计的ROS程序包，其中就包括脑机接口相关程序包。ROS中虚拟仿真平台gazebo，能够通过相关的机器人模型和场景建模，与BCI系统连接实现BCI控制仿真实验。&nbsp;&nbsp;</span></p><p style="white-space: normal; text-align: center; line.height: 1.75em;"><img src="http://www.scholat.com/resources/p_picture/fwang8_1609566324579/img/word/media/image5.png" width="700" height="406" border="0" hspace="0" vspace="0" title="" style="width: 700px; height: 406px;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;">&nbsp;<br></span></p><p style="white-space: normal; text-align: center; line.height: 1.75em;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;">图5&nbsp; 脑机接口软件框架</span></p><p style="white-space: normal; text-align: center; line.height: 1.75em;"><img src="http://www.scholat.com/resources/p_picture/fwang8_1609566324579/img/word/media/image6.png" width="700" height="406" border="0" hspace="0" vspace="0" title="" style="width: 700px; height: 406px;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;">&nbsp;<br></span></p><p style="white-space: normal; text-align: center; line.height: 1.75em;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;">图6&nbsp; 机器人操作系统（ROS）</span></p><p style="white-space: normal; text-align: center; line.height: 1.75em;"><img src="http://www.scholat.com/resources/p_picture/fwang8_1609566324579/img/word/media/image7.png" width="700" height="406" border="0" hspace="0" vspace="0" title="" style="width: 700px; height: 406px;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;">&nbsp;<br></span></p><p style="white-space: normal; text-align: center; line.height: 1.75em;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;">图7&nbsp; gazebo对<span class="a a3" style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; Georgia, Georgia, &quot;Times New Roman&quot;, Times, &quot;Microsoft YaHei&quot;, SimSun, SimHei, serif; color: rgb(77, 77, 77);"></span>机器人模型和室内场景建模</span></p><p style="white-space: normal; text-align: justify; line.height: 1.75em;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;">&nbsp; &nbsp; &nbsp; &nbsp; 周教授团队在ROS最小化系统roscore的基础上，开发集成脑电信号源采集、存储、可视化与信号分析模块的BCI软件框架。设计包含主控逻辑和控制状态的切换的有限状态机，用于实现人机交互和机器人控制功能。并通过SSVEP控制ROS中虚拟小乌龟实体的实验，验证了该系统的可行性。</span></p><p style="white-space: normal; text-align: center; line.height: 1.75em;"><img src="http://www.scholat.com/resources/p_picture/fwang8_1609566324579/img/word/media/image8.png" width="700" height="406" border="0" hspace="0" vspace="0" title="" style="width: 700px; height: 406px;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;">&nbsp;<br></span></p><p style="white-space: normal; text-align: center; line.height: 1.75em;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;">图8&nbsp; 脑机接口机器人操作系统架构图</span></p><p style="white-space: normal; text-align: center; line.height: 1.75em;"><img src="http://www.scholat.com/resources/p_picture/fwang8_1609566324579/img/word/media/image9.png" width="700" height="406" border="0" hspace="0" vspace="0" title="" style="width: 700px; height: 406px;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;">&nbsp;<br></span></p><p style="white-space: normal; text-align: center; line.height: 1.75em;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;">图9&nbsp; SSVEP控制ROS系统下的虚拟目标——小乌龟</span></p><p style="white-space: normal; text-align: justify; line.height: 1.75em;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;"><strong>&nbsp;&nbsp;&nbsp;&nbsp;3. 动起来——设计集成多项技术的康复车</strong></span></p><ol class="custom_num1 list-paddingleft-1" style="width: 763.797px; white-space: normal;"><li class="list-num-2-1 list-num1-paddingleft-1"><p style="text-align: justify; line.height: 1.75em;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;">（1）设计小型化脑电采集模块</span></p></li></ol><p style="white-space: normal; text-align: justify; line.height: 1.75em;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;">&nbsp; &nbsp; &nbsp; &nbsp; 周教授基于国产芯片ESP32设计了一套小型化、低成本（200元左右）的脑电信号采集模块，集成便携式脑电信号模块与干式电极帽，实现了“即戴即用”的脑电信号采集。</span></p><ol class="custom_num1 list-paddingleft-1" style="width: 763.797px; white-space: normal;"><li class="list-num-2-1 list-num1-paddingleft-1"><p style="text-align: justify; line.height: 1.75em;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;">（2）实现脑控康复车</span></p></li></ol><p style="white-space: normal; text-align: justify; line.height: 1.75em;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;">&nbsp; &nbsp; &nbsp; &nbsp; 康复车的主要硬件构成是集成全向轮的底盘、机械臂和深度摄像头。软件部分由主控制系统、基于图像点云的视觉感知系统和目标规划和导航系统构成，其中涉及到环境理解（YOLO）、目标定位（Kinect）和用户辅助决策(基于历史信息的贝叶斯推荐系统)等功能。</span></p><p style="white-space: normal; text-align: center; line.height: 1.75em;"><img src="http://www.scholat.com/resources/p_picture/fwang8_1609566324579/img/word/media/image10.png" width="700" height="406" border="0" hspace="0" vspace="0" title="" style="width: 700px; height: 406px;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;">&nbsp;<br></span></p><p style="white-space: normal; text-align: center; line.height: 1.75em;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;">图10&nbsp; 脑控康复车系统构成</span></p><p style="white-space: normal; text-align: center; line.height: 1.75em;"><img src="http://www.scholat.com/resources/p_picture/fwang8_1609566324579/img/word/media/image11.png" width="700" height="406" border="0" hspace="0" vspace="0" title="" style="width: 700px; height: 406px;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;">&nbsp;<br></span></p><p style="white-space: normal; text-align: center; line.height: 1.75em;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;">图11&nbsp; 脑控康复车功能</span></p><ol class="custom_num1 list-paddingleft-1" style="width: 763.797px; white-space: normal;"><li class="list-num-2-1 list-num1-paddingleft-1"><p style="text-align: justify; line.height: 1.75em;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;">（3）康复车实地测试</span></p></li></ol><p style="white-space: normal; text-align: justify; line.height: 1.75em;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;">&nbsp; &nbsp; &nbsp; &nbsp; 康复车在湖南长沙湘雅医院进行了实地测试，选择10个高位截瘫的患者，操控康复车到达指定的位置，使用机械臂完成的喝水动作，实验中，10名患者都能成功地通过康复车完成该任务。</span></p><p style="white-space: normal; text-align: center; line.height: 1.75em;"><img src="http://www.scholat.com/resources/p_picture/fwang8_1609566324579/img/word/media/image12.png" width="700" height="406" border="0" hspace="0" vspace="0" title="" style="width: 700px; height: 406px;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;">&nbsp;<br></span></p><p style="white-space: normal; text-align: center; line.height: 1.75em;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;">图12&nbsp; 高位截瘫患者控制康复车完成喝水任务</span></p><p style="white-space: normal; text-align: justify; line.height: 1.75em;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;">&nbsp; &nbsp; &nbsp; &nbsp; 报告的最后，周教授表示BCI技术与ROS的结合将有助提高残疾人的生活水平，未来更多新技术的集成，将会使得脑机接口机器人操作系统更加完善，并产生更加广阔的应用前景。</span></p><p style="white-space: normal; line.height: 1.75em;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;"><br></span></p><p style="white-space: normal; line.height: 1.75em;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;"><br></span></p><p style="white-space: normal; text-align: justify; line.height: 1.75em;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;"><strong>周宗潭，国防科学技术大学智能科学院教授、博士生导师。主要从事模式识别与智能系统，脑科学与认知科学，脑机接口方面的研究工作。在Brain, NeuroImage, IEEE T. PAMI, JNE等杂志上发表SCI论文30多篇；获得国家发明和国防专利授权6项；参编专著3本，译著1本。在国际脑机接口竞赛和国际视觉竞赛中多次获得优异成绩。获国家自然科学二等奖、教育部自然科学一等奖、省部级科技进步一等奖1项，二等奖2项，入选教育部新世纪人才支持计划。主持和完成国家科学基金重点项目2项、面上项目1项， 973子项目1项，863项目1项。</strong></span></p><p style="white-space: normal;"><br></p><p class="a a7" style="white-space: normal;"><br></p><p style="white-space: normal; padding: 0px; line.height: 1.75em;"><span style="padding: 0px; font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;">撰稿人：lifeisbinary</span></p><p style="white-space: normal; padding: 0px; line.height: 1.75em;"><span style="padding: 0px; font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;"><br></span></p><p style="white-space: normal; padding: 0px; line.height: 1.75em;"><span style="padding: 0px; font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;"><br></span></p><p style="white-space: normal; padding: 0px; line.height: 1.75em;"><span style="color: rgb(51, 51, 51); text-indent: 32px; padding: 0px; font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;">参考链接：</span></p><p style="white-space: normal; padding: 0px; line.height: 1.75em;"><span style="color: rgb(51, 51, 51); text-indent: 32px; padding: 0px; font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;">1.&nbsp;&nbsp;<a href="http://daxue.cn-healthcare.com/detail/2019" _src="http://daxue.cn-healthcare.com/detail/2019" target="_blank">http://daxue.cn-healthcare.com/detail/2019</a></span></p><p style="white-space: normal; padding: 0px; line.height: 1.75em;"><span style="padding: 0px; font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;">2.&nbsp;<a href="https://baike.baidu.com/item/ros/4710560" _src="https://baike.baidu.com/item/ros/4710560" target="_blank">https://baike.baidu.com/item/ros/4710560</a></span></p><p style="line.height: 1.75em;"><span style="font-family:'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif;'Georgia', Georgia, 'Times New Roman', Times, 'Microsoft YaHei', SimSun, SimHei, serif; 微软雅黑, &quot;Microsoft YaHei&quot;;"><br></span></p> </div>]]></content>
      
      
      <categories>
          
          <category> 脑机接口 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BCI </tag>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机试——字符串、排序与查找</title>
      <link href="/2020/03/29/%E6%9C%BA%E8%AF%95%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E5%8A%9F/"/>
      <url>/2020/03/29/%E6%9C%BA%E8%AF%95%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E5%8A%9F/</url>
      
        <content type="html"><![CDATA[<h4 id="C-中字符串"><a href="#C-中字符串" class="headerlink" title="C++中字符串"></a>C++中字符串</h4><ol><li><p>string 的基本使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;isotream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string str,str1 = <span class="string">&#x27;OK&#x27;</span>; <span class="comment">/*定义string类型变量*/</span></span><br><span class="line">    cin&gt;&gt;str;  <span class="comment">//输入</span></span><br><span class="line">    str.<span class="built_in">size</span>() <span class="comment">// string类型变量长度</span></span><br><span class="line">    cout&lt;&lt;str&lt;&lt;endl;   <span class="comment">//输出</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;str.<span class="built_in">size</span>(); i++)&#123;   <span class="comment">//像数组一样访问元素</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,str[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    str.<span class="built_in">insert</span>(str.<span class="built_in">size</span>(),<span class="string">&quot;...&quot;</span>);  <span class="comment">//从当前下标开始插入   </span></span><br><span class="line">    str.<span class="built_in">erase</span>(<span class="number">0</span>,<span class="number">5</span>); <span class="comment">//删除下标从0～5的元素 </span></span><br><span class="line">    str.<span class="built_in">erase</span>(<span class="number">2</span>);</span><br><span class="line">    str.<span class="built_in">clear</span>(); <span class="comment">//str置空</span></span><br><span class="line"></span><br><span class="line">    str = str + <span class="string">&#x27;hello&#x27;</span>; <span class="comment">//字符串连接</span></span><br><span class="line">    str = str + str1;</span><br><span class="line">    str.<span class="built_in">find</span>(<span class="string">&quot;ok&quot;</span>); <span class="comment">// 在字符串中查找字符串或者字符 如果找不到返回 string::npos</span></span><br><span class="line">    str.<span class="built_in">sbustr</span>(<span class="number">2</span>,<span class="number">4</span>); <span class="comment">//返回str中下标从2开始的四个字符组成的子串</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>对于需要获取一行的字符串（含空格），需要使用getline</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string str;</span><br><span class="line"><span class="built_in">getline</span>(cin,str);</span><br></pre></td></tr></table></figure></li></ol><p>例子：</p><p>在情报传递过程中，为了防止情报被截获，往往需要对情报用一定的方式加密，简单的加密算法虽然不足以完全避免情报被破译，但仍然能防止情报被轻易的识别。我们给出一种最简的的加密方法，对给定的一个字符串，把其中从a-y,A-Y的字母用其后继字母替代，把z和Z用a和A替代，则可得到一个简单的加密字符串。</p><p>输入一行字符串，输出对该字符串加密的结果</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">incode</span><span class="params">(string str)</span></span>&#123;</span><br><span class="line">    string incodeStr;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>( (<span class="string">&#x27;a&#x27;</span>&lt;=str[i]  &amp;&amp; str[i]&lt;=<span class="string">&#x27;y&#x27;</span>) || (<span class="string">&#x27;A&#x27;</span>&lt;=str[i]  &amp;&amp; str[i]&lt;=<span class="string">&#x27;Y&#x27;</span>) )&#123;</span><br><span class="line">            incodeStr += str[i]+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (str[i] == <span class="string">&#x27;z&#x27;</span> || str[i] == <span class="string">&#x27;Z&#x27;</span>)&#123;</span><br><span class="line">            incodeStr += str[i]<span class="number">-25</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            incodeStr += str[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> incodeStr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(cin,str))&#123;</span><br><span class="line">        cout&lt;&lt;<span class="built_in">incode</span>(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><ol><li>c++内部基于快速排序的函数——sort<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sort</span>(first,last,comp); <span class="comment">// first,last 起始地址、结束地址， 排序方式定义的函数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>如果sort中的 比较函数comp 返回 true, 则排序时会将比较函数comp的第一个参数置于第二个参数前。<br>例子： 用一位数组存储学生的学号和成绩，然后按成绩排序输出</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">Student arr[MAXN];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Compare</span><span class="params">(Student a, Student b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.score == b.score)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.number &lt; b.number;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.score &lt; b.score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;arr[i].number,&amp;arr[i].score);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(arr,arr+n,Compare);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,arr[j].number,arr[j].score);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><p>机试中最常见的查找是二分查找<br>二分查找的前提是有序，二分查找的思想是： 对于当前要查找的数，与有序序列中中间位置的数与之做比较：</p><p> a. 如果大于要查找的数，则从小于中间位置的序列中再使用该方法查找。</p><p> b. 如果小于要查找的数，则从大于中间位置的序列中再使用该方法查找。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在长度位n的有序数组arr中查找x,返回查找到的下标</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch</span><span class="params">(<span class="keyword">int</span> arr,<span class="keyword">int</span> n,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">        <span class="keyword">int</span> middle = (low+high)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(arr[middle] == x)&#123;</span><br><span class="line">            <span class="keyword">return</span> middle;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[middle] &lt; x)</span><br><span class="line">            low = middle + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            high = middle - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 机试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 研究生复试上机题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机试--数学问题</title>
      <link href="/2020/03/29/%E6%9C%BA%E8%AF%95-%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98/"/>
      <url>/2020/03/29/%E6%9C%BA%E8%AF%95-%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>机试中，有一些与数字相关的题目： 进制转换、最大公约数、最小公倍数、素数、高进度整整数运算（无法用数值类型变量直接存储）。本文对于这几个部分的一些常见题，进行归纳总结。</p><span id="more"></span><h3 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h3><ol><li>整数二进制方式显示 [北邮上机题]</li></ol><blockquote><p>十进制转二进制，使用除留取余法，注意余数的先后顺序与该数二进制顺序相反，因此将余数按顺序存放，逆序输出即可</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span>   <span class="comment">//容器，可变长度的&quot;数组&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bit</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; NumBit;</span><br><span class="line">    <span class="keyword">int</span> BitNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(num != <span class="number">0</span>)&#123;</span><br><span class="line">        NumBit.<span class="built_in">push_back</span>(num % <span class="number">2</span>);</span><br><span class="line">        num /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = NumBit.<span class="built_in">size</span>()<span class="number">-1</span>; i &gt;= <span class="number">0</span> ; i--) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,NumBit[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    string s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num);</span><br><span class="line">        <span class="built_in">Bit</span>(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>大型正整数二进制显示 [清华上机题]</li></ol><blockquote><p>在C与C++中较大的整数无法存储进行直接的算数运算。因此，对于大数的处理一般需要使用字符串的方法。本题与上一题有相似之处，只是本题的数据无法存储，因此无法进行算术的除、取余操作。可以通过定义字符串的方式，实现字符串数字的除法、取余。进而套用上一题的方法。</p></blockquote><blockquote><p>对于字符串的：</p><ol><li>取余操作： 只需取当前字符串的最后一位做算术的取余操作，其结果即是整个字符串数的取余结果。</li><li>除法操作： 与我们平时在草稿纸上算的步骤一样，依次从高到低对字符串数的每个元素进行：<br> 除2 、 取余操作。 即可得到该字符串数除2的结果字符串。<strong>该过程中注意：取余的目的是为了，在下次除操作前，将上一位的余数与当前为合并作为被除数。 对于除完后的结果中可能前几位是0，需要去掉多余的0，方便除留取余法推出循环。</strong></li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">string <span class="title">divide</span><span class="params">(string num, <span class="keyword">int</span> divider)</span></span>&#123;  <span class="comment">//字符串除法</span></span><br><span class="line">    string answer; <span class="comment">//商</span></span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>; <span class="comment">//上一位的余数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;num.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> dividend = num[i]-<span class="string">&#x27;0&#x27;</span> + carry*<span class="number">10</span> ;</span><br><span class="line">        answer += (<span class="string">&#x27;0&#x27;</span> + dividend / divider);   </span><br><span class="line">        carry = dividend % divider; <span class="comment">//取余</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> post = <span class="number">0</span>; <span class="comment">//标示answer中不为0的第一个数字字符【重要】</span></span><br><span class="line">    <span class="keyword">while</span> (answer[post] == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">        post++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> answer.<span class="built_in">substr</span>(post);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printBit</span><span class="params">(string sNum)</span></span>&#123; <span class="comment">//十进制转二进制</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; NumBit;</span><br><span class="line">    <span class="keyword">while</span>(sNum.<span class="built_in">size</span>() != <span class="number">0</span>)&#123;</span><br><span class="line">        NumBit.<span class="built_in">push_back</span>((sNum[sNum.<span class="built_in">size</span>()<span class="number">-1</span>]-<span class="string">&#x27;0&#x27;</span>) % <span class="number">2</span>);</span><br><span class="line">        sNum = <span class="built_in">divide</span>(sNum,<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=NumBit.<span class="built_in">size</span>()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,NumBit[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string sNum;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; sNum)&#123;</span><br><span class="line">        <span class="built_in">printBit</span>(sNum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>求一个十进制数的逆序数。[清华机上机题]<blockquote><p>逆序数：对于一个十进制数A，将A转换为二进制数，然后按位逆序排列，再转换为十进制数B，我们称B为A的二进制逆序数。例如对于十进制数173，它的二进制形式为10101101，逆序排列得到10110101，其十进制数为181，181即为173的二进制逆序数。</p></blockquote></li></ol><blockquote><p>本题与上一题，有一定的联系。将大数的十进制（字符串形式）转换为二进制【上题内容】，接下来需要：将得到的二进制转换成新的大数的十进制（字符串形式）。</p><p>转换过程中涉及到： 字符串数与一位整数的 加法 和 乘法</p><ol><li>加法： 将加数作为低位的进位，从<strong>后向前</strong>遍历字符串数的每一个位： 当前位与进位相加，对10取余为求加法结果，对10取模为当前位加法向上一位的进位。<strong>注意即使进位为0，也要继续遍历高位，进行求和操作。否则结果会丢失高位信息。</strong>。如果加法遍历完后，最高位有进位需要给结果修正：最高位补1。</li><li>乘法： 对于被乘数进行从后向前遍历：当前位乘上乘数并加上后一位的进位，对10取余为乘法结果，对10取模为进位。如果最高位有进位，结果和加法一样需要类似的修正。</li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">divide</span><span class="params">(string sNum,<span class="keyword">int</span> divider)</span></span>&#123;   <span class="comment">//字符串除法</span></span><br><span class="line">    string answer; <span class="comment">//最后除的结果--商</span></span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>; <span class="comment">//上一位的余数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;sNum.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> dividend = (sNum[i]-<span class="string">&#x27;0&#x27;</span>) + carry*<span class="number">10</span>; <span class="comment">//当前位的被除数</span></span><br><span class="line">        answer += (<span class="string">&#x27;0&#x27;</span>+ (dividend / divider)); <span class="comment">//当前位的商</span></span><br><span class="line">        carry = dividend % <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> post = <span class="number">0</span>; <span class="comment">//商字符串中不为0的第一字符位置</span></span><br><span class="line">    <span class="keyword">while</span>(answer[post] == <span class="string">&#x27;0&#x27;</span>)&#123;    <span class="comment">//去除结果中前面多余的0</span></span><br><span class="line">        post++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> answer.<span class="built_in">substr</span>(post);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">multiple</span><span class="params">(string sNum,<span class="keyword">int</span> factor)</span></span>&#123;  <span class="comment">//字符串乘法</span></span><br><span class="line">    string answer;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=sNum.<span class="built_in">size</span>()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = (sNum[i]-<span class="string">&#x27;0&#x27;</span>)  * factor + carry;</span><br><span class="line">        answer = <span class="built_in"><span class="keyword">char</span></span>(<span class="string">&#x27;0&#x27;</span>+(temp % <span class="number">10</span>)) + answer;   <span class="comment">//从低位到高位分别乘二得到结果</span></span><br><span class="line">        carry = temp / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(carry == <span class="number">1</span>)&#123;     <span class="comment">//因为乘的是2，所以进位只能是1</span></span><br><span class="line">        answer = <span class="string">&#x27;1&#x27;</span> + answer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">add</span><span class="params">(string sNum, <span class="keyword">int</span> adder)</span></span>&#123;</span><br><span class="line">    string answer;</span><br><span class="line">    <span class="keyword">int</span> carry = adder;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=sNum.<span class="built_in">size</span>()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = sNum[i]-<span class="string">&#x27;0&#x27;</span> + carry; <span class="comment">//把要加的一位整数（0或1）当成当前位后一位的进位</span></span><br><span class="line">        carry = temp / <span class="number">10</span>;</span><br><span class="line">        answer = <span class="built_in"><span class="keyword">char</span></span>(<span class="string">&#x27;0&#x27;</span> +temp%<span class="number">10</span>) + answer ;  <span class="comment">//需要进行类型转换，否则无法将int型并入字符串</span></span><br><span class="line">        <span class="comment">//if(carry == 0) 没有进位，加法依然要继续，否则丢失高位值</span></span><br><span class="line">        <span class="comment">//    break;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(carry == <span class="number">1</span>)&#123; <span class="comment">//最高位有进位</span></span><br><span class="line">        answer = <span class="string">&quot;1&quot;</span> + answer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printInvertBinNum</span><span class="params">(string sNum)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//十进制字符串 转 二进制</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; InvertBinary;</span><br><span class="line">    <span class="keyword">while</span>(sNum.<span class="built_in">size</span>() != <span class="number">0</span>)&#123;</span><br><span class="line">        InvertBinary.<span class="built_in">push_back</span>( (sNum[sNum.<span class="built_in">size</span>()<span class="number">-1</span>]-<span class="string">&#x27;0&#x27;</span>) % <span class="number">2</span> ); <span class="comment">//取余</span></span><br><span class="line">        sNum = <span class="built_in">divide</span>(sNum,<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//二进制 转 十进制字符串</span></span><br><span class="line">    string answer = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;InvertBinary.<span class="built_in">size</span>(); i++)&#123;  <span class="comment">//对于求二进制逆序数来说： InvertBinary中保存的是逆序数的正序二进制</span></span><br><span class="line">        answer = <span class="built_in">multiple</span>(answer,<span class="number">2</span>); <span class="comment">//对于中间结果右移一位</span></span><br><span class="line">        answer = <span class="built_in">add</span>(answer,InvertBinary[i]); <span class="comment">//加上低位的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; answer.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,answer[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string sNum;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;sNum)&#123;</span><br><span class="line">        <span class="built_in">printInvertBinNum</span>(sNum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>M进制转N进制<blockquote><p>由于M，和N的值都有可能大于10，所以有字符串的形式存储M进制数和N进制数。因此需要现将M进制的数转换为数值形式，这里将其转换为我们熟悉的十进制是一种常见的方式，通过十进制作为两种不同进制字符串形式转换的桥梁。即 M进制字符串形式 –&gt; 十进制数值形式 –&gt; N进制字符串形式。在其中注意一些细节问题，如需要将高于10进制的数中的英文字符转换为数字，将高于10的数字转换为英文字符。这是于小于10的进制转换所不需要考虑的问题。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CharToInt</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&#x27;0&#x27;</span>&lt;=c &amp;&amp; c&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c-<span class="string">&#x27;A&#x27;</span>+<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">IntToChar</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x&lt;<span class="number">10</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;0&#x27;</span>+x;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x<span class="number">-10</span> + <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m,n;</span><br><span class="line">    string str,Nmum;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;m,&amp;n)) &#123;</span><br><span class="line">        cin &gt;&gt; str;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); ++i) &#123;  <span class="comment">//M进制转为10进制</span></span><br><span class="line">            number *= m;</span><br><span class="line">            number += <span class="built_in">CharToInt</span>(str[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="keyword">char</span>&gt; answer;</span><br><span class="line">        <span class="keyword">while</span>(number != <span class="number">0</span>)&#123;</span><br><span class="line">            answer.<span class="built_in">push_back</span>(<span class="built_in">IntToChar</span>(number%n));</span><br><span class="line">            number /= n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = answer.<span class="built_in">size</span>()<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, answer[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>进制转换的问题，最为重要的是转换的方法： 1.正向除留取余法，2.逆向移位求和法。 注意在做两种运算的过程中1的输出、2的输入的数据的顺序与正常情况下的相反。<br>在此基础之上，有时需要考虑到输入数据的方式：</p><ol><li>由于高于10进制，存储使用字符串方便。对于这种可以想办法把输入转为10进制数值，根据题目要求作处理。</li><li>需要输入的数远大于数值类型的存储范围，使用字符串存储。对于该类数据的运算，不能使用数值型，因为无法存储中间结果。需要实现字符串级别的“算术运算”。要注意定义运算过程中的一些细节，如运算后结果的修正，考虑最高位进位问题等。</li></ol><h3 id="最大公约数与最小公倍数"><a href="#最大公约数与最小公倍数" class="headerlink" title="最大公约数与最小公倍数"></a>最大公约数与最小公倍数</h3><p>这种题需要对于最大公约数和最小公倍数的判别方法熟悉。</p><h4 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h4><blockquote><p>对于 a, b 两数，求其最大公约数的思路是：</p><ol><li>把求   a, b的最大公约数 —&gt;  b, a%b的最大公约数  （数学推理过程略） <strong>注意b作为除数不能为0</strong></li><li>这样不断递归的缩小范围，直到求 某个数与0 的最大公约数，即非0数为最大公约数</li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxFactor</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">MaxFactor</span>(b,a%b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m,n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;m,&amp;n)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in">MaxFactor</span>(m,n));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="最小公倍数"><a href="#最小公倍数" class="headerlink" title="最小公倍数"></a>最小公倍数</h4><p>求最小公倍数思路是基于最大公约数的：<br>    a,b 的最小共倍数是  a*b / 最大公约数</p><h3 id="质数-素数"><a href="#质数-素数" class="headerlink" title="质数/素数"></a>质数/素数</h3><blockquote><p>质数或者素数a： 只能被1和本身整出的<strong>正整数</strong>（小于2的数一定不是素数）。 用所有小于sqrt(a)的数除a,如果存在整除的情况则不是素数。</p></blockquote><h4 id="判断一个数是否为素数"><a href="#判断一个数是否为素数" class="headerlink" title="判断一个数是否为素数"></a>判断一个数是否为素数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">JudgeSuNum</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">2</span>)&#123;                <span class="comment">//小于2的数一定不是素数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> bound = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; bound; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n%i == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in">JudgeSuNum</span>(n));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于一定大范围的数，判断其是否为素数，对于每一个数遍历判别，显然是有些耗时，效率不高。是否有更好的方法呢？——-素数筛选法</p><p>素数筛选法的思想是：假设当前大于1的数都为素数，遍历所有数，用已确定的素数，去标记后面是该素数倍数的数为非素数。通过选出不是素数的数，剩余的则是素数。</p><h4 id="输出1到给定n之间的素数"><a href="#输出1到给定n之间的素数" class="headerlink" title="输出1到给定n之间的素数"></a>输出1到给定n之间的素数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10001</span>;</span><br><span class="line"><span class="keyword">bool</span> isPrime[MAXN];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; prime;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Initial</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXN; ++i) &#123;</span><br><span class="line">        isPrime[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    isPrime[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">    isPrime[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; MAXN; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!isPrime[j])&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        prime.<span class="built_in">push_back</span>(j);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = j*j; i &lt; MAXN; i+=j) &#123;  <span class="comment">//从当前素数j的j倍开始，小于j的倍数的数 由 小于j的素数标记。i的“自增”为j的倍数</span></span><br><span class="line">            isPrime[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Initial</span>();</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n) != EOF) &#123;</span><br><span class="line">        <span class="keyword">bool</span> isOutput = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prime.<span class="built_in">size</span>() &amp;&amp; prime[i]&lt;n; ++i) &#123;</span><br><span class="line">            isOutput = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,prime[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!isOutput)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分解质因数"><a href="#分解质因数" class="headerlink" title="分解质因数"></a>分解质因数</h3><p>给定一个数N（1&lt;N&lt;1E9），将其分解为多个质因数相乘  </p><blockquote><ol><li>分解质因数，需要用到上题素数筛选法，通过素数筛选法确定 1～sqrt(1E9)+1 之间的素数。</li><li>遍历素数序列： 用素数取整除 N，如果成功则为N的质因数，输出。直到 所有的素数都遍历结束。</li><li>遍历结束后需要判断 N 整除前面得到的质因数的结果是否大于1，如果大于一，则存在大于 sqrt(1E9)+1的质因数。需要输出。</li></ol><p><strong>（对于N来说之多存在一个大于 sqrt(n）的质因数）</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">40000</span>;</span><br><span class="line"><span class="keyword">bool</span> isPrime[MAXN];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; prime;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Initial</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXN; ++i) &#123;</span><br><span class="line">        isPrime[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    isPrime[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">    isPrime[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; MAXN; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!isPrime[j])&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        prime.<span class="built_in">push_back</span>(j);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = j*j; i &lt; MAXN; i=i+j) &#123;  <span class="comment">//从当前素数j的j倍开始，小于j的倍数由小于j的素数标记其不为素数。i 的值为j的倍数</span></span><br><span class="line">            isPrime[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Initial</span>();</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n) != EOF) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prime.<span class="built_in">size</span>() &amp;&amp; prime[i]&lt;=n; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span>(n%prime[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,prime[i]);</span><br><span class="line">                n /= prime[i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">1</span>)&#123;   <span class="comment">//未出尽的数大于则是素因数</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><p>对于 a^b 的快速算法思路：</p><blockquote><p>将b分解为若干个2^k的和  如： 3^29 ,  其中b为29 = 1 + 4 + 8 + 16;</p><p>a^b = a^k1 * a^k2 * … * a^km,  3^29 = 3^1 * 3^4 * 3^8 * 3^16;</p><p>这样       3^1 = 3</p><pre><code>      3^2 = 3^1 * 3^1      一次计算         3^4 = 3^2 * 3^2      二次计算         3^8 = 3^4 * 3^4      三次计算          3^16 = 3^8 * 3^8     四次计算</code></pre></blockquote><blockquote><pre><code>      3^29 只需要计算四次   普通乘法需要29次</code></pre></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">aEb</span><span class="params">(<span class="keyword">long</span> a, <span class="keyword">long</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> answer = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(b != <span class="number">0</span>)&#123;     </span><br><span class="line">        <span class="keyword">if</span>(b%<span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">            answer *= a;</span><br><span class="line">        &#125;</span><br><span class="line">        b /= <span class="number">2</span>;        </span><br><span class="line">        a *= a;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b) != EOF) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,<span class="built_in">aEb</span>(a,b));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="高精度整数运算C-类是现实"><a href="#高精度整数运算C-类是现实" class="headerlink" title="高精度整数运算C++类是现实"></a>高精度整数运算C++类是现实</h3><blockquote><p>高进度数之所以不好处理的在于无法存储。一般有两种比较常见的处理方式： </p><ol><li> 用字符串存储</li><li> 用数组存储</li></ol><p>用字符串存储，在编写相应的算术运算实现时，对字符串操作由于字符串的长度不一，两个高进度整数运算时需要考虑具体的处理问题比较多。用数组存储，好处是通过指定存储数组的空间，算术运算实现时，不需要考虑太多运算过程中的数的长度的影响，因为为存储数的数组元素中的大于数长度的部分值置为0，便于大数与小数的运算。确点是需要实现分配容纳数的大量空间，利用效率不一定高。</p></blockquote><p>一下的算法是基于数组存储高进度整数的。<strong>数组存储以十进制的方式，从0～MAXN的下标依次存储数的个位、十位、百位、….</strong></p><ol><li><p>高进度整数表示的类定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN  = <span class="number">10000</span>;  <span class="comment">//最大能存储的10进制数的位数</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BigInteger</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> digit[MAXN];  <span class="comment">//从0～MAXN 存放数字的 个位 十位 百位 ...</span></span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">BigInteger</span>();</span><br><span class="line">    <span class="built_in">BigInteger</span>(<span class="keyword">int</span> x);</span><br><span class="line">    <span class="built_in">BigInteger</span>(string str);</span><br><span class="line">    <span class="built_in">BigInteger</span>(<span class="keyword">const</span> BigInteger&amp; b);</span><br><span class="line">    BigInteger <span class="keyword">operator</span>=(<span class="keyword">int</span> x);</span><br><span class="line">    BigInteger <span class="keyword">operator</span>=(string str);</span><br><span class="line">    BigInteger <span class="keyword">operator</span>=(<span class="keyword">const</span> BigInteger&amp; b);</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;=(<span class="keyword">const</span> BigInteger&amp; b);</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> BigInteger&amp; b);</span><br><span class="line"></span><br><span class="line">    BigInteger <span class="keyword">operator</span>+(<span class="keyword">const</span> BigInteger&amp; b);</span><br><span class="line">    BigInteger <span class="keyword">operator</span>-(<span class="keyword">const</span> BigInteger&amp; b);</span><br><span class="line">    BigInteger <span class="keyword">operator</span>*(<span class="keyword">const</span> BigInteger&amp; b);</span><br><span class="line">    BigInteger <span class="keyword">operator</span>/(<span class="keyword">const</span> BigInteger&amp; b);</span><br><span class="line">    BigInteger <span class="keyword">operator</span>%(<span class="keyword">const</span> BigInteger&amp; b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; in, BigInteger&amp; x);</span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, BigInteger&amp; x);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>高进度整数类的构造函数实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">BigInteger::<span class="built_in">BigInteger</span>() &#123;</span><br><span class="line">    <span class="built_in">memset</span>(digit,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(digit));</span><br><span class="line">    length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger::<span class="built_in">BigInteger</span>(<span class="keyword">int</span> x) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(digit,<span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(digit));</span><br><span class="line">    length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">0</span>)&#123;                <span class="comment">//对于0的特殊处理</span></span><br><span class="line">        digit[length++] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(x != <span class="number">0</span>)&#123;</span><br><span class="line">        digit[length++] = x%<span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger::<span class="built_in">BigInteger</span>(string str) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(digit,<span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(digit));</span><br><span class="line">    length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = str.<span class="built_in">size</span>()<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) &#123;  <span class="comment">//注意数组存储的方式从低位到高位</span></span><br><span class="line">        digit[length++] = str[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger::<span class="built_in">BigInteger</span>(<span class="keyword">const</span> BigInteger &amp;b) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(digit,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(digit));</span><br><span class="line">    length = b.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">        digit[i] = b.digit[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure></li><li><p>赋值运算符的重载</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>=(<span class="keyword">int</span> x) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(digit,<span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(digit));</span><br><span class="line">    length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">0</span>)&#123;</span><br><span class="line">        digit[length++] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(x != <span class="number">0</span>)&#123;</span><br><span class="line">        digit[length++] = x%<span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>=(string str) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(digit,<span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(digit));</span><br><span class="line">    length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = str.<span class="built_in">size</span>()<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        digit[length++] = str[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>=(<span class="keyword">const</span> BigInteger &amp;b) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(digit,<span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(digit));</span><br><span class="line">    length = b.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">        digit[i] = b.digit[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>输入、输出运算符重载</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; in,BigInteger &amp;x)&#123;</span><br><span class="line">    string str;</span><br><span class="line">    in&gt;&gt;str;</span><br><span class="line">    x = str;</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out,<span class="keyword">const</span> BigInteger &amp;x)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x.length<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        out&lt;&lt; x.digit[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure></li><li><p>高进度正整数的算术运算</p><p>a. 比较</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> BigInteger::<span class="keyword">operator</span>&lt;=(<span class="keyword">const</span> BigInteger&amp; b)&#123;</span><br><span class="line">    <span class="keyword">if</span>(length &lt; b.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(b.length &lt; length)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = length<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (digit[i] == b.digit[i])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> digit[i] &lt; b.digit[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> BigInteger::<span class="keyword">operator</span>==(<span class="keyword">const</span> BigInteger &amp;b) &#123;</span><br><span class="line">    <span class="keyword">if</span>(length != b.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = length<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (digit[i] != b.digit[i])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​            b. 加法    </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>+(<span class="keyword">const</span> BigInteger &amp;b) &#123;</span><br><span class="line">    BigInteger answer;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> bound = length&gt;b.length ? length:b.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bound; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = digit[i] + b.digit[i] + carry;</span><br><span class="line">        answer.digit[answer.length++] = temp % <span class="number">10</span>;</span><br><span class="line">        carry = temp / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(carry == <span class="number">1</span>)&#123;  <span class="comment">//最高位有进位</span></span><br><span class="line">        answer.digit[answer.length++] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>加法运算比较简单，以两个数中最大的长度为遍历边界，对于每一位进行加和，留下和中小于10的部分，大于10的作为进位，加入高位的求和中。</p></blockquote><blockquote><p>注意： 两数的每一位遍历加和完成后，<strong>要判断最高位是否有进位（即进位的标记是否为1），如果有进位，则求和的结果在最高位前补1</strong>；</p></blockquote><p>​        c. 乘法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>*(<span class="keyword">const</span> BigInteger &amp;b) &#123;</span><br><span class="line">    BigInteger answer;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    answer.length = length + b.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length;  ++i) &#123;                 <span class="comment">//模拟：每位与乘数每一位运算后的，同权的位结果求和</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; b.length; ++j) &#123;</span><br><span class="line">            answer.digit[i+j] += digit[i] * b.digit[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; answer.length; ++k) &#123;           <span class="comment">//对于answer结果中的每一位超过10的进行修正进位</span></span><br><span class="line">        answer.digit[k+<span class="number">1</span>] += answer.digit[k] / <span class="number">10</span>;</span><br><span class="line">        answer.digit[k] %= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(answer.digit[answer.length<span class="number">-1</span>] == <span class="number">0</span> &amp;&amp; answer.length &gt; <span class="number">1</span>)&#123;   <span class="comment">//消除结果中多余的0</span></span><br><span class="line">        answer.length--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>乘法：稍微复杂一点</p><ol><li>模拟手动计算乘法的过程，即将乘数的从最低位一次去乘被乘数，要注意一个细节： <code>乘数的第i位 * 被乘数的第j位 = 结果的第(i+j)位</code>。将对应结果的权值相同的位加起来。</li><li>此时等到的结果中，每一位的值都可能大于10，需要对这些位做调整，将大于10的部分进位到高位，留下小于10的部分作为当前位的值。</li><li>乘法结果中可能存在连续多个高位到最高位为0，需要去除多余的0.否则对于根据数字有效长度判断大小的函数，会产生错误的比较结果。（如： 000 &gt; 0）</li></ol></blockquote><p>​        d.减法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>-(<span class="keyword">const</span> BigInteger &amp;b) &#123;     <span class="comment">//只使用于大数减小数的减法</span></span><br><span class="line">    BigInteger answer;</span><br><span class="line">    <span class="comment">//大数为this指向的对象，b为小数的对象</span></span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> bound = length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bound; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = digit[i] - b.digit[i] - carry;</span><br><span class="line">        <span class="keyword">if</span> (temp &gt;= <span class="number">0</span>)&#123;         <span class="comment">// 如果 被减数 大于等于 (减数+借位)则不需要进位</span></span><br><span class="line">            answer.digit[answer.length++] = temp;</span><br><span class="line">            carry = <span class="number">0</span>;   <span class="comment">// 如果没有借位需要把carry从1置为0否则会影响以后计算的结果</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            answer.digit[answer.length++]  = <span class="number">10</span> + temp;</span><br><span class="line">            carry = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(answer.digit[answer.length<span class="number">-1</span>] == <span class="number">0</span> &amp;&amp; answer.length &gt; <span class="number">1</span>)&#123;  <span class="comment">//去除结果中多余的0</span></span><br><span class="line">        answer.length--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>减法：<br>从被减数的低位到高位： 依次减去（减数对应权的位+低位相当前位的借位）。减后结果有两种情况：</p><ul><li>结果&lt;0 ,此时就需要向高位借位。 结果+10 修正， 借位置1</li><li>结果&gt;=0,此时结果无需修正，<strong>但是注意要将借位位置为0</strong><br>减法同样需要对于结果中多余的0进行修正</li></ul></blockquote><p>​        e. 除法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>/(<span class="keyword">const</span> BigInteger &amp;b) &#123;</span><br><span class="line">    BigInteger answer;</span><br><span class="line">    answer.length = length;</span><br><span class="line">    BigInteger remainder = <span class="number">0</span>;</span><br><span class="line">    BigInteger temp = b;   <span class="comment">// temp 存在的意义在于 比较运算符 &lt;= 前的对象不能是const 类型。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = length<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(remainder.length == <span class="number">1</span> &amp;&amp; remainder.digit[<span class="number">0</span>] == <span class="number">0</span>))&#123;   <span class="comment">//余数不为0</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = remainder.length<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j) &#123;  <span class="comment">//高位余数右移（向高位的方向移动）</span></span><br><span class="line">                remainder.digit[j+<span class="number">1</span>] = remainder.digit[j];</span><br><span class="line">            &#125;</span><br><span class="line">            remainder.length++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        remainder.digit[<span class="number">0</span>] = digit[i]; <span class="comment">//当前位并如余数中 ，成为新的被除对象</span></span><br><span class="line">        <span class="keyword">while</span>(temp &lt;= remainder)&#123;        <span class="comment">//除操作</span></span><br><span class="line">            remainder = remainder - temp;</span><br><span class="line">            answer.digit[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (answer.digit[answer.length<span class="number">-1</span>] == <span class="number">0</span> &amp;&amp; answer.length &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        answer.length--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>除法的操作：与加法、减法、乘法的不同之处在于，除法运算是从高位到低位的顺序<br>遍历被除数的每一位： </p><ol><li>高位的余数*10（右移一位）与当前位并入，作为新的被除对象。</li><li>对于被除对象的除操作可以表达为： 对被处对象不断的减去除数，对于最终商的当前位置不断加1，直到被除对象小于除数。此时被处对象的值就是当前位余数的值</li><li>遍历被除数的下一位</li></ol></blockquote><p>​        f. 取余<br>取余操作是与除法紧密相关的操作，即除法最终的余数，即位所求。<br>因此，取余的算法几乎与除法算法相同，只是移除了不需要保存的除法的商。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>%(<span class="keyword">const</span> BigInteger &amp;b) &#123;</span><br><span class="line">    BigInteger remainder = <span class="number">0</span>;</span><br><span class="line">    BigInteger temp = b;   <span class="comment">// temp 存在的意义在于 比较运算符 &lt;= 前的对象不能是const 类型。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = length<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(remainder.length == <span class="number">1</span> &amp;&amp; remainder.digit[<span class="number">0</span>] == <span class="number">0</span>))&#123;   </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = remainder.length<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                remainder.digit[j+<span class="number">1</span>] = remainder.digit[j];</span><br><span class="line">            &#125;</span><br><span class="line">            remainder.length++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        remainder.digit[<span class="number">0</span>] = digit[i];</span><br><span class="line">        <span class="keyword">while</span>(temp &lt;= remainder)&#123;</span><br><span class="line">            remainder = remainder - temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> remainder;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 机试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 研究生复试上机题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DevOps是什么?为什么我们需要DevOps?</title>
      <link href="/2019/04/18/DevOps%E6%98%AF%E4%BB%80%E4%B9%88-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81DevOps/"/>
      <url>/2019/04/18/DevOps%E6%98%AF%E4%BB%80%E4%B9%88-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81DevOps/</url>
      
        <content type="html"><![CDATA[<p>什么是 DevOps? 公司在推行 DevOps 的进程中应该注意什么？只有大公司才能从 DevOps 中收益？~</p><p>英文原文：《What is DevOps and Why Do We Need It?》作者：Skywell Software<br>原文链接：<a href="https://medium.com/datadriveninvestor/what-is-devops-and-why-do-we-need-it-82c2ef0a9d3d">https://medium.com/datadriveninvestor/what-is-devops-and-why-do-we-need-it-82c2ef0a9d3d</a></p><span id="more"></span><p>DevOps 被许多专家认为，是一种最好的方式去加强开发团队和运维团队的合作。但是 DevOps 不仅仅是一种方法，它更是一种文化使得软件开发过程中技术和业务双方合作更加高效，以使得产品上市时间缩短，产品<strong>整体</strong>的质量得以提升。在了解为什么 DevOps 这么重要之前，我们首先给它一个定义。</p><h3 id="DevOps-定义"><a href="#DevOps-定义" class="headerlink" title="DevOps 定义"></a>DevOps 定义</h3><p>DevOps 是，打破分隔 开发和运维团队壁垒，增强彼此之间合作的敏捷开发方法论的产物。但是如果你无法适当地应用这种正确的文化，DevOps 将沦为赶时髦的官话。这些使用 DevOps 文化所倡导的：</p><ul><li><p>责任共有—— 在许多公司，开发团队单单专注于产品的开发，对于系统的运维和管理不感兴趣，甚至回避如果这是别人的工作。如果在系统运行期间的监控工作成为开发团队的职责的一部分，他们很可能就能够体会到运维团队工作是的痛苦。DevOps 产生了一种新的方式，通过自动化部署和很好的日志记录来简化部署和维护工作。</p></li><li><p>团队自主化——高效的合作仅仅会发生在没有复杂的决策流程，开发和运维团队能够独立的做决定和改动的情况下。这个就需要新人你的团队、调整风险管理的策略并避免员工惧怕承担风险和失败的情况。</p></li><li><p>移除所有孤岛——一些公司记录过程并且将记录资料移交另一个团队，认为这是一个定期的合作。</p></li></ul><h3 id="DevOps-的整个流程"><a href="#DevOps-的整个流程" class="headerlink" title="DevOps 的整个流程"></a>DevOps 的整个流程</h3><p>DevOps 的整个流程由多个阶段组成，但是它们的如下列举的类似：</p><ul><li><p>计划——这个阶段包括你预期的开发进度的最初规划</p></li><li><p>编码——根据客户的需求开发应用程序</p></li><li><p>构建——合并各个你编写的代码</p></li><li><p>发布——如果测试通过，应用可以上线</p></li><li><p>部署—— 为了一些附加的用途，程序部署到云环境下</p></li><li><p>运维—— 在代码层面指导运维工作</p></li><li><p>监控—— 关注应用的运行情况，进行必要的改进以满足客户端的需求</p></li></ul><h3 id="为什么我们需要-DevOps？"><a href="#为什么我们需要-DevOps？" class="headerlink" title="为什么我们需要 DevOps？"></a>为什么我们需要 DevOps？</h3><p>DevOps 为软件开发公式带来的许多好处，例如，增加了创新的速度为客户更好的服务。能够使你在变化的市场环境下，灵活的调整产生更高的商业价值。由于频繁的迭代速度和节奏，你能更够快速的优化你的产品。这使得发布新特性的时间更短，发现和修复 bug 的速度更快。而更重要的是,快速的用户响应能力将成为你的业务的有力竞争优势。持续集成和持续发布就是从构建到部署的自动化软件发布过程的实践。</p><p>虽然产品化的步伐被加速，但是它在完成时依然如此的稳定可靠。通过 CI/CD 你能够测试所有产品的变更，更好的监控和日志记录将帮助你保持你的应用在生产环境中一直运行在最佳状态。安全流程不会被影响，因为合规策略将被细粒度的控制和管理配置技术自动化。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>如果你刚刚开始踏上 DevOps 落地之旅，设定切实可行的目标期望是必不可少的。当你迫切希望获得 DevOps 项目管理带来的好处时，你的团队可能经历着文化的冲击，因为他们一直习惯于原来独立的组织结构。改变已将建立好的流程并不容易，需要花费时间落实在人员、流程和信息等方面。这种文化的冲击将会带来新的目标表，你不能告诉的以前一个月迭代一个版本的团队，现在开始每天维护五个版本，这完全行不通。</p><p>当你意识到发布时间表应该在你的团队开始去接受 DevOps 文化和方法论时慢下来，你需要有一个更有组织的方式。需要许多的学习和训练，需要时间去习惯这所有的改变。在过渡过程中，建立一些重要的业务指标是重要的，如整体的收入和客户的满意度。以有各种本版的目的而创建多个版本是没有意义的。它必须对于你们的业务基础有效果。</p><p>考虑到 DevOps 所带来的优点，可以负责任的说那些没有完成 DevOps 进程化的公司将面临落后的风险。一个普遍的错误观点是 DevOps 仅仅针对大公司，但是小型和中等规模的公司也能够从中获得 DevOps 所提供的好处。事实上，像 Facebook、Netflix 和 其他的集团公司能够实现如此快速的增长，是因为他们很早就采用了 DevOps 的模式，使得他们能够相对于竞争对手更快的提供新功能给用户。因此，如果你还没有开始 DevOps 的进程，你已经落后于你的竞争者了。</p>]]></content>
      
      
      <categories>
          
          <category> 翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> open source </tag>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-Web框架介绍</title>
      <link href="/2019/04/17/Python-Web%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/"/>
      <url>/2019/04/17/Python-Web%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p>针对 Python 中的 全栈框架（Django） 和 微型框架（Flask）行进介绍，对于一些应用特定场景的其他框架做简单的说明~</p><p>英文原文：《A Complete Guide to Python Web Frameworks》作者：Premjith B P K</p><p>原文链接：<a href="https://opensourceforu.com/2019/04/a-complete-guide-to-python-web-frameworks/">https://opensourceforu.com/2019/04/a-complete-guide-to-python-web-frameworks/</a></p><span id="more"></span><p>Web 框架就是一些函数库，通过使用这些库使得 Web 开发更加简单快捷。Python 作为多功能的编程语言，有许多 Web 框架，像 Django、Web2py、Flask 和 Bottle等等。接下来我们将来介绍这些框架的相关情况。</p><p>对于开发 Web 应用程序的团队，Python 是一种主流且非常灵活的编程语言。应用程序以一种模块化的开发模式进行开发，使得开发者和 Web 框架紧密的联系起来。调用框架中提供的大量的解决方案，使得开发者能够更加专注于应用程序的逻辑业务，不再为重复和低优先级的任务所扰。</p><p>如今，开发者尝试使用强大功能的 Python 框架去解决解决一些具体的实现细节，这个加速了原型设计和开发的进程。从针对企业的强大全栈框架到适合开发小型专业的工具的超轻量级微框架流，目前有各种各样的流行的 Python Web 框架。</p><p>Python Web 框架在很大程度上削减了 Web 应用开发的成本、人力和时间周期。我们将分享这些流行框架中一些重要功能点，帮助在你开发 Web 应用程序中做的更好。我们希望能够帮助你确定针对自己实际需求的最合适框架。</p><h3 id="框架的作用"><a href="#框架的作用" class="headerlink" title="框架的作用"></a>框架的作用</h3><p>Web 框架使得开发者不需要去关注 Socket、协议 和 线程管理 等细节，专注于 Web 应用程序和服务的开发。框架的完成的大部分职责集中于 cookies 的处理、参数的获取以及 session 的处理等。主流的 Web 框架分为两大类：全栈框架 和 微型框架。</p><h3 id="选择全栈框架还是微型框架"><a href="#选择全栈框架还是微型框架" class="headerlink" title="选择全栈框架还是微型框架"></a>选择全栈框架还是微型框架</h3><p>当你在框架选择时，你应该将项目规模和复杂性作为考虑的重要因素。如果你希望应用的开发以业务功能为主，需要与其他的周边框架协作，全栈框架的选择将能够减少整个团队在开发时间和开发任务。但是，如果你在开发一个小型、简单需求的少的项目时，微型框架是你最好的选择。另一个需要考虑的问题是：你需要框架帮你完成多少事情？全栈 Web 框架包含了开发一个功能丰富 Web 应用的所有组件—框架生成器、访问列表和模板等。这使得你的团队能根据不同的需求创建出相应的页面和应用。对于希望快速开发出产品的团队这是一个很好的选择，因为这是使得他们更加专注于应用的开发而不是与之相关的周边事情。如果你有复杂的个性化需求或者已经在开发多种不同类型的定制化的软件，不管在什么情况下，你都不应该使用这些框架。</p><h3 id="全栈框架"><a href="#全栈框架" class="headerlink" title="全栈框架"></a>全栈框架</h3><p>有许多新且完备的全栈 web Python框架选择方案：如主流的框架 TurboGears 2、Pylons 和 Web2py。但是其中最流行的是 Django。</p><ul><li><p>Django</p><p>Django 是流程的 Python 框架，至于具体的原因大家不难理解。大量的网站使用了 Django，从出版社到社交媒体和分享网站，再到重要的<strong>机构</strong>和非盈利组织。由于 Django 最初开发于编辑部门，因此 华盛顿邮报 和 卫报 运行在该框架上也不是意外。一些新公司和初创公司像 Eventbrite 和 Disqus 已经在往 Django 迁移并且在提高完成度。同时社交巨头 Instagram 和 Pinterest 已经使用该框架去开发他们的动态 Web 应用。 </p><p>当考虑到框架时，Django 以快速开发 和 对业务开发者友好 而著称。作为一种“可插拔式”的框架，它提供了所有你需要的基础的组件 认证、可渲染模板、ORM 和路由等。相比于其他的主流 Web 框架，它有良好的技术文档。</p><p>通过对大量选择的处理，Django 能够在很大程度上减少新项目的引导时间。但是，在获得速度的同时也牺牲了长期开发维护的灵活性。例如，Django 内置的 ORM 在大部分情况下效果显著。但是，它无法像被称为最好的 Python 数据库抽象工具 SQLAlchemy那样有突破性。你可以想象在 Django 下使用 SQLAlchemy，但是那样你讲失去 Django 中的一些一开始就吸引人的重要功能。</p></li></ul><ul><li><p>Web2py</p><p>Web2py 是另一个主流的全栈框架。需要牢记的是 Web2py 不兼容 Python3。虽然 Web2py 的早期开发者已经保证会去开发兼容 Python3 的新版，但时至今日依然没有新版依然没有正式发布。</p><p>即便相较目前最新发布的 Python 版本已经十年时间了，Web2py 依然在许多大型企业中使用，其中就包括跨国银行。使得这个老 Web 框架依然有许多开发者在使用的原因，是他独一无二的功能。一方面，它即能够像 Django 一样简单易学习，又兼具灵活性和可扩展能力。不管是 AWS 还是 Google App Engine 中 VPS， 同样的一段代码几乎可以应用到 所用的使用 SQL  或者 Mongo DB 的 VPS 中 。</p><p>Web2py 有优秀的文档手册和活跃的社区在其背后作为强大的支持。另一个亮点在于 Web2py 有自己的IDE，其中包含了 代码编辑器、调试器、bug 票务框架 和 单独的票务部署功能等等。如果你的团队在未来几年中开发以 Python2 为主，或者希望充分利用已有的众多 Python 库和应用，那么 Web2py 框架非常符合你的要求。</p><p>Pyramid 确切的来说不是一个全栈的 Web 框架，并且自称是符合“金发姑娘”原则（适度原则）的框架。Pyramid 有这丰富的特性不会限制使用某种特定的方式去处理事情。作为一种轻量级的框架，不会使你随着应用的开发陷入独自一人的窘境。由于良好的通透性和模块化，Pyramid 是 Python 老鸟最喜爱的开发框架。不仅中等规模的团队在使用，像 Mozilla、Yelp、SurveyMonkey 和 Dropbox 这样的科技巨头也在使用。</p><p>事实上，Pyramid 框架中几乎所有的组件都能够替换掉。你能够使用你的数据库接口，甚者连接任何你想要连接的数据库。它不会像Django那样授权处理具体的选择，也不鼓励自动化处理具体任务的奇妙功能。这使得它不会表现预期的或者吸引人的方式。</p><p>Pyramid 流程的原因是它安全的解决方案，使得访问控制记录的创建和检查变得简单。另一个值得关注的创新功能是 Pyramid 的从 URL 到 code 的映射的路由系统，这使得最终创建 RESTful 接口变得容易。</p></li></ul><h3 id="微型框架"><a href="#微型框架" class="headerlink" title="微型框架"></a>微型框架</h3><p>考虑到你可能不需要全面和丰富的全栈框架。如今，新一代的 Web 应用需要许多可以插拔的部分，包括数据库抽象层，框架认证 和 可配置的访问控制规则。但是也有大部分的 Web 应用不要这些模块。对于这种项目，微型框架应该是最需要的。</p><p>这些超轻量级的应用被开发的目的是使得一些死掉的 Web 应用重新能被使用并且尽可能的运行的更快。他们的设计的功能精简—————— 对一些能通过安装一些其他的库满足的功能专门进行了移除。使用这些透明的方法的好处是使你的代码更加的简洁清晰，并且网站运行速度更快。这就是为什么微型框架没有全栈框架那么抽象。相比于对初学者友好的 Web 框架，你编写的代码将需要触及HTTP 的一些功能。</p><ul><li><p>Flask: </p><p>Flask 无疑是最有名的 Python 微型框架，并且一直是最有名的 Python 结构中的佼佼者。和 Django 一样，开发 Flask 的目的是使得 Web 应用开发并尽可能运行的更快。虽然是微型框架，但 Flask 已经被一些大公司所使用，其中包括 LinkedIn 和 Pinterest。</p><p>无论如何，这是个较量。相比 Django，Flask是那些又小又简单项目的理想选择。因此，你可以期待 Web 服务器开发将支持 Google App Engine 并且 内置单元测试功能。Flask 不支持 数据库抽象层 和 表单验证，且自动上传的功能被禁用。但是，每一个这些功能都能够通过外部扩展来实现。例如一些主要的扩展包括 SQLAlchemy 数据库 、 Jinja2 模板和 CouchDB。</p><p>一些 Python 开发者会选择 Flask 而非 Django ，因为前者越来越 Pythonic。这更加符合 Pytho 之禅的原则：一种方式完成事情，并且相应的代码能够表明在做什么。如果你非常想要从头开始使代码更加简洁明了，Flask 应该是你合适的选择。</p></li><li><p>Bottle: </p><p>Bottle 是另一个主流的微型框架。它从一开始就是为创建 Web API 而生，这也是它最好的使用案例。Bottle 更加奇妙的地方在于，它尝试使用一个单一的文件做所有的事情，这给我们一个重要的认识：它的设计是多么的 micro。</p><p>Bottle 包含一些开箱即用的功能包括 模板、路由、应用程序 和 一些在 WSGI 标准上的基础抽象。和 Flask 一样，有你的编码将更接近底层相比于全栈框架。尽管如此，Bottle 已经被 Netfilx 用于创建 Web 接口。</p></li></ul><h3 id="其他一些流行的框架"><a href="#其他一些流行的框架" class="headerlink" title="其他一些流行的框架"></a>其他一些流行的框架</h3><p>我们已经介绍了许多广泛使用的 Python Web 框架，你可以从中有不同的选择。接下来将了解一些在特定情况下表现优良的其他框架。</p><p>Tornado 是专为解决 C10k 问题而开发的 Python Web 框架。（在正确配置下，它能够通过异步 I/O 处理超过 10,000 并发连接数）这个对于那些需要高质量且大量并发用户的项目是一个巨大的吸引力。</p><p>CubicWeb 是一个奇妙的 Web 框架，它完全不同其他的 Web 框架。它是语义 Web 的一种，用外行人的话将，它是一个通过减少对于电脑系统性能要求的方式来显示信息的系统。它使用一个单独的概念替代了 MVC 模型中的 model 和 view ，即数据块———能够由于开发不同的组件，有点像 Web 上的 Docker。</p><p>Phalcon 是一个专注于创建云 API 的微型框架。和其他微型框架一样，它保持的较少的依赖，并且与复杂功能保持着一个明智的距离。但是，不同于其他框架，它不是为 HTML 的页面而开发的，而是，为更快的创建 RESTful API 而生。</p><p>即便 Android 有非常优秀开箱即用的 SDK ，但使用 Python 实现替代 Java 实现有着巨大的好处，对于网站和应用开发（使用 Kivy 移动应用开发的 Python 开源库 ）。因为 Python 提供了更快的时间转化和库的复用。</p><p>Python 作为一个可靠、安全的开发语言，被用于安全敏捷 Web 应用的开发。作为可靠备选中的佼佼者，它减少了顶尖稳定 Web 应用和网站的开发周期。你可以在开发你的下一个项目时，咨询有经验的 Python 开发人员，以得到更好的指导。</p>]]></content>
      
      
      <categories>
          
          <category> 翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> open source </tag>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何通过在不写代码的情况下做开源</title>
      <link href="/2019/04/16/%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E5%9C%A8%E4%B8%8D%E5%86%99%E4%BB%A3%E7%A0%81%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E5%81%9A%E5%BC%80%E6%BA%90/"/>
      <url>/2019/04/16/%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E5%9C%A8%E4%B8%8D%E5%86%99%E4%BB%A3%E7%A0%81%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E5%81%9A%E5%BC%80%E6%BA%90/</url>
      
        <content type="html"><![CDATA[<p>本文作者阐述了，如果在不写代码的模式下，优雅的为开源事业做贡献~</p><p>英文原文：《How do you contribute to open source without code?》作者： Chris Hermansen<br>原文链接：<a href="https://opensource.com/article/19/4/contribute-without-code">https://opensource.com/article/19/4/contribute-without-code</a></p><span id="more"></span><p>我最早开始为开源做贡献要追溯到20世纪80年代中期。那是我们组织第一次连接到UseNet网站，在那里我们了解到了代码贡献以及为其开发和维护的机会。</p><p>今天，有很多种方式去做贡献，从代码贡献到制作教程。</p><p>我将一步步说明代码贡献这个问题，而不是仅仅指出“那些写代码却不认为自己是开发者的人，依然能够贡献代码”。我愿意告诉每个人：有很多种不通过写代码的方式贡献开源社区的方法。具体谈谈这种不写代码的贡献方式。</p><h3 id="提交-bug-报告"><a href="#提交-bug-报告" class="headerlink" title="提交 bug 报告"></a>提交 bug 报告</h3><p>一种主要、集中的代码贡献方式被称为“不要害怕创建一个体面的 bug 报告”，接下来得内容主要是关于这中方式。有时，编写一个相当好的的 bug 报告是一件相当有挑战的事情。比如：</p><ul><li><p>一些 bug 可能很难记录并秒速。例如 一个带有一系列的不可知代码的冗长复杂信息可能在计算机启动时闪现，或者导致一些奇怪的现象并且显示屏没有相应的错误信息产生。</p></li><li><p>一些 bug 可能是很难复现的。它仅仅在一些特定的 软件/硬件 配置下，并且很难再次触发，对于某些具体的问题可能并不明显。</p></li><li><p>一些 bug 可能涉及到一些非常具体的庞大、混乱、复杂开发环境配置，以至于 bug 的提交非常困难。需要花力气去创建一些精简的测试案例。</p></li><li><p>当提交一个分支版的软件 bug 时，维护者会建议提交上流版本的 bug 测试情况。在当前版本不是社区上流推崇的版本的分支时，这将产生许多工作量。（这个通常发生在分支版本的维护滞后于官方当前的发行版和开发版时）</p></li></ul><p>尽管如此，我依然倡导 未来的 bug 提交者 能够重视并尽可能详细的记录和说明 bug 的情况。</p><p>在开始时，通过自己喜欢的检索工具去寻找相关的 bug 报告，看看它们是如何描述，怎样展现等等。另一种重要的需要知道的是 bug 提交报告的正式术语，关于你用的系统分发版本（Fedora、openSUSE、Ubuntu） 或者 使用的软件（LIbreOffice、Mozilla） 。</p><h3 id="解决用户的问题"><a href="#解决用户的问题" class="headerlink" title="解决用户的问题"></a>解决用户的问题</h3><p>我潜水并偶尔参与到各种各样的邮件列表和论坛，像 Ubuntu quality control 小组或者论坛、LinuxQuestions.org 和 the ALSA users’ 邮件列表。在这里，主要的贡献不是 bug 的提交和修复，更多的是编写软件相关的使用案例。当有人加入讨论并解决他们的特殊问题时，每一个人都有一种喜悦。</p><h3 id="为开源而创作"><a href="#为开源而创作" class="headerlink" title="为开源而创作"></a>为开源而创作</h3><p>最后，另一个我喜欢的贡献方式是通过创作一些关于开源软件的使用的资料。包括 如何使用的指南、一个针对特殊问题，同类软件之间的测评 以及 对于一个感兴趣领域的探索（就我而言，使用开源的音乐播放器来聆听音乐）。一个类似的方式是制作软件使用教程视频，以一种简单的方式录制一些困难的桌面操作，如使用GIMP创作一个引人注目的logo。如果你熟悉两种或者多种语言可以考虑将目前的已有的一些文字教程和视频教程翻译为另一种语言。</p>]]></content>
      
      
      <categories>
          
          <category> 翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> open source </tag>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你应该知道的markdown语法</title>
      <link href="/2019/03/13/%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84markdown%E8%AF%AD%E6%B3%95/"/>
      <url>/2019/03/13/%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84markdown%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>关于 markdown 常用的一些语法，方便我们以 markdown 的方式记录生活~</p><span id="more"></span><p>你还在用word写笔记、心得体会、说明文档之类的东东吗？是不是还在为word的排版而烦恼? ^_^<br>快来试试,代码圈最风靡的说明文档编写姿势吧，markdown 让你在了解几分钟语法的情况,专注于内容的输出。下面我们一起来看一看这些经常用到的语法~</p><!--  --><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 大秦帝国</span></span><br><span class="line"><span class="section">## 长平杀降</span></span><br></pre></td></tr></table></figure><p>标题总共有六级</p><p>效果：</p><img src="/2019/03/13/%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84markdown%E8%AF%AD%E6%B3%95/%E6%A0%87%E9%A2%98.png" class="" title="标题效果"><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; 白起奉亲昭襄王诏令，坑杀赵国数十万放下武器的士兵</span></span><br><span class="line"><span class="quote">&gt;</span></span><br><span class="line"><span class="quote">&gt; &gt; 白起： 秦国上将军，战国时期四大战神之首。</span></span><br><span class="line"><span class="quote">&gt;</span></span><br><span class="line"><span class="quote">&gt; ## 武安君之死</span></span><br><span class="line"><span class="quote">&gt;</span></span><br><span class="line"><span class="quote">&gt; 硬候范睢建议秦昭襄王赐死辞官回乡的白起</span></span><br></pre></td></tr></table></figure><p>效果：</p><img src="/2019/03/13/%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84markdown%E8%AF%AD%E6%B3%95/%E5%BC%95%E7%94%A8.png" class="" title="引用效果"><p>对于引用可以在内部嵌套 markdown 的语法</p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">战国名士</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 苏秦</span><br><span class="line"><span class="bullet">-</span> 张仪</span><br><span class="line"><span class="bullet">-</span> 公孙衍</span><br><span class="line"><span class="bullet">-</span> 孟尝君</span><br></pre></td></tr></table></figure><p>效果：</p><img src="/2019/03/13/%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84markdown%E8%AF%AD%E6%B3%95/%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8.png" class="" title="无序列表效果"><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">战争的要素</span><br><span class="line"><span class="bullet">1.</span> 钱粮</span><br><span class="line"><span class="bullet">2.</span> 兵马</span><br><span class="line"><span class="bullet">3.</span> 将领</span><br></pre></td></tr></table></figure><p>效果：</p><img src="/2019/03/13/%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84markdown%E8%AF%AD%E6%B3%95/%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8.png" class="" title="有序列表效果"><h3 id="代办事项列表"><a href="#代办事项列表" class="headerlink" title="代办事项列表"></a>代办事项列表</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> [ ] 阅读孙皓晖教授的书籍</span><br><span class="line"><span class="bullet">-</span> [x] 观看大秦帝国之裂变</span><br></pre></td></tr></table></figure><p>效果：</p><img src="/2019/03/13/%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84markdown%E8%AF%AD%E6%B3%95/%E4%BB%A3%E5%8A%9E%E4%BA%8B%E9%A1%B9%E5%88%97%E8%A1%A8.png" class="" title="代办事项列表效果"><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">\<span class="code">`\`</span>\`c</span><br><span class="line"><span class="section">#include <span class="xml"><span class="tag">&lt;<span class="name">stdio.h</span>&gt;</span></span></span></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"><span class="code">    printf(&quot;hi~,markdowner ^-^ \n&quot;);   </span></span><br><span class="line"><span class="code">    </span></span><br><span class="line"><span class="code">    return 0;</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code">\`\`\`</span></span><br></pre></td></tr></table></figure><blockquote><p>代码块的语法以```为开头和结尾，此处由于博客展示的原因（不知道代码块的语法如何做到不转义，如果有知道的小伙伴，还请指教^_^）。</p></blockquote><p>效果：</p><img src="/2019/03/13/%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84markdown%E8%AF%AD%E6%B3%95/%E4%BB%A3%E7%A0%81%E5%9D%97.png" class="" title="代码块效果"><h2 id="内容标识"><a href="#内容标识" class="headerlink" title="内容标识"></a>内容标识</h2><p>斜体、加粗</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="emphasis">_白起的妻子是赵国人?_</span></span><br><span class="line"><span class="strong">**白起一生从无败战**</span></span><br></pre></td></tr></table></figure><p>效果：</p><img src="/2019/03/13/%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84markdown%E8%AF%AD%E6%B3%95/%E6%A0%87%E8%AF%86.png" class="" title="标识效果"><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">Dribbble</span>](<span class="link">https://dribbble.com/shots</span>)</span><br></pre></td></tr></table></figure><p>效果：</p><img src="/2019/03/13/%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84markdown%E8%AF%AD%E6%B3%95/%E9%93%BE%E6%8E%A5.png" class="" title="链接效果"><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">coding man</span>](<span class="link">https://lifeisbianry_codeingman.jpg</span>)</span><br></pre></td></tr></table></figure><p>效果：</p><img src="/2019/03/13/%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84markdown%E8%AF%AD%E6%B3%95/%E5%9B%BE%E7%89%87.png" class="" title="图片效果"><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">赵国阵营</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 廉颇</span><br><span class="line"><span class="bullet">-</span> 李牧</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">秦军阵营</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 蒙骜</span><br><span class="line"><span class="bullet">-</span> 白起</span><br></pre></td></tr></table></figure><p>效果：</p><img src="/2019/03/13/%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84markdown%E8%AF%AD%E6%B3%95/%E5%88%86%E5%89%B2%E7%BA%BF.png" class="" title="分割效果"><h2 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~~秦军与赵军在长平进行了一场大对决~~</span><br></pre></td></tr></table></figure><p>效果：</p><img src="/2019/03/13/%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84markdown%E8%AF%AD%E6%B3%95/%E5%88%A0%E9%99%A4%E7%BA%BF.png" class="" title="删除线效果"><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>在要展示目录的文章头部输入<code>[TOC]</code><br>效果：</p><img src="/2019/03/13/%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84markdown%E8%AF%AD%E6%B3%95/%E7%9B%AE%E5%BD%95.png" class="" title="目录效果"><h2 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">白起[^1]是战神，他曾经和赵括在长平进行战争[^2]</span><br><span class="line"></span><br><span class="line">[<span class="symbol">^1</span>]:<span class="link">秦国上将军</span></span><br><span class="line">[<span class="symbol">^2</span>]:<span class="link">杀人的机器</span></span><br></pre></td></tr></table></figure><p>效果：</p><img src="/2019/03/13/%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84markdown%E8%AF%AD%E6%B3%95/%E8%84%9A%E6%B3%A8.png" class="" title="脚注效果">]]></content>
      
      
      <categories>
          
          <category> 展现形式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdwon </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
