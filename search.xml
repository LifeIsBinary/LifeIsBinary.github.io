<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>非侵入式脑机接口落地情况报告</title>
      <link href="/2021/08/01/%E9%9D%9E%E4%BE%B5%E5%85%A5%E5%BC%8F%E8%84%91%E6%9C%BA%E6%8E%A5%E5%8F%A3%E8%90%BD%E5%9C%B0%E6%83%85%E5%86%B5%E6%8A%A5%E5%91%8A/"/>
      <url>/2021/08/01/%E9%9D%9E%E4%BE%B5%E5%85%A5%E5%BC%8F%E8%84%91%E6%9C%BA%E6%8E%A5%E5%8F%A3%E8%90%BD%E5%9C%B0%E6%83%85%E5%86%B5%E6%8A%A5%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<h2 id="写作目的"><a href="#写作目的" class="headerlink" title="写作目的"></a>写作目的</h2><p>&emsp;&emsp;本文梳理了脑机接口技术在各个领域的应用情况。通过各领域的成熟应用案例和当前学术研究进展情况，分析非侵入式脑机接口技术落地情况。</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><h3 id="脑机接口"><a href="#脑机接口" class="headerlink" title="脑机接口"></a>脑机接口</h3><p>&emsp;&emsp;<strong>脑机接口（Brain-computer interface, BCI）是在大脑与外部环境之间建立一种全新的不依赖于外周神经和肌肉的交流与控制通道，从而实现大脑与外部设备的直接交互。</strong>该技术能够在人脑与外部环境之间建立沟通以达到控制设备的目的，进而起到监测、替代、改善/恢复、增强、补充的作用。作为一门多学科交叉的研究领域，涉及神经科学、认知科学、心理学、影像医学、生物医学工程、材料科学、电子工程、信号处理与模式识别等多个学科，是一项复杂的系统工程。</p><p>&emsp;&emsp;构建一个脑机接口系统需要实现四部分功能：<strong>信号采集、信息解码、再编码和反馈。</strong>通过布置在脑部的电极采集脑电信号，经过预处理、特征提取和分类，识别出特定的脑模式。根据应用场景下脑模式或脑模式序列编码的规则，将脑模式特征转译为外部设备可理解的控制信号。用户通过反馈环节获得外部环境和设备的状态信息，形成控制——感知——控制的闭环方式。</p><p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/bci%E6%AD%A5%E9%AA%A4-20210801124547229.jpg"></p><center>图1 BCI系统示意图</center><h3 id="侵入式和非侵入式脑机接口"><a href="#侵入式和非侵入式脑机接口" class="headerlink" title="侵入式和非侵入式脑机接口"></a>侵入式和非侵入式脑机接口</h3><p>&emsp;&emsp;根据脑机接口系统信号采集时电极的布置位置，可分为侵入式脑机接口（大脑皮层或灰质处布置电极）和非侵入式脑机接口（大脑头皮处布置电极）。</p><ul><li>侵入式BCI可以直接记录神经元电活动，信号衰减小，信噪比和空间分辨率高，能够区分。但植入有创伤，技术难度大，存在继发感染的可能性。</li><li>非侵入式BCI通过附着在头皮上的穿戴设备测量大脑的电活动或代谢活动，无需手术，安全无创。其中脑电帽是最常用的非侵入式传感器，可以在头皮上监测到群体神经元的放电活动，时间分辨率高，但空间分辨率低，且受大脑容积导体效应的影响，传递至头皮表面时衰减较大，易被噪声污染，信噪比低。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/image-20210722164811563-20210801124604533.png"></p><center>图2     侵入式与非侵入式BCI电极布置位置</center><p>&emsp;&emsp;目前，非侵入式脑机接口的研究和应用占主导地位。非侵入式BCI根据采用的脑模式又可分为P300-BCI、SSVEP-BCI 和MI-BCI。</p><ul><li><p>P300-BCI：P300 是一种事件相关电位，实验证实当人脑受到小概率新奇事件刺激后300ms 左右脑电信号会出现一个正向波峰。基于P300 信号特征的脑机接口系统具有<strong>目标多、个体差异较少</strong>的优点,已被广泛研究并测试应用，需要注意的是，该类BCI 需要多次重复闪烁,而<strong>长时间的重复闪烁</strong>,会影响患者的使用体验。</p><p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/image-20210722210050859-20210801124622027.png"></p><center>图3     P300电位（红色垂直线代表出现字符w的刺激，绿色和橙色的脑电波分别代表刺激产生后有P300的脑电波和没有P300的脑电波）</center></li><li><p>SSVEP-BCI：SSVEP （视觉稳态诱发电位）是当人眼视网膜受到恒定频率（大于6HZ）的闪光或图形刺激时，会诱发大脑视觉皮层产生可记录到的电位变化，该变化与刺激频率及其谐波频率一致。基于SSVEP 的BCI 特征提取简单、准确率和<strong>信息传输率高</strong>，用户不需要训练。这类BCI 的<strong>控制命令数量受刺激频率及其他因素影响</strong>,特别是当命令数增加时，分类精度下降。</p><p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/image-20210722211214229-20210801124641132.png"></p><center>图4    SSVEP信号特征（红色实心圆圈表示不同频率的刺激源，图中的波形对应注意到刺激后产生的脑电波功率谱）</center></li><li><p>MI-BCI：MI （运动想象）是人在心理感觉一个动作过程但不发生实际运动，是一种内隐性心理活动，<strong>无需外界刺激</strong>。研究表明运动想象会在感觉运动皮层诱发事件相关去同步/同步（ERD/ERS）响应。基于运动想象脑信号特征的脑机接口系统可用于运动障碍康复训练、假肢和轮椅控制等。该类脑机接口系统的用户需要一定量的训练，其性能不仅取决于解码算法，还取决于用户的运动想象表现，此外目前<strong>可辨识的运动想象的模式有限</strong>，只有六种，很难产生数量较多的外部设备控制命令。</p><p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/image-20210722211658567-20210801124658321.png"></p><center>图5  MI信号特征（图中脑部的热力图为不同位置电极在运动想象时的电压幅值对比情况，左手运动想象时左侧脑部的电极电压幅值明显降低，右侧脑补的电极电压幅值变高。出现左侧去同步化，右侧同步化响应的情况。同理右手运动想象时会出现右侧去同步化，左侧同步化的现象）</center></li></ul><h3 id="非侵入式脑机接口应用方向"><a href="#非侵入式脑机接口应用方向" class="headerlink" title="非侵入式脑机接口应用方向"></a>非侵入式脑机接口应用方向</h3><p>脑机接口技术的功效可以归结为如下5 类：</p><ul><li>监测：使用脑机接口系统监测部分人体意识状态。</li><li>替代：脑机接口系统的输出可以取代由于损伤或疾病而丧失的自然输出。</li><li>改善/恢复：主要针对康复领域，改善某种疾病的症状或恢复某种功能。</li><li>增强：主要是针对健康人而言，实现机能的提升和扩展。</li><li>补充：主要针对控制领域，增加脑控方式，作为传统单一控制方法的补充，实现多模态控制。</li></ul><p>围绕上述5 大功效，脑机接口技术的应用方向主要有医疗健康、娱乐、智能家居和其他。</p><ol><li><p>医疗健康</p><p>&emsp;&emsp;医疗健康领域是脑机接口最初、最直接和最主要的应用领域，也是目前最接近商业化的应用领域。医疗健康领域的应用案例主要集在“监测”、“改善/恢复”、“替代”、和“增强”4 大功效上，这些主要是以输出为主狭义BCI 的功效。</p><p>&emsp;&emsp;“监测”是指通过脑机接口系统完成对<strong>人体神经系统状态的实时监控与测量</strong>。例如，脑机接口可应用于陷入深度昏迷等微小意识状态的患者，帮助测量并评定其意识等级。</p><p>&emsp;&emsp;“改善/恢复”方向主要是指可以<strong>针对中风、癫痫等疾病做对应的恢复训练</strong>。例如，对于感觉运动皮层相关部位受损的中风病人，脑机接口可以从受损的皮层区采集信号，然后刺激失能肌肉或控制矫形器，改善手臂运动。癫痫病人的大脑会出现某个区域的神经元异常放电，通过脑机接口技术检测到神经元异常放电后，可以对大脑进行相应的电刺激，从而抑制癫痫发作。</p><p>&emsp;&emsp;“替代”方向主要针对因为损伤或疾病而丧失某种功能的患者。例如，丧失说话能力的人<strong>通过脑机接口输出文字</strong>，或通过语音合成器发声。脊髓侧索硬化症患者、重症肌无力患者、以及因事故导致高位截瘫的患者等重度运动障碍患者群体，可通过脑机接口系统将自己脑中所想的信息传达出来。</p><p>&emsp;&emsp;“增强”方向主要是指将芯片植入大脑，以增强记忆、推动人脑和计算设备的直接连接等</p></li><li><p>娱乐</p><p>&emsp;&emsp;脑机接口在娱乐领域的应用主要集中在“补充”方向。例如，脑机接口为游戏玩家提供了<strong>独立于传统游戏控制方式之外的新的操作维度</strong>，可以用意念来控制虚拟现实界面的菜单导航和选项控制，极大的丰富了游戏内涵并提升了游戏体验。</p></li><li><p>智能家居</p><p>&emsp;&emsp;脑机接口在智能家居领域的应用主要集中在“补充”方向。智能家居是脑机接口与物联网跨领域结合的一大想象空间。例如，脑机接口可类似于“遥控器”，帮助人们用<strong>意念控制</strong>开关灯、开关门和开关窗帘等，进一步可以控制家庭服务机器人。</p></li><li><p>其他</p><p>&emsp;&emsp;脑机接口在其他方向的应用主要针对健康人群的“增强”和“补充”，实现机能的扩展。例如，澳大利亚的SmartCap 公司通过在棒球帽内植入电极，可以实时<strong>监测用户的疲劳状态</strong>，同时也有部分公司将脑机接口应用于驾驶状态监测，随时关注驾驶员的疲劳状态，以降低由于疲劳驾驶而发生事故的概率。在教育领域，脑机接口技术可对学生<strong>注意力表现实时探测</strong>，从而帮助教师及时了解课堂情况以改变教学方法。</p></li></ol><h2 id="非侵入式脑机接口应用案例"><a href="#非侵入式脑机接口应用案例" class="headerlink" title="非侵入式脑机接口应用案例"></a>非侵入式脑机接口应用案例</h2><h3 id="医疗健康"><a href="#医疗健康" class="headerlink" title="医疗健康"></a>医疗健康</h3><h4 id="假肢控制"><a href="#假肢控制" class="headerlink" title="假肢控制"></a>假肢控制</h4><p>&emsp;&emsp;BrainCo公司研发的BrainRobotics智能仿生手，可以通过手臂上肌肉神经信号，识别佩戴者的运动意图，再将运动意图转化成相应的运动指令，从而完成佩戴者想要完成的动作。BrainRobotics已经实现握手、抓杯子等日常操作，并且已有残疾患者通过练习实现了写毛笔字、弹钢琴等更为复杂的操作。<img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/brainRobotics-20210801124717626.gif"></p><center>图6    BrainRobotic智能仿生手</center><h4 id="康复训练"><a href="#康复训练" class="headerlink" title="康复训练"></a>康复训练</h4><p>&emsp;&emsp;专注于虚拟显示和运动捕捉的MindMaze公司，将自身技术与脑机接口结合发布了一款用于医疗商业领域的VR头显，用于中风后运动麻痹的病人恢复，并且已获得美国食品和药物管理局（FDA）批准，进入美国市场。</p><p>&emsp;&emsp;如果中风病人的左手不能动了，但右手能动，相机就会捕捉他右手的动作，然后当他试图控制左手时，会把右手的动作移植到虚拟化身的左手上，让病人观看虚拟化身的左手在动，从而欺骗病人的大脑，让大脑相信自己的左手也能动，从而提高神经的可塑性。所以，当脑机接口检测到用户的运动意图后，通过动作捕捉技术和VR技术，我们可以欺骗大脑，加速病人恢复。这就是这款VR头显中风恢复理疗的原理。<img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/1bc81b64fac44d728370584a0e97a6cb_th-20210801092700836-20210801124751087.jpg"></p><center>图7    中风恢复治疗</center><h4 id="睡眠监测"><a href="#睡眠监测" class="headerlink" title="睡眠监测"></a>睡眠监测</h4><p>&emsp;&emsp;国外InteraXon公司和国内的脑陆科技都推出了消费级的睡眠监测可穿戴EEG设备，通过分析脑电、心率、血氧和体动等睡眠过程中的重要指标，融合多模态生物信号，为用户提供精准的睡眠管理方案。展示量化的睡眠日报、周报、月报，可以随时掌握自身睡眠状态。特别是脑陆科技推出的脑电仪设备，能够将用户的睡眠脑电进行分期，分为清醒期、浅睡期、中度睡眠期、深度睡眠期和快速眼动期。采集的数据可供专业医生诊断提供参考，并且可以为后续通过粉噪音、白噪音等节律声波对神经实时调控，优化深度睡眠的应用场景提供可靠调控指标。</p><h4 id="信息表达"><a href="#信息表达" class="headerlink" title="信息表达"></a>信息表达</h4><p>&emsp;&emsp;脑机接口的一个重要应用领域是意念打字，自从1988年Farewell和Donchin提出的第一款脑机接口字符输入系统——P300 Speller开始，基于BCI的字符输入系统一直在发展迭代。目前，世界上字符输入速度最快的非侵入式BCI Speller是国内博睿康公司和清华大学合作开发的基于SSVEP的字符输入系统，该系统能够在一分钟类输入12个英文单词。该系统还处于实验室阶段，在此研究基础之上，北京邮电大学将中文双拼输入法与SSVEP字符输入系统结合，构建了基于SSVEP的中文字符输入系统。该系统目前正在产业化过程中。</p><p>![](<a href="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/SSVEP">https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/SSVEP</a> speller-20210801124833980-20210801125946676.gif)</p><center>图8    清华大学基于SSVEP的字符输入系统</center><h3 id="娱乐"><a href="#娱乐" class="headerlink" title="娱乐"></a>娱乐</h3><h4 id="面部情绪识别"><a href="#面部情绪识别" class="headerlink" title="面部情绪识别"></a>面部情绪识别</h4><p>&emsp;&emsp;位于瑞士洛桑的MindMaze公司展示了一种在VR中读取脸部情绪的设备，名为MASK。戴上集成MASK的头显后，你马上可以看到屏幕上的虚拟化身在模仿你的表情。产品的电极被安装在泡沫衬垫面板上，而这些电极可以感觉到你的面部肌肉，甚至可以在完全作出表情之前进行预测。该设备目前可以追踪的情绪有限，包括微笑、皱眉、眨眼、嘲笑和扬眉。</p><p><img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/b4b4cc6c-5ddf-4a6d-88ff-47e213f3b8f0-7499262-20210801124925673.jpg"></p><center>图9    VR中的表情识别</center><h3 id="智能家居"><a href="#智能家居" class="headerlink" title="智能家居"></a>智能家居</h3><p>&emsp;&emsp;广州华南脑控公司针对手脚及身体不便人群,打造了一套脑机智能护理应用系统。该系统能够让用户随时掌握护理床各活动部件的升降开关，实现自主控制起坐、抬腿、屈腿、翻身、便盘等。结合护理场景下的智能电器设备，对所在房间空调、窗帘、电视等家居设备进行控制<img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/IMG_1718-20210801125008237.JPG"></p><center>图10    基于BCI的智慧床控制</center>                                                        <h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="注意力实时检测"><a href="#注意力实时检测" class="headerlink" title="注意力实时检测"></a>注意力实时检测</h4><p>&emsp;&emsp;在注意力监测方面，BrainCo公司开发的一款Focus1注意力检测头环，可以实时显示佩戴者的当前的注意水平。该产品可用于教育领域，对于学生上课专注的评估，便于教师根据学生对于课堂的接收情况来作出课程的调整。同时也能够通过实时注意力评估值，进行一些注意力集中的调控行为如冥想，帮助学生调整状态以进入最佳的状态，更好的进行课程学习。目前该产品已经销售往15个国家，近15000名学生使用。<img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/image-20210723152007427-20210801124941112-20210801125050909.png"></p><center>图11    BrainCo公司注意力监测头环</center><p>&emsp;&emsp;系统主要用于课堂上使用，分为课前、课中、课后以及常态训练四个阶段。上课之前老师给学生发放头环，打开 Focus EDU 系统，连接网络；然后依次进行不超过三分钟的冥想训练和神经反馈训练，之后进行正常课堂授课，课堂结束后取下头环。老师可以通过BrainCo提供的教育训练平台查看学生一周内的平均专注力报告，来及时作出课程的调整。</p><h4 id="疲劳状况监测"><a href="#疲劳状况监测" class="headerlink" title="疲劳状况监测"></a>疲劳状况监测</h4><p>&emsp;&emsp;脑陆科技提出的BCI智慧安全帽，是一款在传统安全帽或智能安全帽上集成脑机接口的新型智能终端设备。在完成安全防护的同时，对人的精神不安全状况和生理状况进行监测，实时进行安全预警，提升安全管理技术手段。</p><p>&emsp;&emsp;该设备中集成了EEG（脑电图）和fNRIS（功能性性近红外光谱）信号采集传感器，能够对佩戴的疲劳状况、注意力状况、脑血氧、心率和血压进行监测。可以对佩戴者的疲劳和注意力不集中情况进行报警，同时针对使用者缺氧、供血不足、脉搏紊乱和中毒等威胁生命的突发状况进行通报，通过GPS定位来确定佩戴者方位进行及时的抢救措施，保证工作人员施工过程中的生命安全。<img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/image-20210723154806314-20210801125127878.png"></p><center>图12    脑陆科技BCI智慧安全帽的结构功能图</center><h2 id="非侵入式脑机接口成熟技术"><a href="#非侵入式脑机接口成熟技术" class="headerlink" title="非侵入式脑机接口成熟技术"></a>非侵入式脑机接口成熟技术</h2><h3 id="基于脑电的生理情况监测"><a href="#基于脑电的生理情况监测" class="headerlink" title="基于脑电的生理情况监测"></a>基于脑电的生理情况监测</h3><h4 id="睡眠评估"><a href="#睡眠评估" class="headerlink" title="睡眠评估"></a>睡眠评估</h4><p>&emsp;&emsp;可穿戴睡眠监测设备最常使用的信号是脑电图 (EEG) 和光电容积脉搏波 (PPG)。相比与PPG基于 EEG 的系统是最准确的，并且能够识别所有睡眠阶段。 基于EEG的睡眠分期系统能够<strong>实现 80-90% 之间的分类准确率</strong>。目前，多通道信号对于睡眠评估具有优势，但单通道脑电图睡眠分期也取得了很好的性能（针对所有睡眠阶段分期准确率最高可达到86.2%）。单通道EEG设备便于佩戴且成本相对较低，容易普及，<strong>能够满足家庭睡眠评估，用于早期诊断和持续监测</strong>。</p><h4 id="注意力监测"><a href="#注意力监测" class="headerlink" title="注意力监测"></a>注意力监测</h4><p>&emsp;&emsp;大脑的神经振荡是指中枢神经系统自发产生的有节奏的脑电活动，有alpha, theta, delta, gamma等。其中的 alpha和 theta 波段活动与情绪和注意力状态有关。在注意力方面，脑电信号的alpha波段功率与其呈正相关，而脑电信号的θ波段功率同时呈负相关。目前，在研究中使用多通道采集设备结合机器学习算法对注意力的分类准确率达到91.72%。但具有注意力监测功能的产品都是单通道，单通道设备注意力监测的分类准确率平均在80%左右。并且注意力监测的准确率会因使用者不同任务情景（如阅读，听讲，计算），而存在10%左右的波动。</p><h4 id="疲劳程度监"><a href="#疲劳程度监" class="headerlink" title="疲劳程度监"></a>疲劳程度监</h4><p>&emsp;&emsp;根据人在昏昏欲睡时α波和β波减少，而θ波保持不变这一生理特征，可通过监测 EEG 频带的功率谱的变化来检测受试者的困倦情况。目前拥有困倦程度的监测设备很多，Emotiv公司的Epoc、Neurosky的MindWave、OpenBCI 和 InteraXon公司的Muse产品都具有困倦疲劳监测功能。2020年Jones 和 Minh Dong Le写了一篇简短的文章，回顾了几种低成本 EEG 设备及其检测睡意的能力。其中MindWave设备的监测准确度波动最大，波动最小的设备为OpenBCI，<strong>平均准确率为79.4%<strong>。尽管这些系统没有达到研究级或医疗级系统的准确度，但它们</strong>足以部署在某些环境中</strong>。例如，这些系统可以用于发展中国家的小型企业或迫切需要易于获得的困倦检测的劳务派遣公司等。2016年，Wilaiprasitporn 和 Yagi提出了将 EEG 的睡意检测系统集成到防护或职业头盔中的想法。国内的脑陆科技公司根据这一思路实现了一款BCI智慧安全帽，除了加入EEG监测技术外还增加了对佩戴者头部血氧浓度的监测，能够进行疲劳、中毒、缺氧和供血不足等特殊生理状况监控预警。</p><h3 id="基于BCI的外设交互"><a href="#基于BCI的外设交互" class="headerlink" title="基于BCI的外设交互"></a>基于BCI的外设交互</h3><h4 id="基于BCI的字符输入系统"><a href="#基于BCI的字符输入系统" class="headerlink" title="基于BCI的字符输入系统"></a>基于BCI的字符输入系统</h4><p>&emsp;&emsp;非侵入式字符输入系统一直是BCI领域的研究重点。从字符分布界面的设计到采用的刺激范式一些系列的优化与提高，到目前为止基于非侵入式字符输入系统的输入速率还远远达不到正常人的平均水平，仅仅为每分钟40字符（准确率达到91.5%），而正常人的水平为115个字符。因此基于该技术的系统大多还处于实验室阶段或者实验室到商业产品的转换阶段。目前基于BCI技术的字符输入系统中最接近人类输入速度的斯坦福教授Krishna Shenoy发表于《Nature》上的基于侵入式BCI的笔记想象字符输入系统，该系统能够达到每分钟输入90个字符，并且识别准确率高达99%。该系统的速度与在智能手机上打字的速度相当，是BCI字符输入系统领域的重大突破。目前影响该技术应用的是目前侵入式BCI技术还不够成熟，芯片植入后的风险以及后续的维护更换都是待解决的问题。<img src="https://cdn.jsdelivr.net/gh/LifeIsBinary/Picbed/8db6-kpzzqmz7958767-20210801125225097.gif"></p><center>图13    基于笔记想象的侵入式BCI字符输入系统</center><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;BCI技术最重要的应用是医疗领域，而目前医疗领域非侵入BCI最成熟的技术之一是基于EEG信号生理信息监测，睡眠监测、疲劳状况监测、注意力监测等。在从科研和医疗领域向大众市场的下放的过程中，考虑到便携性、可穿戴性和成本等多方因素，相关设备都牺牲了多通道信号源，采用单通道信号来进行后续一些应用场景分析。这使得产品的准确性和鲁棒性与研究和医疗领域有所差距，但是已经能够用于日常的使用。这类产品面临广泛的使用人群，相比于科研和医疗领域的相对单一可控的使用环境，面临复杂多变环境下的可靠性是产品体验的重要环节。目前由于产品推出不久，还没有广泛的使用人群并形成可靠权威的产品体验报告。</p><p>&emsp;&emsp;作为BCI技术诞生不久后，一直研究的字符输入系统，技术相对成熟，2018清华大学提出的SSVEP字符输入系统每分钟可以输入40个字符，但是目前迟迟没有产品推出，主要还是基于SSVEP的系统对于字符输入这种长时间的任务，不同频率的闪烁刺激方式容易产生疲劳，整体体验还有待优化。而针对BCI的智慧家居、假肢的控制以及基于虚拟现实的康复训练，目前只有极少的公司有产品化。</p><p>&emsp;&emsp;从产品的成熟度来看，脑机接口技术处于初级阶段，未来尚需更加完善的制度和标准来规范产品上市进程，对产品的安全性、有效性进行合理全面的认证。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><p>Current and Future Brain-Computer Interface，Christoph Guger，g.tech medical engineering (2021).</p></li><li><p>Imtiaz, Syed Anas. “A Systematic Review of Sensing Technologies for Wearable Sleep Staging.” Sensors 21.5 (2021): 1562.</p></li><li><p>Yang, Chen, et al. “A dynamic window recognition algorithm for SSVEP-based brain–computer interfaces using a spatio-temporal equalizer.” International journal of neural systems 28.10 (2018): 1850028.</p></li><li><p>LaRocco, John, Minh Dong Le, and Dong-Guk Paeng. “A systemic review of available low-cost EEG headsets used for drowsiness detection.” Frontiers in neuroinformatics 14 (2020).</p></li><li><p>Mohammadpour, Mostafa, and Saeed Mozaffari. “Classification of EEG-based attention for brain computer interface.” 2017 3rd Iranian Conference on Intelligent Systems and Signal Processing (ICSPIS). IEEE, 2017.</p></li><li><p>Wang, Bingbing, et al. “EEG-Based Closed-Loop Neurofeedback for Attention Monitoring and Training in Young Adults.” Journal of Healthcare Engineering 2021 (2021).</p></li><li><p>Willett, Francis R., et al. “High-performance brain-to-text communication via handwriting.” Nature 593.7858 (2021): 249-254.</p></li><li><p>伏云发,郭衍龙, 张夏冰, 李松. 脑-机接口—革命性的人机交互[译]. 北京:国防工业出版社, 2020.</p></li><li><p>伏云发,丁鹏,罗建功,吕晓彤.脑-计算机接口[译]. 国防工业出版社,北京,2021.</p></li><li><p>李静雯, 王秀梅. 脑机接口技术在医疗领域的应用[J]. 信息通信技术与政策, 2021,47(2):87-91.</p></li><li><p>脑机接口技术在医疗健康领域应用白皮书. 中国人工智能产业发展联盟”,2021.</p></li><li><p><a href="https://zhuanlan.zhihu.com/p/28584797">意念打字、心灵控制、大脑永生…这不是科幻大片，这是过去一年「脑机接口」领域的重磅突破！</a></p></li><li><p><a href="https://space.bilibili.com/1262597880/video?tid=0&page=1&keyword=&order=pubdate">g.tec 脑电产品中国区总代理</a></p></li></ol><p>  ​    </p><p>  ​    </p>]]></content>
      
      
      
        <tags>
            
            <tag> 脑机接口 </tag>
            
            <tag> BCI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zoella Cooking笔记之——简餐挂面</title>
      <link href="/2021/07/31/Zoella-Cooking%E7%AC%94%E8%AE%B0%E4%B9%8B%E2%80%94%E2%80%94%E7%AE%80%E9%A4%90%E6%8C%82%E9%9D%A2/"/>
      <url>/2021/07/31/Zoella-Cooking%E7%AC%94%E8%AE%B0%E4%B9%8B%E2%80%94%E2%80%94%E7%AE%80%E9%A4%90%E6%8C%82%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<p><code>首先</code>是挂面的选择。</p><p>不同的挂面吸水性不同，容易吸水的后面需要加水和盐。<img src="https://raw.githubusercontent.com/LifeIsBinary/Picbed/main/different_noodle.jpg"></p><p>面，中火不盖锅盖煮<strong>五分钟</strong>即可。</p><h3 id="挂面调料"><a href="#挂面调料" class="headerlink" title="挂面调料"></a>挂面调料</h3><p><code>接着</code>主戏——挂面调料：</p><ol><li>两勺生抽</li><li>一勺四川熟油辣子</li><li> 半勺或一勺醋</li><li>一勺花椒油</li><li>加盐</li><li>一小块猪油</li></ol><p>以上调制完成，加入煮面的水，根据咸淡，添加水或盐。</p><p><code>然后</code>，煮五分钟的面，捞入调制好的汤中，加入葱花。</p><p><img src="https://raw.githubusercontent.com/LifeIsBinary/Picbed/main/noodles.jpg"></p><p><code>最后</code>，开始享用喽～</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.youtube.com/watch?v=TBLF9oBab9k&t=116s">会做这三碗面，我就还能再宅一个月🍜川妹子最爱的三种挂面调料</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 简餐 </tag>
            
            <tag> 挂面 </tag>
            
            <tag> Zoella Cooking </tag>
            
            <tag> 做饭 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机试——字符串、排序与查找</title>
      <link href="/2020/03/29/%E6%9C%BA%E8%AF%95%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E5%8A%9F/"/>
      <url>/2020/03/29/%E6%9C%BA%E8%AF%95%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E5%8A%9F/</url>
      
        <content type="html"><![CDATA[<h4 id="C-中字符串"><a href="#C-中字符串" class="headerlink" title="C++中字符串"></a>C++中字符串</h4><ol><li><p>string 的基本使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;isotream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string str,str1 = <span class="string">&#x27;OK&#x27;</span>; <span class="comment">/*定义string类型变量*/</span></span><br><span class="line">    cin&gt;&gt;str;  <span class="comment">//输入</span></span><br><span class="line">    str.<span class="built_in">size</span>() <span class="comment">// string类型变量长度</span></span><br><span class="line">    cout&lt;&lt;str&lt;&lt;endl;   <span class="comment">//输出</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;str.<span class="built_in">size</span>(); i++)&#123;   <span class="comment">//像数组一样访问元素</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,str[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    str.<span class="built_in">insert</span>(str.<span class="built_in">size</span>(),<span class="string">&quot;...&quot;</span>);  <span class="comment">//从当前下标开始插入   </span></span><br><span class="line">    str.<span class="built_in">erase</span>(<span class="number">0</span>,<span class="number">5</span>); <span class="comment">//删除下标从0～5的元素 </span></span><br><span class="line">    str.<span class="built_in">erase</span>(<span class="number">2</span>);</span><br><span class="line">    str.<span class="built_in">clear</span>(); <span class="comment">//str置空</span></span><br><span class="line"></span><br><span class="line">    str = str + <span class="string">&#x27;hello&#x27;</span>; <span class="comment">//字符串连接</span></span><br><span class="line">    str = str + str1;</span><br><span class="line">    str.<span class="built_in">find</span>(<span class="string">&quot;ok&quot;</span>); <span class="comment">// 在字符串中查找字符串或者字符 如果找不到返回 string::npos</span></span><br><span class="line">    str.<span class="built_in">sbustr</span>(<span class="number">2</span>,<span class="number">4</span>); <span class="comment">//返回str中下标从2开始的四个字符组成的子串</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>对于需要获取一行的字符串（含空格），需要使用getline</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string str;</span><br><span class="line"><span class="built_in">getline</span>(cin,str);</span><br></pre></td></tr></table></figure></li></ol><p>例子：</p><p>在情报传递过程中，为了防止情报被截获，往往需要对情报用一定的方式加密，简单的加密算法虽然不足以完全避免情报被破译，但仍然能防止情报被轻易的识别。我们给出一种最简的的加密方法，对给定的一个字符串，把其中从a-y,A-Y的字母用其后继字母替代，把z和Z用a和A替代，则可得到一个简单的加密字符串。</p><p>输入一行字符串，输出对该字符串加密的结果</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">incode</span><span class="params">(string str)</span></span>&#123;</span><br><span class="line">    string incodeStr;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>( (<span class="string">&#x27;a&#x27;</span>&lt;=str[i]  &amp;&amp; str[i]&lt;=<span class="string">&#x27;y&#x27;</span>) || (<span class="string">&#x27;A&#x27;</span>&lt;=str[i]  &amp;&amp; str[i]&lt;=<span class="string">&#x27;Y&#x27;</span>) )&#123;</span><br><span class="line">            incodeStr += str[i]+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (str[i] == <span class="string">&#x27;z&#x27;</span> || str[i] == <span class="string">&#x27;Z&#x27;</span>)&#123;</span><br><span class="line">            incodeStr += str[i]<span class="number">-25</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            incodeStr += str[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> incodeStr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(cin,str))&#123;</span><br><span class="line">        cout&lt;&lt;<span class="built_in">incode</span>(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><ol><li>c++内部基于快速排序的函数——sort<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sort</span>(first,last,comp); <span class="comment">// first,last 起始地址、结束地址， 排序方式定义的函数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>如果sort中的 比较函数comp 返回 true, 则排序时会将比较函数comp的第一个参数置于第二个参数前。<br>例子： 用一位数组存储学生的学号和成绩，然后按成绩排序输出</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">Student arr[MAXN];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Compare</span><span class="params">(Student a, Student b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.score == b.score)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.number &lt; b.number;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.score &lt; b.score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;arr[i].number,&amp;arr[i].score);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(arr,arr+n,Compare);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,arr[j].number,arr[j].score);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><p>机试中最常见的查找是二分查找<br>二分查找的前提是有序，二分查找的思想是： 对于当前要查找的数，与有序序列中中间位置的数与之做比较：</p><p> a. 如果大于要查找的数，则从小于中间位置的序列中再使用该方法查找。</p><p> b. 如果小于要查找的数，则从大于中间位置的序列中再使用该方法查找。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在长度位n的有序数组arr中查找x,返回查找到的下标</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch</span><span class="params">(<span class="keyword">int</span> arr,<span class="keyword">int</span> n,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">        <span class="keyword">int</span> middle = (low+high)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(arr[middle] == x)&#123;</span><br><span class="line">            <span class="keyword">return</span> middle;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[middle] &lt; x)</span><br><span class="line">            low = middle + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            high = middle - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 机试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 研究生复试上机题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机试--数学问题</title>
      <link href="/2020/03/29/%E6%9C%BA%E8%AF%95-%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98/"/>
      <url>/2020/03/29/%E6%9C%BA%E8%AF%95-%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>机试中，有一些与数字相关的题目： 进制转换、最大公约数、最小公倍数、素数、高进度整整数运算（无法用数值类型变量直接存储）。本文对于这几个部分的一些常见题，进行归纳总结。</p><span id="more"></span><h3 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h3><ol><li>整数二进制方式显示 [北邮上机题]</li></ol><blockquote><p>十进制转二进制，使用除留取余法，注意余数的先后顺序与该数二进制顺序相反，因此将余数按顺序存放，逆序输出即可</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span>   <span class="comment">//容器，可变长度的&quot;数组&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bit</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; NumBit;</span><br><span class="line">    <span class="keyword">int</span> BitNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(num != <span class="number">0</span>)&#123;</span><br><span class="line">        NumBit.<span class="built_in">push_back</span>(num % <span class="number">2</span>);</span><br><span class="line">        num /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = NumBit.<span class="built_in">size</span>()<span class="number">-1</span>; i &gt;= <span class="number">0</span> ; i--) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,NumBit[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    string s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num);</span><br><span class="line">        <span class="built_in">Bit</span>(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>大型正整数二进制显示 [清华上机题]</li></ol><blockquote><p>在C与C++中较大的整数无法存储进行直接的算数运算。因此，对于大数的处理一般需要使用字符串的方法。本题与上一题有相似之处，只是本题的数据无法存储，因此无法进行算术的除、取余操作。可以通过定义字符串的方式，实现字符串数字的除法、取余。进而套用上一题的方法。</p></blockquote><blockquote><p>对于字符串的：</p><ol><li>取余操作： 只需取当前字符串的最后一位做算术的取余操作，其结果即是整个字符串数的取余结果。</li><li>除法操作： 与我们平时在草稿纸上算的步骤一样，依次从高到低对字符串数的每个元素进行：<br> 除2 、 取余操作。 即可得到该字符串数除2的结果字符串。<strong>该过程中注意：取余的目的是为了，在下次除操作前，将上一位的余数与当前为合并作为被除数。 对于除完后的结果中可能前几位是0，需要去掉多余的0，方便除留取余法推出循环。</strong></li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">string <span class="title">divide</span><span class="params">(string num, <span class="keyword">int</span> divider)</span></span>&#123;  <span class="comment">//字符串除法</span></span><br><span class="line">    string answer; <span class="comment">//商</span></span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>; <span class="comment">//上一位的余数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;num.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> dividend = num[i]-<span class="string">&#x27;0&#x27;</span> + carry*<span class="number">10</span> ;</span><br><span class="line">        answer += (<span class="string">&#x27;0&#x27;</span> + dividend / divider);   </span><br><span class="line">        carry = dividend % divider; <span class="comment">//取余</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> post = <span class="number">0</span>; <span class="comment">//标示answer中不为0的第一个数字字符【重要】</span></span><br><span class="line">    <span class="keyword">while</span> (answer[post] == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">        post++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> answer.<span class="built_in">substr</span>(post);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printBit</span><span class="params">(string sNum)</span></span>&#123; <span class="comment">//十进制转二进制</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; NumBit;</span><br><span class="line">    <span class="keyword">while</span>(sNum.<span class="built_in">size</span>() != <span class="number">0</span>)&#123;</span><br><span class="line">        NumBit.<span class="built_in">push_back</span>((sNum[sNum.<span class="built_in">size</span>()<span class="number">-1</span>]-<span class="string">&#x27;0&#x27;</span>) % <span class="number">2</span>);</span><br><span class="line">        sNum = <span class="built_in">divide</span>(sNum,<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=NumBit.<span class="built_in">size</span>()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,NumBit[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string sNum;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; sNum)&#123;</span><br><span class="line">        <span class="built_in">printBit</span>(sNum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>求一个十进制数的逆序数。[清华机上机题]<blockquote><p>逆序数：对于一个十进制数A，将A转换为二进制数，然后按位逆序排列，再转换为十进制数B，我们称B为A的二进制逆序数。例如对于十进制数173，它的二进制形式为10101101，逆序排列得到10110101，其十进制数为181，181即为173的二进制逆序数。</p></blockquote></li></ol><blockquote><p>本题与上一题，有一定的联系。将大数的十进制（字符串形式）转换为二进制【上题内容】，接下来需要：将得到的二进制转换成新的大数的十进制（字符串形式）。</p><p>转换过程中涉及到： 字符串数与一位整数的 加法 和 乘法</p><ol><li>加法： 将加数作为低位的进位，从<strong>后向前</strong>遍历字符串数的每一个位： 当前位与进位相加，对10取余为求加法结果，对10取模为当前位加法向上一位的进位。<strong>注意即使进位为0，也要继续遍历高位，进行求和操作。否则结果会丢失高位信息。</strong>。如果加法遍历完后，最高位有进位需要给结果修正：最高位补1。</li><li>乘法： 对于被乘数进行从后向前遍历：当前位乘上乘数并加上后一位的进位，对10取余为乘法结果，对10取模为进位。如果最高位有进位，结果和加法一样需要类似的修正。</li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">divide</span><span class="params">(string sNum,<span class="keyword">int</span> divider)</span></span>&#123;   <span class="comment">//字符串除法</span></span><br><span class="line">    string answer; <span class="comment">//最后除的结果--商</span></span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>; <span class="comment">//上一位的余数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;sNum.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> dividend = (sNum[i]-<span class="string">&#x27;0&#x27;</span>) + carry*<span class="number">10</span>; <span class="comment">//当前位的被除数</span></span><br><span class="line">        answer += (<span class="string">&#x27;0&#x27;</span>+ (dividend / divider)); <span class="comment">//当前位的商</span></span><br><span class="line">        carry = dividend % <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> post = <span class="number">0</span>; <span class="comment">//商字符串中不为0的第一字符位置</span></span><br><span class="line">    <span class="keyword">while</span>(answer[post] == <span class="string">&#x27;0&#x27;</span>)&#123;    <span class="comment">//去除结果中前面多余的0</span></span><br><span class="line">        post++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> answer.<span class="built_in">substr</span>(post);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">multiple</span><span class="params">(string sNum,<span class="keyword">int</span> factor)</span></span>&#123;  <span class="comment">//字符串乘法</span></span><br><span class="line">    string answer;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=sNum.<span class="built_in">size</span>()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = (sNum[i]-<span class="string">&#x27;0&#x27;</span>)  * factor + carry;</span><br><span class="line">        answer = <span class="built_in"><span class="keyword">char</span></span>(<span class="string">&#x27;0&#x27;</span>+(temp % <span class="number">10</span>)) + answer;   <span class="comment">//从低位到高位分别乘二得到结果</span></span><br><span class="line">        carry = temp / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(carry == <span class="number">1</span>)&#123;     <span class="comment">//因为乘的是2，所以进位只能是1</span></span><br><span class="line">        answer = <span class="string">&#x27;1&#x27;</span> + answer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">add</span><span class="params">(string sNum, <span class="keyword">int</span> adder)</span></span>&#123;</span><br><span class="line">    string answer;</span><br><span class="line">    <span class="keyword">int</span> carry = adder;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=sNum.<span class="built_in">size</span>()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = sNum[i]-<span class="string">&#x27;0&#x27;</span> + carry; <span class="comment">//把要加的一位整数（0或1）当成当前位后一位的进位</span></span><br><span class="line">        carry = temp / <span class="number">10</span>;</span><br><span class="line">        answer = <span class="built_in"><span class="keyword">char</span></span>(<span class="string">&#x27;0&#x27;</span> +temp%<span class="number">10</span>) + answer ;  <span class="comment">//需要进行类型转换，否则无法将int型并入字符串</span></span><br><span class="line">        <span class="comment">//if(carry == 0) 没有进位，加法依然要继续，否则丢失高位值</span></span><br><span class="line">        <span class="comment">//    break;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(carry == <span class="number">1</span>)&#123; <span class="comment">//最高位有进位</span></span><br><span class="line">        answer = <span class="string">&quot;1&quot;</span> + answer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printInvertBinNum</span><span class="params">(string sNum)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//十进制字符串 转 二进制</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; InvertBinary;</span><br><span class="line">    <span class="keyword">while</span>(sNum.<span class="built_in">size</span>() != <span class="number">0</span>)&#123;</span><br><span class="line">        InvertBinary.<span class="built_in">push_back</span>( (sNum[sNum.<span class="built_in">size</span>()<span class="number">-1</span>]-<span class="string">&#x27;0&#x27;</span>) % <span class="number">2</span> ); <span class="comment">//取余</span></span><br><span class="line">        sNum = <span class="built_in">divide</span>(sNum,<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//二进制 转 十进制字符串</span></span><br><span class="line">    string answer = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;InvertBinary.<span class="built_in">size</span>(); i++)&#123;  <span class="comment">//对于求二进制逆序数来说： InvertBinary中保存的是逆序数的正序二进制</span></span><br><span class="line">        answer = <span class="built_in">multiple</span>(answer,<span class="number">2</span>); <span class="comment">//对于中间结果右移一位</span></span><br><span class="line">        answer = <span class="built_in">add</span>(answer,InvertBinary[i]); <span class="comment">//加上低位的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; answer.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,answer[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string sNum;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;sNum)&#123;</span><br><span class="line">        <span class="built_in">printInvertBinNum</span>(sNum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>M进制转N进制<blockquote><p>由于M，和N的值都有可能大于10，所以有字符串的形式存储M进制数和N进制数。因此需要现将M进制的数转换为数值形式，这里将其转换为我们熟悉的十进制是一种常见的方式，通过十进制作为两种不同进制字符串形式转换的桥梁。即 M进制字符串形式 –&gt; 十进制数值形式 –&gt; N进制字符串形式。在其中注意一些细节问题，如需要将高于10进制的数中的英文字符转换为数字，将高于10的数字转换为英文字符。这是于小于10的进制转换所不需要考虑的问题。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CharToInt</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&#x27;0&#x27;</span>&lt;=c &amp;&amp; c&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c-<span class="string">&#x27;A&#x27;</span>+<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">IntToChar</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x&lt;<span class="number">10</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;0&#x27;</span>+x;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x<span class="number">-10</span> + <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m,n;</span><br><span class="line">    string str,Nmum;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;m,&amp;n)) &#123;</span><br><span class="line">        cin &gt;&gt; str;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); ++i) &#123;  <span class="comment">//M进制转为10进制</span></span><br><span class="line">            number *= m;</span><br><span class="line">            number += <span class="built_in">CharToInt</span>(str[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="keyword">char</span>&gt; answer;</span><br><span class="line">        <span class="keyword">while</span>(number != <span class="number">0</span>)&#123;</span><br><span class="line">            answer.<span class="built_in">push_back</span>(<span class="built_in">IntToChar</span>(number%n));</span><br><span class="line">            number /= n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = answer.<span class="built_in">size</span>()<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, answer[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>进制转换的问题，最为重要的是转换的方法： 1.正向除留取余法，2.逆向移位求和法。 注意在做两种运算的过程中1的输出、2的输入的数据的顺序与正常情况下的相反。<br>在此基础之上，有时需要考虑到输入数据的方式：</p><ol><li>由于高于10进制，存储使用字符串方便。对于这种可以想办法把输入转为10进制数值，根据题目要求作处理。</li><li>需要输入的数远大于数值类型的存储范围，使用字符串存储。对于该类数据的运算，不能使用数值型，因为无法存储中间结果。需要实现字符串级别的“算术运算”。要注意定义运算过程中的一些细节，如运算后结果的修正，考虑最高位进位问题等。</li></ol><h3 id="最大公约数与最小公倍数"><a href="#最大公约数与最小公倍数" class="headerlink" title="最大公约数与最小公倍数"></a>最大公约数与最小公倍数</h3><p>这种题需要对于最大公约数和最小公倍数的判别方法熟悉。</p><h4 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h4><blockquote><p>对于 a, b 两数，求其最大公约数的思路是：</p><ol><li>把求   a, b的最大公约数 —&gt;  b, a%b的最大公约数  （数学推理过程略） <strong>注意b作为除数不能为0</strong></li><li>这样不断递归的缩小范围，直到求 某个数与0 的最大公约数，即非0数为最大公约数</li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxFactor</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">MaxFactor</span>(b,a%b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m,n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;m,&amp;n)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in">MaxFactor</span>(m,n));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="最小公倍数"><a href="#最小公倍数" class="headerlink" title="最小公倍数"></a>最小公倍数</h4><p>求最小公倍数思路是基于最大公约数的：<br>    a,b 的最小共倍数是  a*b / 最大公约数</p><h3 id="质数-素数"><a href="#质数-素数" class="headerlink" title="质数/素数"></a>质数/素数</h3><blockquote><p>质数或者素数a： 只能被1和本身整出的<strong>正整数</strong>（小于2的数一定不是素数）。 用所有小于sqrt(a)的数除a,如果存在整除的情况则不是素数。</p></blockquote><h4 id="判断一个数是否为素数"><a href="#判断一个数是否为素数" class="headerlink" title="判断一个数是否为素数"></a>判断一个数是否为素数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">JudgeSuNum</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">2</span>)&#123;                <span class="comment">//小于2的数一定不是素数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> bound = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; bound; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n%i == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in">JudgeSuNum</span>(n));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于一定大范围的数，判断其是否为素数，对于每一个数遍历判别，显然是有些耗时，效率不高。是否有更好的方法呢？——-素数筛选法</p><p>素数筛选法的思想是：假设当前大于1的数都为素数，遍历所有数，用已确定的素数，去标记后面是该素数倍数的数为非素数。通过选出不是素数的数，剩余的则是素数。</p><h4 id="输出1到给定n之间的素数"><a href="#输出1到给定n之间的素数" class="headerlink" title="输出1到给定n之间的素数"></a>输出1到给定n之间的素数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10001</span>;</span><br><span class="line"><span class="keyword">bool</span> isPrime[MAXN];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; prime;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Initial</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXN; ++i) &#123;</span><br><span class="line">        isPrime[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    isPrime[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">    isPrime[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; MAXN; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!isPrime[j])&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        prime.<span class="built_in">push_back</span>(j);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = j*j; i &lt; MAXN; i+=j) &#123;  <span class="comment">//从当前素数j的j倍开始，小于j的倍数的数 由 小于j的素数标记。i的“自增”为j的倍数</span></span><br><span class="line">            isPrime[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Initial</span>();</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n) != EOF) &#123;</span><br><span class="line">        <span class="keyword">bool</span> isOutput = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prime.<span class="built_in">size</span>() &amp;&amp; prime[i]&lt;n; ++i) &#123;</span><br><span class="line">            isOutput = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,prime[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!isOutput)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分解质因数"><a href="#分解质因数" class="headerlink" title="分解质因数"></a>分解质因数</h3><p>给定一个数N（1&lt;N&lt;1E9），将其分解为多个质因数相乘  </p><blockquote><ol><li>分解质因数，需要用到上题素数筛选法，通过素数筛选法确定 1～sqrt(1E9)+1 之间的素数。</li><li>遍历素数序列： 用素数取整除 N，如果成功则为N的质因数，输出。直到 所有的素数都遍历结束。</li><li>遍历结束后需要判断 N 整除前面得到的质因数的结果是否大于1，如果大于一，则存在大于 sqrt(1E9)+1的质因数。需要输出。</li></ol><p><strong>（对于N来说之多存在一个大于 sqrt(n）的质因数）</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">40000</span>;</span><br><span class="line"><span class="keyword">bool</span> isPrime[MAXN];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; prime;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Initial</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXN; ++i) &#123;</span><br><span class="line">        isPrime[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    isPrime[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">    isPrime[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; MAXN; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!isPrime[j])&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        prime.<span class="built_in">push_back</span>(j);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = j*j; i &lt; MAXN; i=i+j) &#123;  <span class="comment">//从当前素数j的j倍开始，小于j的倍数由小于j的素数标记其不为素数。i 的值为j的倍数</span></span><br><span class="line">            isPrime[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Initial</span>();</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n) != EOF) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prime.<span class="built_in">size</span>() &amp;&amp; prime[i]&lt;=n; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span>(n%prime[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,prime[i]);</span><br><span class="line">                n /= prime[i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">1</span>)&#123;   <span class="comment">//未出尽的数大于则是素因数</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><p>对于 a^b 的快速算法思路：</p><blockquote><p>将b分解为若干个2^k的和  如： 3^29 ,  其中b为29 = 1 + 4 + 8 + 16;</p><p>a^b = a^k1 * a^k2 * … * a^km,  3^29 = 3^1 * 3^4 * 3^8 * 3^16;</p><p>这样       3^1 = 3</p><pre><code>      3^2 = 3^1 * 3^1      一次计算         3^4 = 3^2 * 3^2      二次计算         3^8 = 3^4 * 3^4      三次计算          3^16 = 3^8 * 3^8     四次计算</code></pre></blockquote><blockquote><pre><code>      3^29 只需要计算四次   普通乘法需要29次</code></pre></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">aEb</span><span class="params">(<span class="keyword">long</span> a, <span class="keyword">long</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> answer = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(b != <span class="number">0</span>)&#123;     </span><br><span class="line">        <span class="keyword">if</span>(b%<span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">            answer *= a;</span><br><span class="line">        &#125;</span><br><span class="line">        b /= <span class="number">2</span>;        </span><br><span class="line">        a *= a;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b) != EOF) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,<span class="built_in">aEb</span>(a,b));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="高精度整数运算C-类是现实"><a href="#高精度整数运算C-类是现实" class="headerlink" title="高精度整数运算C++类是现实"></a>高精度整数运算C++类是现实</h3><blockquote><p>高进度数之所以不好处理的在于无法存储。一般有两种比较常见的处理方式： </p><ol><li> 用字符串存储</li><li> 用数组存储</li></ol><p>用字符串存储，在编写相应的算术运算实现时，对字符串操作由于字符串的长度不一，两个高进度整数运算时需要考虑具体的处理问题比较多。用数组存储，好处是通过指定存储数组的空间，算术运算实现时，不需要考虑太多运算过程中的数的长度的影响，因为为存储数的数组元素中的大于数长度的部分值置为0，便于大数与小数的运算。确点是需要实现分配容纳数的大量空间，利用效率不一定高。</p></blockquote><p>一下的算法是基于数组存储高进度整数的。<strong>数组存储以十进制的方式，从0～MAXN的下标依次存储数的个位、十位、百位、….</strong></p><ol><li><p>高进度整数表示的类定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN  = <span class="number">10000</span>;  <span class="comment">//最大能存储的10进制数的位数</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BigInteger</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> digit[MAXN];  <span class="comment">//从0～MAXN 存放数字的 个位 十位 百位 ...</span></span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">BigInteger</span>();</span><br><span class="line">    <span class="built_in">BigInteger</span>(<span class="keyword">int</span> x);</span><br><span class="line">    <span class="built_in">BigInteger</span>(string str);</span><br><span class="line">    <span class="built_in">BigInteger</span>(<span class="keyword">const</span> BigInteger&amp; b);</span><br><span class="line">    BigInteger <span class="keyword">operator</span>=(<span class="keyword">int</span> x);</span><br><span class="line">    BigInteger <span class="keyword">operator</span>=(string str);</span><br><span class="line">    BigInteger <span class="keyword">operator</span>=(<span class="keyword">const</span> BigInteger&amp; b);</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;=(<span class="keyword">const</span> BigInteger&amp; b);</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> BigInteger&amp; b);</span><br><span class="line"></span><br><span class="line">    BigInteger <span class="keyword">operator</span>+(<span class="keyword">const</span> BigInteger&amp; b);</span><br><span class="line">    BigInteger <span class="keyword">operator</span>-(<span class="keyword">const</span> BigInteger&amp; b);</span><br><span class="line">    BigInteger <span class="keyword">operator</span>*(<span class="keyword">const</span> BigInteger&amp; b);</span><br><span class="line">    BigInteger <span class="keyword">operator</span>/(<span class="keyword">const</span> BigInteger&amp; b);</span><br><span class="line">    BigInteger <span class="keyword">operator</span>%(<span class="keyword">const</span> BigInteger&amp; b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; in, BigInteger&amp; x);</span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, BigInteger&amp; x);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>高进度整数类的构造函数实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">BigInteger::<span class="built_in">BigInteger</span>() &#123;</span><br><span class="line">    <span class="built_in">memset</span>(digit,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(digit));</span><br><span class="line">    length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger::<span class="built_in">BigInteger</span>(<span class="keyword">int</span> x) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(digit,<span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(digit));</span><br><span class="line">    length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">0</span>)&#123;                <span class="comment">//对于0的特殊处理</span></span><br><span class="line">        digit[length++] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(x != <span class="number">0</span>)&#123;</span><br><span class="line">        digit[length++] = x%<span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger::<span class="built_in">BigInteger</span>(string str) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(digit,<span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(digit));</span><br><span class="line">    length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = str.<span class="built_in">size</span>()<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) &#123;  <span class="comment">//注意数组存储的方式从低位到高位</span></span><br><span class="line">        digit[length++] = str[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger::<span class="built_in">BigInteger</span>(<span class="keyword">const</span> BigInteger &amp;b) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(digit,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(digit));</span><br><span class="line">    length = b.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">        digit[i] = b.digit[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure></li><li><p>赋值运算符的重载</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>=(<span class="keyword">int</span> x) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(digit,<span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(digit));</span><br><span class="line">    length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">0</span>)&#123;</span><br><span class="line">        digit[length++] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(x != <span class="number">0</span>)&#123;</span><br><span class="line">        digit[length++] = x%<span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>=(string str) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(digit,<span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(digit));</span><br><span class="line">    length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = str.<span class="built_in">size</span>()<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        digit[length++] = str[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>=(<span class="keyword">const</span> BigInteger &amp;b) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(digit,<span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(digit));</span><br><span class="line">    length = b.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">        digit[i] = b.digit[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>输入、输出运算符重载</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; in,BigInteger &amp;x)&#123;</span><br><span class="line">    string str;</span><br><span class="line">    in&gt;&gt;str;</span><br><span class="line">    x = str;</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out,<span class="keyword">const</span> BigInteger &amp;x)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x.length<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        out&lt;&lt; x.digit[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure></li><li><p>高进度正整数的算术运算</p><p>a. 比较</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> BigInteger::<span class="keyword">operator</span>&lt;=(<span class="keyword">const</span> BigInteger&amp; b)&#123;</span><br><span class="line">    <span class="keyword">if</span>(length &lt; b.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(b.length &lt; length)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = length<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (digit[i] == b.digit[i])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> digit[i] &lt; b.digit[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> BigInteger::<span class="keyword">operator</span>==(<span class="keyword">const</span> BigInteger &amp;b) &#123;</span><br><span class="line">    <span class="keyword">if</span>(length != b.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = length<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (digit[i] != b.digit[i])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​            b. 加法    </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>+(<span class="keyword">const</span> BigInteger &amp;b) &#123;</span><br><span class="line">    BigInteger answer;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> bound = length&gt;b.length ? length:b.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bound; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = digit[i] + b.digit[i] + carry;</span><br><span class="line">        answer.digit[answer.length++] = temp % <span class="number">10</span>;</span><br><span class="line">        carry = temp / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(carry == <span class="number">1</span>)&#123;  <span class="comment">//最高位有进位</span></span><br><span class="line">        answer.digit[answer.length++] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>加法运算比较简单，以两个数中最大的长度为遍历边界，对于每一位进行加和，留下和中小于10的部分，大于10的作为进位，加入高位的求和中。</p></blockquote><blockquote><p>注意： 两数的每一位遍历加和完成后，<strong>要判断最高位是否有进位（即进位的标记是否为1），如果有进位，则求和的结果在最高位前补1</strong>；</p></blockquote><p>​        c. 乘法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>*(<span class="keyword">const</span> BigInteger &amp;b) &#123;</span><br><span class="line">    BigInteger answer;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    answer.length = length + b.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length;  ++i) &#123;                 <span class="comment">//模拟：每位与乘数每一位运算后的，同权的位结果求和</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; b.length; ++j) &#123;</span><br><span class="line">            answer.digit[i+j] += digit[i] * b.digit[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; answer.length; ++k) &#123;           <span class="comment">//对于answer结果中的每一位超过10的进行修正进位</span></span><br><span class="line">        answer.digit[k+<span class="number">1</span>] += answer.digit[k] / <span class="number">10</span>;</span><br><span class="line">        answer.digit[k] %= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(answer.digit[answer.length<span class="number">-1</span>] == <span class="number">0</span> &amp;&amp; answer.length &gt; <span class="number">1</span>)&#123;   <span class="comment">//消除结果中多余的0</span></span><br><span class="line">        answer.length--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>乘法：稍微复杂一点</p><ol><li>模拟手动计算乘法的过程，即将乘数的从最低位一次去乘被乘数，要注意一个细节： <code>乘数的第i位 * 被乘数的第j位 = 结果的第(i+j)位</code>。将对应结果的权值相同的位加起来。</li><li>此时等到的结果中，每一位的值都可能大于10，需要对这些位做调整，将大于10的部分进位到高位，留下小于10的部分作为当前位的值。</li><li>乘法结果中可能存在连续多个高位到最高位为0，需要去除多余的0.否则对于根据数字有效长度判断大小的函数，会产生错误的比较结果。（如： 000 &gt; 0）</li></ol></blockquote><p>​        d.减法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>-(<span class="keyword">const</span> BigInteger &amp;b) &#123;     <span class="comment">//只使用于大数减小数的减法</span></span><br><span class="line">    BigInteger answer;</span><br><span class="line">    <span class="comment">//大数为this指向的对象，b为小数的对象</span></span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> bound = length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bound; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = digit[i] - b.digit[i] - carry;</span><br><span class="line">        <span class="keyword">if</span> (temp &gt;= <span class="number">0</span>)&#123;         <span class="comment">// 如果 被减数 大于等于 (减数+借位)则不需要进位</span></span><br><span class="line">            answer.digit[answer.length++] = temp;</span><br><span class="line">            carry = <span class="number">0</span>;   <span class="comment">// 如果没有借位需要把carry从1置为0否则会影响以后计算的结果</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            answer.digit[answer.length++]  = <span class="number">10</span> + temp;</span><br><span class="line">            carry = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(answer.digit[answer.length<span class="number">-1</span>] == <span class="number">0</span> &amp;&amp; answer.length &gt; <span class="number">1</span>)&#123;  <span class="comment">//去除结果中多余的0</span></span><br><span class="line">        answer.length--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>减法：<br>从被减数的低位到高位： 依次减去（减数对应权的位+低位相当前位的借位）。减后结果有两种情况：</p><ul><li>结果&lt;0 ,此时就需要向高位借位。 结果+10 修正， 借位置1</li><li>结果&gt;=0,此时结果无需修正，<strong>但是注意要将借位位置为0</strong><br>减法同样需要对于结果中多余的0进行修正</li></ul></blockquote><p>​        e. 除法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>/(<span class="keyword">const</span> BigInteger &amp;b) &#123;</span><br><span class="line">    BigInteger answer;</span><br><span class="line">    answer.length = length;</span><br><span class="line">    BigInteger remainder = <span class="number">0</span>;</span><br><span class="line">    BigInteger temp = b;   <span class="comment">// temp 存在的意义在于 比较运算符 &lt;= 前的对象不能是const 类型。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = length<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(remainder.length == <span class="number">1</span> &amp;&amp; remainder.digit[<span class="number">0</span>] == <span class="number">0</span>))&#123;   <span class="comment">//余数不为0</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = remainder.length<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j) &#123;  <span class="comment">//高位余数右移（向高位的方向移动）</span></span><br><span class="line">                remainder.digit[j+<span class="number">1</span>] = remainder.digit[j];</span><br><span class="line">            &#125;</span><br><span class="line">            remainder.length++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        remainder.digit[<span class="number">0</span>] = digit[i]; <span class="comment">//当前位并如余数中 ，成为新的被除对象</span></span><br><span class="line">        <span class="keyword">while</span>(temp &lt;= remainder)&#123;        <span class="comment">//除操作</span></span><br><span class="line">            remainder = remainder - temp;</span><br><span class="line">            answer.digit[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (answer.digit[answer.length<span class="number">-1</span>] == <span class="number">0</span> &amp;&amp; answer.length &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        answer.length--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>除法的操作：与加法、减法、乘法的不同之处在于，除法运算是从高位到低位的顺序<br>遍历被除数的每一位： </p><ol><li>高位的余数*10（右移一位）与当前位并入，作为新的被除对象。</li><li>对于被除对象的除操作可以表达为： 对被处对象不断的减去除数，对于最终商的当前位置不断加1，直到被除对象小于除数。此时被处对象的值就是当前位余数的值</li><li>遍历被除数的下一位</li></ol></blockquote><p>​        f. 取余<br>取余操作是与除法紧密相关的操作，即除法最终的余数，即位所求。<br>因此，取余的算法几乎与除法算法相同，只是移除了不需要保存的除法的商。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>%(<span class="keyword">const</span> BigInteger &amp;b) &#123;</span><br><span class="line">    BigInteger remainder = <span class="number">0</span>;</span><br><span class="line">    BigInteger temp = b;   <span class="comment">// temp 存在的意义在于 比较运算符 &lt;= 前的对象不能是const 类型。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = length<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(remainder.length == <span class="number">1</span> &amp;&amp; remainder.digit[<span class="number">0</span>] == <span class="number">0</span>))&#123;   </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = remainder.length<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                remainder.digit[j+<span class="number">1</span>] = remainder.digit[j];</span><br><span class="line">            &#125;</span><br><span class="line">            remainder.length++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        remainder.digit[<span class="number">0</span>] = digit[i];</span><br><span class="line">        <span class="keyword">while</span>(temp &lt;= remainder)&#123;</span><br><span class="line">            remainder = remainder - temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> remainder;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 机试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 研究生复试上机题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DevOps是什么?为什么我们需要DevOps?</title>
      <link href="/2019/04/18/DevOps%E6%98%AF%E4%BB%80%E4%B9%88-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81DevOps/"/>
      <url>/2019/04/18/DevOps%E6%98%AF%E4%BB%80%E4%B9%88-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81DevOps/</url>
      
        <content type="html"><![CDATA[<p>什么是 DevOps? 公司在推行 DevOps 的进程中应该注意什么？只有大公司才能从 DevOps 中收益？~</p><p>英文原文：《What is DevOps and Why Do We Need It?》作者：Skywell Software<br>原文链接：<a href="https://medium.com/datadriveninvestor/what-is-devops-and-why-do-we-need-it-82c2ef0a9d3d">https://medium.com/datadriveninvestor/what-is-devops-and-why-do-we-need-it-82c2ef0a9d3d</a></p><span id="more"></span><p>DevOps 被许多专家认为，是一种最好的方式去加强开发团队和运维团队的合作。但是 DevOps 不仅仅是一种方法，它更是一种文化使得软件开发过程中技术和业务双方合作更加高效，以使得产品上市时间缩短，产品<strong>整体</strong>的质量得以提升。在了解为什么 DevOps 这么重要之前，我们首先给它一个定义。</p><h3 id="DevOps-定义"><a href="#DevOps-定义" class="headerlink" title="DevOps 定义"></a>DevOps 定义</h3><p>DevOps 是，打破分隔 开发和运维团队壁垒，增强彼此之间合作的敏捷开发方法论的产物。但是如果你无法适当地应用这种正确的文化，DevOps 将沦为赶时髦的官话。这些使用 DevOps 文化所倡导的：</p><ul><li><p>责任共有—— 在许多公司，开发团队单单专注于产品的开发，对于系统的运维和管理不感兴趣，甚至回避如果这是别人的工作。如果在系统运行期间的监控工作成为开发团队的职责的一部分，他们很可能就能够体会到运维团队工作是的痛苦。DevOps 产生了一种新的方式，通过自动化部署和很好的日志记录来简化部署和维护工作。</p></li><li><p>团队自主化——高效的合作仅仅会发生在没有复杂的决策流程，开发和运维团队能够独立的做决定和改动的情况下。这个就需要新人你的团队、调整风险管理的策略并避免员工惧怕承担风险和失败的情况。</p></li><li><p>移除所有孤岛——一些公司记录过程并且将记录资料移交另一个团队，认为这是一个定期的合作。</p></li></ul><h3 id="DevOps-的整个流程"><a href="#DevOps-的整个流程" class="headerlink" title="DevOps 的整个流程"></a>DevOps 的整个流程</h3><p>DevOps 的整个流程由多个阶段组成，但是它们的如下列举的类似：</p><ul><li><p>计划——这个阶段包括你预期的开发进度的最初规划</p></li><li><p>编码——根据客户的需求开发应用程序</p></li><li><p>构建——合并各个你编写的代码</p></li><li><p>发布——如果测试通过，应用可以上线</p></li><li><p>部署—— 为了一些附加的用途，程序部署到云环境下</p></li><li><p>运维—— 在代码层面指导运维工作</p></li><li><p>监控—— 关注应用的运行情况，进行必要的改进以满足客户端的需求</p></li></ul><h3 id="为什么我们需要-DevOps？"><a href="#为什么我们需要-DevOps？" class="headerlink" title="为什么我们需要 DevOps？"></a>为什么我们需要 DevOps？</h3><p>DevOps 为软件开发公式带来的许多好处，例如，增加了创新的速度为客户更好的服务。能够使你在变化的市场环境下，灵活的调整产生更高的商业价值。由于频繁的迭代速度和节奏，你能更够快速的优化你的产品。这使得发布新特性的时间更短，发现和修复 bug 的速度更快。而更重要的是,快速的用户响应能力将成为你的业务的有力竞争优势。持续集成和持续发布就是从构建到部署的自动化软件发布过程的实践。</p><p>虽然产品化的步伐被加速，但是它在完成时依然如此的稳定可靠。通过 CI/CD 你能够测试所有产品的变更，更好的监控和日志记录将帮助你保持你的应用在生产环境中一直运行在最佳状态。安全流程不会被影响，因为合规策略将被细粒度的控制和管理配置技术自动化。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>如果你刚刚开始踏上 DevOps 落地之旅，设定切实可行的目标期望是必不可少的。当你迫切希望获得 DevOps 项目管理带来的好处时，你的团队可能经历着文化的冲击，因为他们一直习惯于原来独立的组织结构。改变已将建立好的流程并不容易，需要花费时间落实在人员、流程和信息等方面。这种文化的冲击将会带来新的目标表，你不能告诉的以前一个月迭代一个版本的团队，现在开始每天维护五个版本，这完全行不通。</p><p>当你意识到发布时间表应该在你的团队开始去接受 DevOps 文化和方法论时慢下来，你需要有一个更有组织的方式。需要许多的学习和训练，需要时间去习惯这所有的改变。在过渡过程中，建立一些重要的业务指标是重要的，如整体的收入和客户的满意度。以有各种本版的目的而创建多个版本是没有意义的。它必须对于你们的业务基础有效果。</p><p>考虑到 DevOps 所带来的优点，可以负责任的说那些没有完成 DevOps 进程化的公司将面临落后的风险。一个普遍的错误观点是 DevOps 仅仅针对大公司，但是小型和中等规模的公司也能够从中获得 DevOps 所提供的好处。事实上，像 Facebook、Netflix 和 其他的集团公司能够实现如此快速的增长，是因为他们很早就采用了 DevOps 的模式，使得他们能够相对于竞争对手更快的提供新功能给用户。因此，如果你还没有开始 DevOps 的进程，你已经落后于你的竞争者了。</p>]]></content>
      
      
      <categories>
          
          <category> 翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> open source </tag>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-Web框架介绍</title>
      <link href="/2019/04/17/Python-Web%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/"/>
      <url>/2019/04/17/Python-Web%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p>针对 Python 中的 全栈框架（Django） 和 微型框架（Flask）行进介绍，对于一些应用特定场景的其他框架做简单的说明~</p><p>英文原文：《A Complete Guide to Python Web Frameworks》作者：Premjith B P K</p><p>原文链接：<a href="https://opensourceforu.com/2019/04/a-complete-guide-to-python-web-frameworks/">https://opensourceforu.com/2019/04/a-complete-guide-to-python-web-frameworks/</a></p><span id="more"></span><p>Web 框架就是一些函数库，通过使用这些库使得 Web 开发更加简单快捷。Python 作为多功能的编程语言，有许多 Web 框架，像 Django、Web2py、Flask 和 Bottle等等。接下来我们将来介绍这些框架的相关情况。</p><p>对于开发 Web 应用程序的团队，Python 是一种主流且非常灵活的编程语言。应用程序以一种模块化的开发模式进行开发，使得开发者和 Web 框架紧密的联系起来。调用框架中提供的大量的解决方案，使得开发者能够更加专注于应用程序的逻辑业务，不再为重复和低优先级的任务所扰。</p><p>如今，开发者尝试使用强大功能的 Python 框架去解决解决一些具体的实现细节，这个加速了原型设计和开发的进程。从针对企业的强大全栈框架到适合开发小型专业的工具的超轻量级微框架流，目前有各种各样的流行的 Python Web 框架。</p><p>Python Web 框架在很大程度上削减了 Web 应用开发的成本、人力和时间周期。我们将分享这些流行框架中一些重要功能点，帮助在你开发 Web 应用程序中做的更好。我们希望能够帮助你确定针对自己实际需求的最合适框架。</p><h3 id="框架的作用"><a href="#框架的作用" class="headerlink" title="框架的作用"></a>框架的作用</h3><p>Web 框架使得开发者不需要去关注 Socket、协议 和 线程管理 等细节，专注于 Web 应用程序和服务的开发。框架的完成的大部分职责集中于 cookies 的处理、参数的获取以及 session 的处理等。主流的 Web 框架分为两大类：全栈框架 和 微型框架。</p><h3 id="选择全栈框架还是微型框架"><a href="#选择全栈框架还是微型框架" class="headerlink" title="选择全栈框架还是微型框架"></a>选择全栈框架还是微型框架</h3><p>当你在框架选择时，你应该将项目规模和复杂性作为考虑的重要因素。如果你希望应用的开发以业务功能为主，需要与其他的周边框架协作，全栈框架的选择将能够减少整个团队在开发时间和开发任务。但是，如果你在开发一个小型、简单需求的少的项目时，微型框架是你最好的选择。另一个需要考虑的问题是：你需要框架帮你完成多少事情？全栈 Web 框架包含了开发一个功能丰富 Web 应用的所有组件—框架生成器、访问列表和模板等。这使得你的团队能根据不同的需求创建出相应的页面和应用。对于希望快速开发出产品的团队这是一个很好的选择，因为这是使得他们更加专注于应用的开发而不是与之相关的周边事情。如果你有复杂的个性化需求或者已经在开发多种不同类型的定制化的软件，不管在什么情况下，你都不应该使用这些框架。</p><h3 id="全栈框架"><a href="#全栈框架" class="headerlink" title="全栈框架"></a>全栈框架</h3><p>有许多新且完备的全栈 web Python框架选择方案：如主流的框架 TurboGears 2、Pylons 和 Web2py。但是其中最流行的是 Django。</p><ul><li><p>Django</p><p>Django 是流程的 Python 框架，至于具体的原因大家不难理解。大量的网站使用了 Django，从出版社到社交媒体和分享网站，再到重要的<strong>机构</strong>和非盈利组织。由于 Django 最初开发于编辑部门，因此 华盛顿邮报 和 卫报 运行在该框架上也不是意外。一些新公司和初创公司像 Eventbrite 和 Disqus 已经在往 Django 迁移并且在提高完成度。同时社交巨头 Instagram 和 Pinterest 已经使用该框架去开发他们的动态 Web 应用。 </p><p>当考虑到框架时，Django 以快速开发 和 对业务开发者友好 而著称。作为一种“可插拔式”的框架，它提供了所有你需要的基础的组件 认证、可渲染模板、ORM 和路由等。相比于其他的主流 Web 框架，它有良好的技术文档。</p><p>通过对大量选择的处理，Django 能够在很大程度上减少新项目的引导时间。但是，在获得速度的同时也牺牲了长期开发维护的灵活性。例如，Django 内置的 ORM 在大部分情况下效果显著。但是，它无法像被称为最好的 Python 数据库抽象工具 SQLAlchemy那样有突破性。你可以想象在 Django 下使用 SQLAlchemy，但是那样你讲失去 Django 中的一些一开始就吸引人的重要功能。</p></li></ul><ul><li><p>Web2py</p><p>Web2py 是另一个主流的全栈框架。需要牢记的是 Web2py 不兼容 Python3。虽然 Web2py 的早期开发者已经保证会去开发兼容 Python3 的新版，但时至今日依然没有新版依然没有正式发布。</p><p>即便相较目前最新发布的 Python 版本已经十年时间了，Web2py 依然在许多大型企业中使用，其中就包括跨国银行。使得这个老 Web 框架依然有许多开发者在使用的原因，是他独一无二的功能。一方面，它即能够像 Django 一样简单易学习，又兼具灵活性和可扩展能力。不管是 AWS 还是 Google App Engine 中 VPS， 同样的一段代码几乎可以应用到 所用的使用 SQL  或者 Mongo DB 的 VPS 中 。</p><p>Web2py 有优秀的文档手册和活跃的社区在其背后作为强大的支持。另一个亮点在于 Web2py 有自己的IDE，其中包含了 代码编辑器、调试器、bug 票务框架 和 单独的票务部署功能等等。如果你的团队在未来几年中开发以 Python2 为主，或者希望充分利用已有的众多 Python 库和应用，那么 Web2py 框架非常符合你的要求。</p><p>Pyramid 确切的来说不是一个全栈的 Web 框架，并且自称是符合“金发姑娘”原则（适度原则）的框架。Pyramid 有这丰富的特性不会限制使用某种特定的方式去处理事情。作为一种轻量级的框架，不会使你随着应用的开发陷入独自一人的窘境。由于良好的通透性和模块化，Pyramid 是 Python 老鸟最喜爱的开发框架。不仅中等规模的团队在使用，像 Mozilla、Yelp、SurveyMonkey 和 Dropbox 这样的科技巨头也在使用。</p><p>事实上，Pyramid 框架中几乎所有的组件都能够替换掉。你能够使用你的数据库接口，甚者连接任何你想要连接的数据库。它不会像Django那样授权处理具体的选择，也不鼓励自动化处理具体任务的奇妙功能。这使得它不会表现预期的或者吸引人的方式。</p><p>Pyramid 流程的原因是它安全的解决方案，使得访问控制记录的创建和检查变得简单。另一个值得关注的创新功能是 Pyramid 的从 URL 到 code 的映射的路由系统，这使得最终创建 RESTful 接口变得容易。</p></li></ul><h3 id="微型框架"><a href="#微型框架" class="headerlink" title="微型框架"></a>微型框架</h3><p>考虑到你可能不需要全面和丰富的全栈框架。如今，新一代的 Web 应用需要许多可以插拔的部分，包括数据库抽象层，框架认证 和 可配置的访问控制规则。但是也有大部分的 Web 应用不要这些模块。对于这种项目，微型框架应该是最需要的。</p><p>这些超轻量级的应用被开发的目的是使得一些死掉的 Web 应用重新能被使用并且尽可能的运行的更快。他们的设计的功能精简—————— 对一些能通过安装一些其他的库满足的功能专门进行了移除。使用这些透明的方法的好处是使你的代码更加的简洁清晰，并且网站运行速度更快。这就是为什么微型框架没有全栈框架那么抽象。相比于对初学者友好的 Web 框架，你编写的代码将需要触及HTTP 的一些功能。</p><ul><li><p>Flask: </p><p>Flask 无疑是最有名的 Python 微型框架，并且一直是最有名的 Python 结构中的佼佼者。和 Django 一样，开发 Flask 的目的是使得 Web 应用开发并尽可能运行的更快。虽然是微型框架，但 Flask 已经被一些大公司所使用，其中包括 LinkedIn 和 Pinterest。</p><p>无论如何，这是个较量。相比 Django，Flask是那些又小又简单项目的理想选择。因此，你可以期待 Web 服务器开发将支持 Google App Engine 并且 内置单元测试功能。Flask 不支持 数据库抽象层 和 表单验证，且自动上传的功能被禁用。但是，每一个这些功能都能够通过外部扩展来实现。例如一些主要的扩展包括 SQLAlchemy 数据库 、 Jinja2 模板和 CouchDB。</p><p>一些 Python 开发者会选择 Flask 而非 Django ，因为前者越来越 Pythonic。这更加符合 Pytho 之禅的原则：一种方式完成事情，并且相应的代码能够表明在做什么。如果你非常想要从头开始使代码更加简洁明了，Flask 应该是你合适的选择。</p></li><li><p>Bottle: </p><p>Bottle 是另一个主流的微型框架。它从一开始就是为创建 Web API 而生，这也是它最好的使用案例。Bottle 更加奇妙的地方在于，它尝试使用一个单一的文件做所有的事情，这给我们一个重要的认识：它的设计是多么的 micro。</p><p>Bottle 包含一些开箱即用的功能包括 模板、路由、应用程序 和 一些在 WSGI 标准上的基础抽象。和 Flask 一样，有你的编码将更接近底层相比于全栈框架。尽管如此，Bottle 已经被 Netfilx 用于创建 Web 接口。</p></li></ul><h3 id="其他一些流行的框架"><a href="#其他一些流行的框架" class="headerlink" title="其他一些流行的框架"></a>其他一些流行的框架</h3><p>我们已经介绍了许多广泛使用的 Python Web 框架，你可以从中有不同的选择。接下来将了解一些在特定情况下表现优良的其他框架。</p><p>Tornado 是专为解决 C10k 问题而开发的 Python Web 框架。（在正确配置下，它能够通过异步 I/O 处理超过 10,000 并发连接数）这个对于那些需要高质量且大量并发用户的项目是一个巨大的吸引力。</p><p>CubicWeb 是一个奇妙的 Web 框架，它完全不同其他的 Web 框架。它是语义 Web 的一种，用外行人的话将，它是一个通过减少对于电脑系统性能要求的方式来显示信息的系统。它使用一个单独的概念替代了 MVC 模型中的 model 和 view ，即数据块———能够由于开发不同的组件，有点像 Web 上的 Docker。</p><p>Phalcon 是一个专注于创建云 API 的微型框架。和其他微型框架一样，它保持的较少的依赖，并且与复杂功能保持着一个明智的距离。但是，不同于其他框架，它不是为 HTML 的页面而开发的，而是，为更快的创建 RESTful API 而生。</p><p>即便 Android 有非常优秀开箱即用的 SDK ，但使用 Python 实现替代 Java 实现有着巨大的好处，对于网站和应用开发（使用 Kivy 移动应用开发的 Python 开源库 ）。因为 Python 提供了更快的时间转化和库的复用。</p><p>Python 作为一个可靠、安全的开发语言，被用于安全敏捷 Web 应用的开发。作为可靠备选中的佼佼者，它减少了顶尖稳定 Web 应用和网站的开发周期。你可以在开发你的下一个项目时，咨询有经验的 Python 开发人员，以得到更好的指导。</p>]]></content>
      
      
      <categories>
          
          <category> 翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> open source </tag>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何通过在不写代码的情况下做开源</title>
      <link href="/2019/04/16/%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E5%9C%A8%E4%B8%8D%E5%86%99%E4%BB%A3%E7%A0%81%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E5%81%9A%E5%BC%80%E6%BA%90/"/>
      <url>/2019/04/16/%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E5%9C%A8%E4%B8%8D%E5%86%99%E4%BB%A3%E7%A0%81%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E5%81%9A%E5%BC%80%E6%BA%90/</url>
      
        <content type="html"><![CDATA[<p>本文作者阐述了，如果在不写代码的模式下，优雅的为开源事业做贡献~</p><p>英文原文：《How do you contribute to open source without code?》作者： Chris Hermansen<br>原文链接：<a href="https://opensource.com/article/19/4/contribute-without-code">https://opensource.com/article/19/4/contribute-without-code</a></p><span id="more"></span><p>我最早开始为开源做贡献要追溯到20世纪80年代中期。那是我们组织第一次连接到UseNet网站，在那里我们了解到了代码贡献以及为其开发和维护的机会。</p><p>今天，有很多种方式去做贡献，从代码贡献到制作教程。</p><p>我将一步步说明代码贡献这个问题，而不是仅仅指出“那些写代码却不认为自己是开发者的人，依然能够贡献代码”。我愿意告诉每个人：有很多种不通过写代码的方式贡献开源社区的方法。具体谈谈这种不写代码的贡献方式。</p><h3 id="提交-bug-报告"><a href="#提交-bug-报告" class="headerlink" title="提交 bug 报告"></a>提交 bug 报告</h3><p>一种主要、集中的代码贡献方式被称为“不要害怕创建一个体面的 bug 报告”，接下来得内容主要是关于这中方式。有时，编写一个相当好的的 bug 报告是一件相当有挑战的事情。比如：</p><ul><li><p>一些 bug 可能很难记录并秒速。例如 一个带有一系列的不可知代码的冗长复杂信息可能在计算机启动时闪现，或者导致一些奇怪的现象并且显示屏没有相应的错误信息产生。</p></li><li><p>一些 bug 可能是很难复现的。它仅仅在一些特定的 软件/硬件 配置下，并且很难再次触发，对于某些具体的问题可能并不明显。</p></li><li><p>一些 bug 可能涉及到一些非常具体的庞大、混乱、复杂开发环境配置，以至于 bug 的提交非常困难。需要花力气去创建一些精简的测试案例。</p></li><li><p>当提交一个分支版的软件 bug 时，维护者会建议提交上流版本的 bug 测试情况。在当前版本不是社区上流推崇的版本的分支时，这将产生许多工作量。（这个通常发生在分支版本的维护滞后于官方当前的发行版和开发版时）</p></li></ul><p>尽管如此，我依然倡导 未来的 bug 提交者 能够重视并尽可能详细的记录和说明 bug 的情况。</p><p>在开始时，通过自己喜欢的检索工具去寻找相关的 bug 报告，看看它们是如何描述，怎样展现等等。另一种重要的需要知道的是 bug 提交报告的正式术语，关于你用的系统分发版本（Fedora、openSUSE、Ubuntu） 或者 使用的软件（LIbreOffice、Mozilla） 。</p><h3 id="解决用户的问题"><a href="#解决用户的问题" class="headerlink" title="解决用户的问题"></a>解决用户的问题</h3><p>我潜水并偶尔参与到各种各样的邮件列表和论坛，像 Ubuntu quality control 小组或者论坛、LinuxQuestions.org 和 the ALSA users’ 邮件列表。在这里，主要的贡献不是 bug 的提交和修复，更多的是编写软件相关的使用案例。当有人加入讨论并解决他们的特殊问题时，每一个人都有一种喜悦。</p><h3 id="为开源而创作"><a href="#为开源而创作" class="headerlink" title="为开源而创作"></a>为开源而创作</h3><p>最后，另一个我喜欢的贡献方式是通过创作一些关于开源软件的使用的资料。包括 如何使用的指南、一个针对特殊问题，同类软件之间的测评 以及 对于一个感兴趣领域的探索（就我而言，使用开源的音乐播放器来聆听音乐）。一个类似的方式是制作软件使用教程视频，以一种简单的方式录制一些困难的桌面操作，如使用GIMP创作一个引人注目的logo。如果你熟悉两种或者多种语言可以考虑将目前的已有的一些文字教程和视频教程翻译为另一种语言。</p>]]></content>
      
      
      <categories>
          
          <category> 翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> open source </tag>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你应该知道的markdown语法</title>
      <link href="/2019/03/13/%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84markdown%E8%AF%AD%E6%B3%95/"/>
      <url>/2019/03/13/%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84markdown%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>关于 markdown 常用的一些语法，方便我们以 markdown 的方式记录生活~</p><span id="more"></span><p>你还在用word写笔记、心得体会、说明文档之类的东东吗？是不是还在为word的排版而烦恼? ^_^<br>快来试试,代码圈最风靡的说明文档编写姿势吧，markdown 让你在了解几分钟语法的情况,专注于内容的输出。下面我们一起来看一看这些经常用到的语法~</p><!--  --><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 大秦帝国</span></span><br><span class="line"><span class="section">## 长平杀降</span></span><br></pre></td></tr></table></figure><p>标题总共有六级</p><p>效果：</p><img src="/2019/03/13/%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84markdown%E8%AF%AD%E6%B3%95/%E6%A0%87%E9%A2%98.png" class="" title="标题效果"><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; 白起奉亲昭襄王诏令，坑杀赵国数十万放下武器的士兵</span></span><br><span class="line"><span class="quote">&gt;</span></span><br><span class="line"><span class="quote">&gt; &gt; 白起： 秦国上将军，战国时期四大战神之首。</span></span><br><span class="line"><span class="quote">&gt;</span></span><br><span class="line"><span class="quote">&gt; ## 武安君之死</span></span><br><span class="line"><span class="quote">&gt;</span></span><br><span class="line"><span class="quote">&gt; 硬候范睢建议秦昭襄王赐死辞官回乡的白起</span></span><br></pre></td></tr></table></figure><p>效果：</p><img src="/2019/03/13/%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84markdown%E8%AF%AD%E6%B3%95/%E5%BC%95%E7%94%A8.png" class="" title="引用效果"><p>对于引用可以在内部嵌套 markdown 的语法</p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">战国名士</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 苏秦</span><br><span class="line"><span class="bullet">-</span> 张仪</span><br><span class="line"><span class="bullet">-</span> 公孙衍</span><br><span class="line"><span class="bullet">-</span> 孟尝君</span><br></pre></td></tr></table></figure><p>效果：</p><img src="/2019/03/13/%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84markdown%E8%AF%AD%E6%B3%95/%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8.png" class="" title="无序列表效果"><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">战争的要素</span><br><span class="line"><span class="bullet">1.</span> 钱粮</span><br><span class="line"><span class="bullet">2.</span> 兵马</span><br><span class="line"><span class="bullet">3.</span> 将领</span><br></pre></td></tr></table></figure><p>效果：</p><img src="/2019/03/13/%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84markdown%E8%AF%AD%E6%B3%95/%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8.png" class="" title="有序列表效果"><h3 id="代办事项列表"><a href="#代办事项列表" class="headerlink" title="代办事项列表"></a>代办事项列表</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> [ ] 阅读孙皓晖教授的书籍</span><br><span class="line"><span class="bullet">-</span> [x] 观看大秦帝国之裂变</span><br></pre></td></tr></table></figure><p>效果：</p><img src="/2019/03/13/%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84markdown%E8%AF%AD%E6%B3%95/%E4%BB%A3%E5%8A%9E%E4%BA%8B%E9%A1%B9%E5%88%97%E8%A1%A8.png" class="" title="代办事项列表效果"><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">\<span class="code">`\`</span>\`c</span><br><span class="line"><span class="section">#include <span class="xml"><span class="tag">&lt;<span class="name">stdio.h</span>&gt;</span></span></span></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"><span class="code">    printf(&quot;hi~,markdowner ^-^ \n&quot;);   </span></span><br><span class="line"><span class="code">    </span></span><br><span class="line"><span class="code">    return 0;</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code">\`\`\`</span></span><br></pre></td></tr></table></figure><blockquote><p>代码块的语法以```为开头和结尾，此处由于博客展示的原因（不知道代码块的语法如何做到不转义，如果有知道的小伙伴，还请指教^_^）。</p></blockquote><p>效果：</p><img src="/2019/03/13/%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84markdown%E8%AF%AD%E6%B3%95/%E4%BB%A3%E7%A0%81%E5%9D%97.png" class="" title="代码块效果"><h2 id="内容标识"><a href="#内容标识" class="headerlink" title="内容标识"></a>内容标识</h2><p>斜体、加粗</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="emphasis">_白起的妻子是赵国人?_</span></span><br><span class="line"><span class="strong">**白起一生从无败战**</span></span><br></pre></td></tr></table></figure><p>效果：</p><img src="/2019/03/13/%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84markdown%E8%AF%AD%E6%B3%95/%E6%A0%87%E8%AF%86.png" class="" title="标识效果"><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">Dribbble</span>](<span class="link">https://dribbble.com/shots</span>)</span><br></pre></td></tr></table></figure><p>效果：</p><img src="/2019/03/13/%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84markdown%E8%AF%AD%E6%B3%95/%E9%93%BE%E6%8E%A5.png" class="" title="链接效果"><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">coding man</span>](<span class="link">https://lifeisbianry_codeingman.jpg</span>)</span><br></pre></td></tr></table></figure><p>效果：</p><img src="/2019/03/13/%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84markdown%E8%AF%AD%E6%B3%95/%E5%9B%BE%E7%89%87.png" class="" title="图片效果"><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">赵国阵营</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 廉颇</span><br><span class="line"><span class="bullet">-</span> 李牧</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">秦军阵营</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 蒙骜</span><br><span class="line"><span class="bullet">-</span> 白起</span><br></pre></td></tr></table></figure><p>效果：</p><img src="/2019/03/13/%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84markdown%E8%AF%AD%E6%B3%95/%E5%88%86%E5%89%B2%E7%BA%BF.png" class="" title="分割效果"><h2 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~~秦军与赵军在长平进行了一场大对决~~</span><br></pre></td></tr></table></figure><p>效果：</p><img src="/2019/03/13/%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84markdown%E8%AF%AD%E6%B3%95/%E5%88%A0%E9%99%A4%E7%BA%BF.png" class="" title="删除线效果"><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>在要展示目录的文章头部输入<code>[TOC]</code><br>效果：</p><img src="/2019/03/13/%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84markdown%E8%AF%AD%E6%B3%95/%E7%9B%AE%E5%BD%95.png" class="" title="目录效果"><h2 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">白起[^1]是战神，他曾经和赵括在长平进行战争[^2]</span><br><span class="line"></span><br><span class="line">[<span class="symbol">^1</span>]:<span class="link">秦国上将军</span></span><br><span class="line">[<span class="symbol">^2</span>]:<span class="link">杀人的机器</span></span><br></pre></td></tr></table></figure><p>效果：</p><img src="/2019/03/13/%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84markdown%E8%AF%AD%E6%B3%95/%E8%84%9A%E6%B3%A8.png" class="" title="脚注效果">]]></content>
      
      
      <categories>
          
          <category> 展现形式 </category>
          
          <category> markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdwon </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
