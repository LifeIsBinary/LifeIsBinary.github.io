<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>机试——字符串、排序与查找</title>
      <link href="/2020/03/29/%E6%9C%BA%E8%AF%95%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E5%8A%9F/"/>
      <url>/2020/03/29/%E6%9C%BA%E8%AF%95%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E5%8A%9F/</url>
      
        <content type="html"><![CDATA[<h4 id="C-中字符串"><a href="#C-中字符串" class="headerlink" title="C++中字符串"></a>C++中字符串</h4><ol><li><p>string 的基本使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;isotream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string str,str1 = <span class="string">&#x27;OK&#x27;</span>; <span class="comment">/*定义string类型变量*/</span></span><br><span class="line">    cin&gt;&gt;str;  <span class="comment">//输入</span></span><br><span class="line">    str.<span class="built_in">size</span>() <span class="comment">// string类型变量长度</span></span><br><span class="line">    cout&lt;&lt;str&lt;&lt;endl;   <span class="comment">//输出</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;str.<span class="built_in">size</span>(); i++)&#123;   <span class="comment">//像数组一样访问元素</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,str[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    str.<span class="built_in">insert</span>(str.<span class="built_in">size</span>(),<span class="string">&quot;...&quot;</span>);  <span class="comment">//从当前下标开始插入   </span></span><br><span class="line">    str.<span class="built_in">erase</span>(<span class="number">0</span>,<span class="number">5</span>); <span class="comment">//删除下标从0～5的元素 </span></span><br><span class="line">    str.<span class="built_in">erase</span>(<span class="number">2</span>);</span><br><span class="line">    str.<span class="built_in">clear</span>(); <span class="comment">//str置空</span></span><br><span class="line"></span><br><span class="line">    str = str + <span class="string">&#x27;hello&#x27;</span>; <span class="comment">//字符串连接</span></span><br><span class="line">    str = str + str1;</span><br><span class="line">    str.<span class="built_in">find</span>(<span class="string">&quot;ok&quot;</span>); <span class="comment">// 在字符串中查找字符串或者字符 如果找不到返回 string::npos</span></span><br><span class="line">    str.<span class="built_in">sbustr</span>(<span class="number">2</span>,<span class="number">4</span>); <span class="comment">//返回str中下标从2开始的四个字符组成的子串</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>对于需要获取一行的字符串（含空格），需要使用getline</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string str;</span><br><span class="line"><span class="built_in">getline</span>(cin,str);</span><br></pre></td></tr></table></figure></li></ol><p>例子：</p><p>在情报传递过程中，为了防止情报被截获，往往需要对情报用一定的方式加密，简单的加密算法虽然不足以完全避免情报被破译，但仍然能防止情报被轻易的识别。我们给出一种最简的的加密方法，对给定的一个字符串，把其中从a-y,A-Y的字母用其后继字母替代，把z和Z用a和A替代，则可得到一个简单的加密字符串。</p><p>输入一行字符串，输出对该字符串加密的结果</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">incode</span><span class="params">(string str)</span></span>&#123;</span><br><span class="line">    string incodeStr;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>( (<span class="string">&#x27;a&#x27;</span>&lt;=str[i]  &amp;&amp; str[i]&lt;=<span class="string">&#x27;y&#x27;</span>) || (<span class="string">&#x27;A&#x27;</span>&lt;=str[i]  &amp;&amp; str[i]&lt;=<span class="string">&#x27;Y&#x27;</span>) )&#123;</span><br><span class="line">            incodeStr += str[i]+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (str[i] == <span class="string">&#x27;z&#x27;</span> || str[i] == <span class="string">&#x27;Z&#x27;</span>)&#123;</span><br><span class="line">            incodeStr += str[i]<span class="number">-25</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            incodeStr += str[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> incodeStr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(cin,str))&#123;</span><br><span class="line">        cout&lt;&lt;<span class="built_in">incode</span>(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><ol><li>c++内部基于快速排序的函数——sort<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sort</span>(first,last,comp); <span class="comment">// first,last 起始地址、结束地址， 排序方式定义的函数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>如果sort中的 比较函数comp 返回 true, 则排序时会将比较函数comp的第一个参数置于第二个参数前。<br>例子： 用一位数组存储学生的学号和成绩，然后按成绩排序输出</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">Student arr[MAXN];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Compare</span><span class="params">(Student a, Student b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.score == b.score)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.number &lt; b.number;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.score &lt; b.score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;arr[i].number,&amp;arr[i].score);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(arr,arr+n,Compare);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,arr[j].number,arr[j].score);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><p>机试中最常见的查找是二分查找<br>二分查找的前提是有序，二分查找的思想是： 对于当前要查找的数，与有序序列中中间位置的数与之做比较：</p><p> a. 如果大于要查找的数，则从小于中间位置的序列中再使用该方法查找。</p><p> b. 如果小于要查找的数，则从大于中间位置的序列中再使用该方法查找。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在长度位n的有序数组arr中查找x,返回查找到的下标</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch</span><span class="params">(<span class="keyword">int</span> arr,<span class="keyword">int</span> n,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">        <span class="keyword">int</span> middle = (low+high)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(arr[middle] == x)&#123;</span><br><span class="line">            <span class="keyword">return</span> middle;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[middle] &lt; x)</span><br><span class="line">            low = middle + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            high = middle - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 机试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机试上手 </tag>
            
            <tag> 研究生复试上机题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机试--数学问题</title>
      <link href="/2020/03/29/%E6%9C%BA%E8%AF%95-%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98/"/>
      <url>/2020/03/29/%E6%9C%BA%E8%AF%95-%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>机试中，有一些与数字相关的题目： 进制转换、最大公约数、最小公倍数、素数、高进度整整数运算（无法用数值类型变量直接存储）。本文对于这几个部分的一些常见题，进行归纳总结。</p><span id="more"></span><h3 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h3><ol><li>整数二进制方式显示 [北邮上机题]</li></ol><blockquote><p>十进制转二进制，使用除留取余法，注意余数的先后顺序与该数二进制顺序相反，因此将余数按顺序存放，逆序输出即可</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span>   <span class="comment">//容器，可变长度的&quot;数组&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bit</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; NumBit;</span><br><span class="line">    <span class="keyword">int</span> BitNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(num != <span class="number">0</span>)&#123;</span><br><span class="line">        NumBit.<span class="built_in">push_back</span>(num % <span class="number">2</span>);</span><br><span class="line">        num /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = NumBit.<span class="built_in">size</span>()<span class="number">-1</span>; i &gt;= <span class="number">0</span> ; i--) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,NumBit[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    string s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num);</span><br><span class="line">        <span class="built_in">Bit</span>(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>大型正整数二进制显示 [清华上机题]</li></ol><blockquote><p>在C与C++中较大的整数无法存储进行直接的算数运算。因此，对于大数的处理一般需要使用字符串的方法。本题与上一题有相似之处，只是本题的数据无法存储，因此无法进行算术的除、取余操作。可以通过定义字符串的方式，实现字符串数字的除法、取余。进而套用上一题的方法。</p></blockquote><blockquote><p>对于字符串的：</p><ol><li>取余操作： 只需取当前字符串的最后一位做算术的取余操作，其结果即是整个字符串数的取余结果。</li><li>除法操作： 与我们平时在草稿纸上算的步骤一样，依次从高到低对字符串数的每个元素进行：<br> 除2 、 取余操作。 即可得到该字符串数除2的结果字符串。<strong>该过程中注意：取余的目的是为了，在下次除操作前，将上一位的余数与当前为合并作为被除数。 对于除完后的结果中可能前几位是0，需要去掉多余的0，方便除留取余法推出循环。</strong></li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">string <span class="title">divide</span><span class="params">(string num, <span class="keyword">int</span> divider)</span></span>&#123;  <span class="comment">//字符串除法</span></span><br><span class="line">    string answer; <span class="comment">//商</span></span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>; <span class="comment">//上一位的余数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;num.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> dividend = num[i]-<span class="string">&#x27;0&#x27;</span> + carry*<span class="number">10</span> ;</span><br><span class="line">        answer += (<span class="string">&#x27;0&#x27;</span> + dividend / divider);   </span><br><span class="line">        carry = dividend % divider; <span class="comment">//取余</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> post = <span class="number">0</span>; <span class="comment">//标示answer中不为0的第一个数字字符【重要】</span></span><br><span class="line">    <span class="keyword">while</span> (answer[post] == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">        post++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> answer.<span class="built_in">substr</span>(post);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printBit</span><span class="params">(string sNum)</span></span>&#123; <span class="comment">//十进制转二进制</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; NumBit;</span><br><span class="line">    <span class="keyword">while</span>(sNum.<span class="built_in">size</span>() != <span class="number">0</span>)&#123;</span><br><span class="line">        NumBit.<span class="built_in">push_back</span>((sNum[sNum.<span class="built_in">size</span>()<span class="number">-1</span>]-<span class="string">&#x27;0&#x27;</span>) % <span class="number">2</span>);</span><br><span class="line">        sNum = <span class="built_in">divide</span>(sNum,<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=NumBit.<span class="built_in">size</span>()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,NumBit[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string sNum;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; sNum)&#123;</span><br><span class="line">        <span class="built_in">printBit</span>(sNum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>求一个十进制数的逆序数。[清华机上机题]<blockquote><p>逆序数：对于一个十进制数A，将A转换为二进制数，然后按位逆序排列，再转换为十进制数B，我们称B为A的二进制逆序数。例如对于十进制数173，它的二进制形式为10101101，逆序排列得到10110101，其十进制数为181，181即为173的二进制逆序数。</p></blockquote></li></ol><blockquote><p>本题与上一题，有一定的联系。将大数的十进制（字符串形式）转换为二进制【上题内容】，接下来需要：将得到的二进制转换成新的大数的十进制（字符串形式）。</p><p>转换过程中涉及到： 字符串数与一位整数的 加法 和 乘法</p><ol><li>加法： 将加数作为低位的进位，从<strong>后向前</strong>遍历字符串数的每一个位： 当前位与进位相加，对10取余为求加法结果，对10取模为当前位加法向上一位的进位。<strong>注意即使进位为0，也要继续遍历高位，进行求和操作。否则结果会丢失高位信息。</strong>。如果加法遍历完后，最高位有进位需要给结果修正：最高位补1。</li><li>乘法： 对于被乘数进行从后向前遍历：当前位乘上乘数并加上后一位的进位，对10取余为乘法结果，对10取模为进位。如果最高位有进位，结果和加法一样需要类似的修正。</li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">divide</span><span class="params">(string sNum,<span class="keyword">int</span> divider)</span></span>&#123;   <span class="comment">//字符串除法</span></span><br><span class="line">    string answer; <span class="comment">//最后除的结果--商</span></span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>; <span class="comment">//上一位的余数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;sNum.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> dividend = (sNum[i]-<span class="string">&#x27;0&#x27;</span>) + carry*<span class="number">10</span>; <span class="comment">//当前位的被除数</span></span><br><span class="line">        answer += (<span class="string">&#x27;0&#x27;</span>+ (dividend / divider)); <span class="comment">//当前位的商</span></span><br><span class="line">        carry = dividend % <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> post = <span class="number">0</span>; <span class="comment">//商字符串中不为0的第一字符位置</span></span><br><span class="line">    <span class="keyword">while</span>(answer[post] == <span class="string">&#x27;0&#x27;</span>)&#123;    <span class="comment">//去除结果中前面多余的0</span></span><br><span class="line">        post++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> answer.<span class="built_in">substr</span>(post);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">multiple</span><span class="params">(string sNum,<span class="keyword">int</span> factor)</span></span>&#123;  <span class="comment">//字符串乘法</span></span><br><span class="line">    string answer;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=sNum.<span class="built_in">size</span>()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = (sNum[i]-<span class="string">&#x27;0&#x27;</span>)  * factor + carry;</span><br><span class="line">        answer = <span class="built_in"><span class="keyword">char</span></span>(<span class="string">&#x27;0&#x27;</span>+(temp % <span class="number">10</span>)) + answer;   <span class="comment">//从低位到高位分别乘二得到结果</span></span><br><span class="line">        carry = temp / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(carry == <span class="number">1</span>)&#123;     <span class="comment">//因为乘的是2，所以进位只能是1</span></span><br><span class="line">        answer = <span class="string">&#x27;1&#x27;</span> + answer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">add</span><span class="params">(string sNum, <span class="keyword">int</span> adder)</span></span>&#123;</span><br><span class="line">    string answer;</span><br><span class="line">    <span class="keyword">int</span> carry = adder;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=sNum.<span class="built_in">size</span>()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = sNum[i]-<span class="string">&#x27;0&#x27;</span> + carry; <span class="comment">//把要加的一位整数（0或1）当成当前位后一位的进位</span></span><br><span class="line">        carry = temp / <span class="number">10</span>;</span><br><span class="line">        answer = <span class="built_in"><span class="keyword">char</span></span>(<span class="string">&#x27;0&#x27;</span> +temp%<span class="number">10</span>) + answer ;  <span class="comment">//需要进行类型转换，否则无法将int型并入字符串</span></span><br><span class="line">        <span class="comment">//if(carry == 0) 没有进位，加法依然要继续，否则丢失高位值</span></span><br><span class="line">        <span class="comment">//    break;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(carry == <span class="number">1</span>)&#123; <span class="comment">//最高位有进位</span></span><br><span class="line">        answer = <span class="string">&quot;1&quot;</span> + answer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printInvertBinNum</span><span class="params">(string sNum)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//十进制字符串 转 二进制</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; InvertBinary;</span><br><span class="line">    <span class="keyword">while</span>(sNum.<span class="built_in">size</span>() != <span class="number">0</span>)&#123;</span><br><span class="line">        InvertBinary.<span class="built_in">push_back</span>( (sNum[sNum.<span class="built_in">size</span>()<span class="number">-1</span>]-<span class="string">&#x27;0&#x27;</span>) % <span class="number">2</span> ); <span class="comment">//取余</span></span><br><span class="line">        sNum = <span class="built_in">divide</span>(sNum,<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//二进制 转 十进制字符串</span></span><br><span class="line">    string answer = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;InvertBinary.<span class="built_in">size</span>(); i++)&#123;  <span class="comment">//对于求二进制逆序数来说： InvertBinary中保存的是逆序数的正序二进制</span></span><br><span class="line">        answer = <span class="built_in">multiple</span>(answer,<span class="number">2</span>); <span class="comment">//对于中间结果右移一位</span></span><br><span class="line">        answer = <span class="built_in">add</span>(answer,InvertBinary[i]); <span class="comment">//加上低位的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; answer.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,answer[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string sNum;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;sNum)&#123;</span><br><span class="line">        <span class="built_in">printInvertBinNum</span>(sNum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>M进制转N进制<blockquote><p>由于M，和N的值都有可能大于10，所以有字符串的形式存储M进制数和N进制数。因此需要现将M进制的数转换为数值形式，这里将其转换为我们熟悉的十进制是一种常见的方式，通过十进制作为两种不同进制字符串形式转换的桥梁。即 M进制字符串形式 –&gt; 十进制数值形式 –&gt; N进制字符串形式。在其中注意一些细节问题，如需要将高于10进制的数中的英文字符转换为数字，将高于10的数字转换为英文字符。这是于小于10的进制转换所不需要考虑的问题。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CharToInt</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&#x27;0&#x27;</span>&lt;=c &amp;&amp; c&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c-<span class="string">&#x27;A&#x27;</span>+<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">IntToChar</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x&lt;<span class="number">10</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;0&#x27;</span>+x;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x<span class="number">-10</span> + <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m,n;</span><br><span class="line">    string str,Nmum;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;m,&amp;n)) &#123;</span><br><span class="line">        cin &gt;&gt; str;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); ++i) &#123;  <span class="comment">//M进制转为10进制</span></span><br><span class="line">            number *= m;</span><br><span class="line">            number += <span class="built_in">CharToInt</span>(str[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="keyword">char</span>&gt; answer;</span><br><span class="line">        <span class="keyword">while</span>(number != <span class="number">0</span>)&#123;</span><br><span class="line">            answer.<span class="built_in">push_back</span>(<span class="built_in">IntToChar</span>(number%n));</span><br><span class="line">            number /= n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = answer.<span class="built_in">size</span>()<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, answer[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><pre><code>进制转换的问题，最为重要的是转换的方法： 1.正向除留取余法，2.逆向移位求和法。 注意在做两种运算的过程中1的输出、2的输入的数据的顺序与正常情况下的相反。在此基础之上，有时需要考虑到输入数据的方式：1. 由于高于10进制，存储使用字符串方便。对于这种可以想办法把输入转为10进制数值，根据题目要求作处理。2. 需要输入的数远大于数值类型的存储范围，使用字符串存储。对于该类数据的运算，不能使用数值型，因为无法存储中间结果。需要实现字符串级别的“算术运算”。要注意定义运算过程中的一些细节，如运算后结果的修正，考虑最高位进位问题等。</code></pre><h3 id="最大公约数与最小公倍数"><a href="#最大公约数与最小公倍数" class="headerlink" title="最大公约数与最小公倍数"></a>最大公约数与最小公倍数</h3><p>这种题需要对于最大公约数和最小公倍数的判别方法熟悉。</p><h4 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h4><blockquote><p>对于 a, b 两数，求其最大公约数的思路是：</p><ol><li>把求   a, b的最大公约数 —&gt;  b, a%b的最大公约数  （数学推理过程略） <strong>注意b作为除数不能为0</strong></li><li>这样不断递归的缩小范围，直到求 某个数与0 的最大公约数，即非0数为最大公约数</li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxFactor</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">MaxFactor</span>(b,a%b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m,n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;m,&amp;n)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in">MaxFactor</span>(m,n));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="最小公倍数"><a href="#最小公倍数" class="headerlink" title="最小公倍数"></a>最小公倍数</h4><p>求最小公倍数思路是基于最大公约数的：<br>    a,b 的最小共倍数是  a*b / 最大公约数</p><h3 id="质数-素数"><a href="#质数-素数" class="headerlink" title="质数/素数"></a>质数/素数</h3><blockquote><p>质数或者素数a： 只能被1和本身整出的<strong>正整数</strong>（小于2的数一定不是素数）。 用所有小于sqrt(a)的数除a,如果存在整除的情况则不是素数。</p></blockquote><h4 id="判断一个数是否为素数"><a href="#判断一个数是否为素数" class="headerlink" title="判断一个数是否为素数"></a>判断一个数是否为素数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">JudgeSuNum</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">2</span>)&#123;                <span class="comment">//小于2的数一定不是素数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> bound = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; bound; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n%i == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in">JudgeSuNum</span>(n));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于一定大范围的数，判断其是否为素数，对于每一个数遍历判别，显然是有些耗时，效率不高。是否有更好的方法呢？——-素数筛选法</p><p>素数筛选法的思想是：假设当前大于1的数都为素数，遍历所有数，用已确定的素数，去标记后面是该素数倍数的数为非素数。通过选出不是素数的数，剩余的则是素数。</p><h4 id="输出1到给定n之间的素数"><a href="#输出1到给定n之间的素数" class="headerlink" title="输出1到给定n之间的素数"></a>输出1到给定n之间的素数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10001</span>;</span><br><span class="line"><span class="keyword">bool</span> isPrime[MAXN];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; prime;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Initial</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXN; ++i) &#123;</span><br><span class="line">        isPrime[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    isPrime[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">    isPrime[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; MAXN; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!isPrime[j])&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        prime.<span class="built_in">push_back</span>(j);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = j*j; i &lt; MAXN; i+=j) &#123;  <span class="comment">//从当前素数j的j倍开始，小于j的倍数的数 由 小于j的素数标记。i的“自增”为j的倍数</span></span><br><span class="line">            isPrime[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Initial</span>();</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n) != EOF) &#123;</span><br><span class="line">        <span class="keyword">bool</span> isOutput = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prime.<span class="built_in">size</span>() &amp;&amp; prime[i]&lt;n; ++i) &#123;</span><br><span class="line">            isOutput = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,prime[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!isOutput)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分解质因数"><a href="#分解质因数" class="headerlink" title="分解质因数"></a>分解质因数</h3><p>给定一个数N（1&lt;N&lt;1E9），将其分解为多个质因数相乘  </p><blockquote><ol><li>分解质因数，需要用到上题素数筛选法，通过素数筛选法确定 1～sqrt(1E9)+1 之间的素数。</li><li>遍历素数序列： 用素数取整除 N，如果成功则为N的质因数，输出。直到 所有的素数都遍历结束。</li><li>遍历结束后需要判断 N 整除前面得到的质因数的结果是否大于1，如果大于一，则存在大于 sqrt(1E9)+1的质因数。需要输出。</li></ol><p><strong>（对于N来说之多存在一个大于 sqrt(n）的质因数）</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">40000</span>;</span><br><span class="line"><span class="keyword">bool</span> isPrime[MAXN];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; prime;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Initial</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXN; ++i) &#123;</span><br><span class="line">        isPrime[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    isPrime[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">    isPrime[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; MAXN; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!isPrime[j])&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        prime.<span class="built_in">push_back</span>(j);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = j*j; i &lt; MAXN; i=i+j) &#123;  <span class="comment">//从当前素数j的j倍开始，小于j的倍数由小于j的素数标记其不为素数。i 的值为j的倍数</span></span><br><span class="line">            isPrime[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Initial</span>();</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n) != EOF) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prime.<span class="built_in">size</span>() &amp;&amp; prime[i]&lt;=n; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span>(n%prime[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,prime[i]);</span><br><span class="line">                n /= prime[i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">1</span>)&#123;   <span class="comment">//未出尽的数大于则是素因数</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><p>对于 a^b 的快速算法思路：</p><blockquote><p>将b分解为若干个2^k的和  如： 3^29 ,  其中b为29 = 1 + 4 + 8 + 16;</p><p>a^b = a^k1 * a^k2 * … * a^km,  3^29 = 3^1 * 3^4 * 3^8 * 3^16;</p><p>这样       3^1 = 3</p><pre><code>      3^2 = 3^1 * 3^1      一次计算      3^4 = 3^2 * 3^2      二次计算      3^8 = 3^4 * 3^4      三次计算      3^16 = 3^8 * 3^8     四次计算</code></pre></blockquote><blockquote><pre><code>      3^29 只需要计算四次   普通乘法需要29次</code></pre></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">aEb</span><span class="params">(<span class="keyword">long</span> a, <span class="keyword">long</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> answer = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(b != <span class="number">0</span>)&#123;     </span><br><span class="line">        <span class="keyword">if</span>(b%<span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">            answer *= a;</span><br><span class="line">        &#125;</span><br><span class="line">        b /= <span class="number">2</span>;        </span><br><span class="line">        a *= a;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b) != EOF) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,<span class="built_in">aEb</span>(a,b));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="高精度整数运算C-类是现实"><a href="#高精度整数运算C-类是现实" class="headerlink" title="高精度整数运算C++类是现实"></a>高精度整数运算C++类是现实</h3><blockquote><p>高进度数之所以不好处理的在于无法存储。一般有两种比较常见的处理方式： </p><ol><li> 用字符串存储</li><li> 用数组存储</li></ol><p>用字符串存储，在编写相应的算术运算实现时，对字符串操作由于字符串的长度不一，两个高进度整数运算时需要考虑具体的处理问题比较多。用数组存储，好处是通过指定存储数组的空间，算术运算实现时，不需要考虑太多运算过程中的数的长度的影响，因为为存储数的数组元素中的大于数长度的部分值置为0，便于大数与小数的运算。确点是需要实现分配容纳数的大量空间，利用效率不一定高。</p></blockquote><p>一下的算法是基于数组存储高进度整数的。<strong>数组存储以十进制的方式，从0～MAXN的下标依次存储数的个位、十位、百位、….</strong></p><ol><li><p>高进度整数表示的类定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN  = <span class="number">10000</span>;  <span class="comment">//最大能存储的10进制数的位数</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BigInteger</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> digit[MAXN];  <span class="comment">//从0～MAXN 存放数字的 个位 十位 百位 ...</span></span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">BigInteger</span>();</span><br><span class="line">    <span class="built_in">BigInteger</span>(<span class="keyword">int</span> x);</span><br><span class="line">    <span class="built_in">BigInteger</span>(string str);</span><br><span class="line">    <span class="built_in">BigInteger</span>(<span class="keyword">const</span> BigInteger&amp; b);</span><br><span class="line">    BigInteger <span class="keyword">operator</span>=(<span class="keyword">int</span> x);</span><br><span class="line">    BigInteger <span class="keyword">operator</span>=(string str);</span><br><span class="line">    BigInteger <span class="keyword">operator</span>=(<span class="keyword">const</span> BigInteger&amp; b);</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;=(<span class="keyword">const</span> BigInteger&amp; b);</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> BigInteger&amp; b);</span><br><span class="line"></span><br><span class="line">    BigInteger <span class="keyword">operator</span>+(<span class="keyword">const</span> BigInteger&amp; b);</span><br><span class="line">    BigInteger <span class="keyword">operator</span>-(<span class="keyword">const</span> BigInteger&amp; b);</span><br><span class="line">    BigInteger <span class="keyword">operator</span>*(<span class="keyword">const</span> BigInteger&amp; b);</span><br><span class="line">    BigInteger <span class="keyword">operator</span>/(<span class="keyword">const</span> BigInteger&amp; b);</span><br><span class="line">    BigInteger <span class="keyword">operator</span>%(<span class="keyword">const</span> BigInteger&amp; b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; in, BigInteger&amp; x);</span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, BigInteger&amp; x);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>高进度整数类的构造函数实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">BigInteger::<span class="built_in">BigInteger</span>() &#123;</span><br><span class="line">    <span class="built_in">memset</span>(digit,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(digit));</span><br><span class="line">    length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger::<span class="built_in">BigInteger</span>(<span class="keyword">int</span> x) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(digit,<span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(digit));</span><br><span class="line">    length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">0</span>)&#123;                <span class="comment">//对于0的特殊处理</span></span><br><span class="line">        digit[length++] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(x != <span class="number">0</span>)&#123;</span><br><span class="line">        digit[length++] = x%<span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger::<span class="built_in">BigInteger</span>(string str) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(digit,<span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(digit));</span><br><span class="line">    length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = str.<span class="built_in">size</span>()<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) &#123;  <span class="comment">//注意数组存储的方式从低位到高位</span></span><br><span class="line">        digit[length++] = str[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger::<span class="built_in">BigInteger</span>(<span class="keyword">const</span> BigInteger &amp;b) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(digit,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(digit));</span><br><span class="line">    length = b.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">        digit[i] = b.digit[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure></li><li><p>赋值运算符的重载</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>=(<span class="keyword">int</span> x) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(digit,<span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(digit));</span><br><span class="line">    length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">0</span>)&#123;</span><br><span class="line">        digit[length++] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(x != <span class="number">0</span>)&#123;</span><br><span class="line">        digit[length++] = x%<span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>=(string str) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(digit,<span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(digit));</span><br><span class="line">    length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = str.<span class="built_in">size</span>()<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        digit[length++] = str[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>=(<span class="keyword">const</span> BigInteger &amp;b) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(digit,<span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(digit));</span><br><span class="line">    length = b.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">        digit[i] = b.digit[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li>输入、输出运算符重载<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; in,BigInteger &amp;x)&#123;</span><br><span class="line">    string str;</span><br><span class="line">    in&gt;&gt;str;</span><br><span class="line">    x = str;</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out,<span class="keyword">const</span> BigInteger &amp;x)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x.length<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        out&lt;&lt; x.digit[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure></li><li>高进度正整数的算术运算</li></ol><p>a. 比较</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> BigInteger::<span class="keyword">operator</span>&lt;=(<span class="keyword">const</span> BigInteger&amp; b)&#123;</span><br><span class="line">    <span class="keyword">if</span>(length &lt; b.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(b.length &lt; length)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = length<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (digit[i] == b.digit[i])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> digit[i] &lt; b.digit[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> BigInteger::<span class="keyword">operator</span>==(<span class="keyword">const</span> BigInteger &amp;b) &#123;</span><br><span class="line">    <span class="keyword">if</span>(length != b.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = length<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (digit[i] != b.digit[i])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b. 加法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>+(<span class="keyword">const</span> BigInteger &amp;b) &#123;</span><br><span class="line">    BigInteger answer;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> bound = length&gt;b.length ? length:b.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bound; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = digit[i] + b.digit[i] + carry;</span><br><span class="line">        answer.digit[answer.length++] = temp % <span class="number">10</span>;</span><br><span class="line">        carry = temp / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(carry == <span class="number">1</span>)&#123;  <span class="comment">//最高位有进位</span></span><br><span class="line">        answer.digit[answer.length++] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>加法运算比较简单，以两个数中最大的长度为遍历边界，对于每一位进行加和，留下和中小于10的部分，大于10的作为进位，加入高位的求和中。</p></blockquote><blockquote><p>注意： 两数的每一位遍历加和完成后，<strong>要判断最高位是否有进位（即进位的标记是否为1），如果有进位，则求和的结果在最高位前补1</strong>；</p></blockquote><p>c. 乘法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>*(<span class="keyword">const</span> BigInteger &amp;b) &#123;</span><br><span class="line">    BigInteger answer;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    answer.length = length + b.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length;  ++i) &#123;                 <span class="comment">//模拟：每位与乘数每一位运算后的，同权的位结果求和</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; b.length; ++j) &#123;</span><br><span class="line">            answer.digit[i+j] += digit[i] * b.digit[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; answer.length; ++k) &#123;           <span class="comment">//对于answer结果中的每一位超过10的进行修正进位</span></span><br><span class="line">        answer.digit[k+<span class="number">1</span>] += answer.digit[k] / <span class="number">10</span>;</span><br><span class="line">        answer.digit[k] %= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(answer.digit[answer.length<span class="number">-1</span>] == <span class="number">0</span> &amp;&amp; answer.length &gt; <span class="number">1</span>)&#123;   <span class="comment">//消除结果中多余的0</span></span><br><span class="line">        answer.length--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>乘法：稍微复杂一点</p><ol><li>模拟手动计算乘法的过程，即将乘数的从最低位一次去乘被乘数，要注意一个细节： <code>乘数的第i位 * 被乘数的第j位 = 结果的第(i+j)位</code>。将对应结果的权值相同的位加起来。</li><li>此时等到的结果中，每一位的值都可能大于10，需要对这些位做调整，将大于10的部分进位到高位，留下小于10的部分作为当前位的值。</li><li>乘法结果中可能存在连续多个高位到最高位为0，需要去除多余的0.否则对于根据数字有效长度判断大小的函数，会产生错误的比较结果。（如： 000 &gt; 0）</li></ol></blockquote><p>d.减法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>-(<span class="keyword">const</span> BigInteger &amp;b) &#123;     <span class="comment">//只使用于大数减小数的减法</span></span><br><span class="line">    BigInteger answer;</span><br><span class="line">    <span class="comment">//大数为this指向的对象，b为小数的对象</span></span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> bound = length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bound; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = digit[i] - b.digit[i] - carry;</span><br><span class="line">        <span class="keyword">if</span> (temp &gt;= <span class="number">0</span>)&#123;         <span class="comment">// 如果 被减数 大于等于 (减数+借位)则不需要进位</span></span><br><span class="line">            answer.digit[answer.length++] = temp;</span><br><span class="line">            carry = <span class="number">0</span>;   <span class="comment">// 如果没有借位需要把carry从1置为0否则会影响以后计算的结果</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            answer.digit[answer.length++]  = <span class="number">10</span> + temp;</span><br><span class="line">            carry = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(answer.digit[answer.length<span class="number">-1</span>] == <span class="number">0</span> &amp;&amp; answer.length &gt; <span class="number">1</span>)&#123;  <span class="comment">//去除结果中多余的0</span></span><br><span class="line">        answer.length--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>减法：<br>从被减数的低位到高位： 依次减去（减数对应权的位+低位相当前位的借位）。减后结果有两种情况：</p><ul><li>结果&lt;0 ,此时就需要向高位借位。 结果+10 修正， 借位置1</li><li>结果&gt;=0,此时结果无需修正，<strong>但是注意要将借位位置为0</strong><br>减法同样需要对于结果中多余的0进行修正</li></ul></blockquote><p>e. 除法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>/(<span class="keyword">const</span> BigInteger &amp;b) &#123;</span><br><span class="line">    BigInteger answer;</span><br><span class="line">    answer.length = length;</span><br><span class="line">    BigInteger remainder = <span class="number">0</span>;</span><br><span class="line">    BigInteger temp = b;   <span class="comment">// temp 存在的意义在于 比较运算符 &lt;= 前的对象不能是const 类型。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = length<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(remainder.length == <span class="number">1</span> &amp;&amp; remainder.digit[<span class="number">0</span>] == <span class="number">0</span>))&#123;   <span class="comment">//余数不为0</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = remainder.length<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j) &#123;  <span class="comment">//高位余数右移（向高位的方向移动）</span></span><br><span class="line">                remainder.digit[j+<span class="number">1</span>] = remainder.digit[j];</span><br><span class="line">            &#125;</span><br><span class="line">            remainder.length++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        remainder.digit[<span class="number">0</span>] = digit[i]; <span class="comment">//当前位并如余数中 ，成为新的被除对象</span></span><br><span class="line">        <span class="keyword">while</span>(temp &lt;= remainder)&#123;        <span class="comment">//除操作</span></span><br><span class="line">            remainder = remainder - temp;</span><br><span class="line">            answer.digit[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (answer.digit[answer.length<span class="number">-1</span>] == <span class="number">0</span> &amp;&amp; answer.length &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        answer.length--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>除法的操作：与加法、减法、乘法的不同之处在于，除法运算是从高位到低位的顺序<br>遍历被除数的每一位： </p><ol><li>高位的余数*10（右移一位）与当前位并入，作为新的被除对象。</li><li>对于被除对象的除操作可以表达为： 对被处对象不断的减去除数，对于最终商的当前位置不断加1，直到被除对象小于除数。此时被处对象的值就是当前位余数的值</li><li>遍历被除数的下一位</li></ol></blockquote><p>f. 取余<br>取余操作是与除法紧密相关的操作，即除法最终的余数，即位所求。<br>因此，取余的算法几乎与除法算法相同，只是移除了不需要保存的除法的商。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>%(<span class="keyword">const</span> BigInteger &amp;b) &#123;</span><br><span class="line">    BigInteger remainder = <span class="number">0</span>;</span><br><span class="line">    BigInteger temp = b;   <span class="comment">// temp 存在的意义在于 比较运算符 &lt;= 前的对象不能是const 类型。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = length<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(remainder.length == <span class="number">1</span> &amp;&amp; remainder.digit[<span class="number">0</span>] == <span class="number">0</span>))&#123;   </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = remainder.length<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                remainder.digit[j+<span class="number">1</span>] = remainder.digit[j];</span><br><span class="line">            &#125;</span><br><span class="line">            remainder.length++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        remainder.digit[<span class="number">0</span>] = digit[i];</span><br><span class="line">        <span class="keyword">while</span>(temp &lt;= remainder)&#123;</span><br><span class="line">            remainder = remainder - temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> remainder;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 机试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机试上手 </tag>
            
            <tag> 研究生复试上机题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DevOps是什么?为什么我们需要DevOps?</title>
      <link href="/2019/04/18/DevOps%E6%98%AF%E4%BB%80%E4%B9%88-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81DevOps/"/>
      <url>/2019/04/18/DevOps%E6%98%AF%E4%BB%80%E4%B9%88-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81DevOps/</url>
      
        <content type="html"><![CDATA[<p>什么是 DevOps? 公司在推行 DevOps 的进程中应该注意什么？只有大公司才能从 DevOps 中收益？~</p><p>英文原文：《What is DevOps and Why Do We Need It?》作者：Skywell Software<br>原文链接：<a href="https://medium.com/datadriveninvestor/what-is-devops-and-why-do-we-need-it-82c2ef0a9d3d">https://medium.com/datadriveninvestor/what-is-devops-and-why-do-we-need-it-82c2ef0a9d3d</a></p><span id="more"></span><h1 id="What-is-DevOps-and-Why-Do-We-Need-It"><a href="#What-is-DevOps-and-Why-Do-We-Need-It" class="headerlink" title="What is DevOps and Why Do We Need It?"></a>What is DevOps and Why Do We Need It?</h1><h1 id="DevOps-是什么？为什么我们需要它-？"><a href="#DevOps-是什么？为什么我们需要它-？" class="headerlink" title="DevOps 是什么？为什么我们需要它 ？"></a>DevOps 是什么？为什么我们需要它 ？</h1><p>The DevOps methodology has been recognized by many experts as the best way to promote cooperation between development and operations teams. However, DevOps is much more than a methodology. It is more of a culture that makes both the technical and business sides of software development much more efficient thus reducing time to market and increasing the <strong>overall</strong> quality of the product. Before we get into why DevOps is important, let’s get the definition of it first.</p><p>DevOps 被许多专家认为，是一种最好的方式去加强开发团队和运维团队的合作。但是 DevOps 不仅仅是一种方法，它更是一种文化使得软件开发过程中技术和业务双方合作更加高效，以使得产品上市时间缩短，产品<strong>整体</strong>的质量得以提升。在了解为什么 DevOps 这么重要之前，我们首先给它一个定义。</p><h2 id="DevOps-Definition"><a href="#DevOps-Definition" class="headerlink" title="DevOps Definition"></a>DevOps Definition</h2><h3 id="DevOps-定义"><a href="#DevOps-定义" class="headerlink" title="DevOps 定义"></a>DevOps 定义</h3><p>DevOps is an offspring of the Agile methodology that breaks down the barriers separating development and operations teams thus increasing collaboration between them. However, if you do not have the right culture in place, DevOps is just a <strong>buzzword</strong>. The following are some of DevOps culture:</p><p>DevOps 是，打破分隔 开发和运维团队壁垒，增强彼此之间合作的敏捷开发方法论的产物。但是如果你无法适当地应用这种正确的文化，DevOps 将沦为<strong>赶时髦的官话</strong>。这些使用 DevOps 文化所倡导的：</p><ul><li><p>Shared responsibility — In many companies, the development team is focused solely on creating the product and can become disinterest or even estranged operating and managing a system if it is somebody else’s job. If it is also part of the development team’s responsibility to monitor the system over the course of its existence, they are likely to feel the same pains operations teams are dealing with. This will lead to finding new ways of simplifying deployments and the maintenance by automating the deployments and better logging.</p><p>责任共有—— 在许多公司，开发团队单单专注于产品的开发，对于系统的运维和管理不感兴趣，甚至回避如果这是别人的工作。如果在系统运行期间的监控工作成为开发团队的职责的一部分，他们很可能就能够体会到运维团队工作是的痛苦。DevOps 产生了一种新的方式，通过自动化部署和很好的日志记录来简化部署和维护工作。</p></li><li><p>Autonomous teams — Effective collaboration is only possible when development and operations teams can make decisions and changes independently without a complicated decision-making process. This includes trusting your teams, adjusting the way risks are managed and getting rid of an environment where employees are afraid of taking risks or failing.</p><p>团队自主化——高效的合作仅仅会发生在没有复杂的决策流程，开发和运维团队能够独立的做决定和改动的情况下。这个就需要新人你的团队、调整风险管理的策略并避免员工惧怕承担风险和失败的情况。</p></li><li><p>Removing all <strong>silos</strong> （筒仓）— Some companies document the process and hand this documentation over to another team and consider this to be <strong>regular</strong> cooperation. Such an arrangement is doomed from the start because it promotes a culture of finger pointing and blaming. You must adjust resourcing structures to let operations teams start collaborating with other teams early on. One of the goals of DevOps is to blur the line between development and operations team to the point where there may not be a difference between them at all.</p><p>移除所有孤岛——一些公司记录过程并且将记录资料移交另一个团队，认为这是一个<strong>定期的</strong>合作。</p></li></ul><h2 id="The-DevOps-Lifecycle"><a href="#The-DevOps-Lifecycle" class="headerlink" title="The DevOps Lifecycle"></a>The DevOps Lifecycle</h2><h3 id="DevOps-的整个流程"><a href="#DevOps-的整个流程" class="headerlink" title="DevOps 的整个流程"></a>DevOps 的整个流程</h3><p>There are many stages that make up the DevOps lifecycle, but the process will look like the following:</p><p>DevOps 的整个流程由多个阶段组成，但是它们的如下列举的类似：</p><ul><li><p>Plan — This stage includes initial planning about how you <strong>envision</strong> the development process</p><p>计划——这个阶段包括你预期的开发进度的最初规划</p></li><li><p>Code — Coding the applications according to the requirements of the customer</p><p>编码——根据客户的需求开发应用程序</p></li><li><p>Build — Integrate all of the various codes you have written</p><p>构建——合并各个你编写的代码</p></li><li><p>Releases — If the testing phase was successful, the application could go live</p><p>发布——如果测试通过，应用可以上线</p></li><li><p>Deploy — The code is deployed to a cloud environment for additional usage</p><p>部署—— 为了一些附加的用途，程序部署到云环境下</p></li><li><p>Operate — Conduct the operations on the code</p><p>运维—— 在代码层面指导运维工作</p></li><li><p>Monitor — Keep an eye on how well the app is performing and make any changes necessary to satisfy the client.</p><p>监控—— 关注应用的运行情况，进行必要的改进以满足客户端的需求</p></li></ul><h2 id="Why-Do-We-Need-DevOps"><a href="#Why-Do-We-Need-DevOps" class="headerlink" title="Why Do We Need DevOps?"></a>Why Do We Need DevOps?</h2><h3 id="为什么我们需要-DevOps？"><a href="#为什么我们需要-DevOps？" class="headerlink" title="为什么我们需要 DevOps？"></a>为什么我们需要 DevOps？</h3><p>DevOps offers a lot of benefits for software programming companies such as increased innovation speed which will allow you to serve your customers better. You will also be more flexible to adjust to changing market conditions and drive higher business results. Since the speed and <strong>tempo</strong> of the releases will be frequent, you will be able to improve your product faster. This way you can release new features sooner, notice and fix bugs quicker and perhaps most importantly, respond to customer demands better to give your business a competitive advantage. Continuous integration and delivery (CI/CD) are <strong>practices</strong> that automate the software release process starting from the build and all the way to deployment.</p><p>DevOps 为软件开发公式带来的许多好处，例如，增加了创新的速度为客户更好的服务。能够使你在变化的市场环境下，灵活的调整产生更高的商业价值。由于频繁的迭代速度和<strong>节奏</strong>，你能更够快速的优化你的产品。这使得发布新特性的时间更短，发现和修复 bug 的速度更快。而更重要的是,快速的用户响应能力将成为你的业务的有力竞争优势。持续集成和持续发布就是从构建到部署的自动化软件发布过程的<strong>实践</strong>。</p><p>Even though the pace of production will increase, it has to be done so reliably. You will be able to use CI/CD to test all of the changes, and better monitoring and logging will help you continuously stay on top of how well your application is doing in real-time. Security process will not be <strong>compromised</strong>（妥协） since the <strong>compliance</strong>（服从）policies will be automated by using fine-<strong>grained</strong> controls and configuration management techniques.</p><p>虽然产品化的步伐被加速，但是它在完成时依然如此的稳定可靠。通过 CI/CD 你能够测试所有产品的变更，更好的监控和日志记录将帮助你保持你的应用在生产环境中一直运行在最佳状态。安全流程不会被影响，因为合规策略将被细<strong>粒度的</strong>控制和管理配置技术自动化。</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>If you are just <strong>embarking</strong>（上船）on your journey towards DevOps implementation, it is essential to set realistic goals expectations. While you may be eager to reap all the benefits of DevOps project management, your teams may experience culture shock, since they are used to the old siloed structure. It is not easy to change well-established processes, and it will take some time to implement on the people, process and information levels. This culture shock will usually come in the form of new goals. You cannot tell your teams, which are used to delivering one release a month, that they will need to have five releases every day from now on. This is simply not going to work.</p><p>如果你刚刚开始踏上 DevOps 落地之旅，设定切实可行的目标期望是必不可少的。当你迫切希望获得 DevOps 项目管理带来的好处时，你的团队可能经历着文化的冲击，因为他们一直习惯于原来独立的组织结构。改变已将建立好的流程并不容易，需要花费时间落实在人员、流程和信息等方面。这种文化的冲击将会带来新的目标表，你不能告诉的以前一个月迭代一个版本的团队，现在开始每天维护五个版本，这完全行不通。</p><p>You need to have a more structured approach with the understanding that the release schedule might slow down at first as your teams become acquainted with the DevOps culture and methodologies. This will require a lot of education, training and some time to get used to all of the changes. As the <strong>transition</strong> is going on, it is important to set and monitor business critical metrics such as overall <strong>revenue</strong> and customer satisfaction. There is no point in having multiple releases just for the <strong>sake</strong>（目的） of having various releases. It must make an impact on the bottom line.</p><p>当你意识到发布时间表应该在你的团队开始去接受 DevOps 文化和方法论时慢下来，你需要有一个更有组织的方式。需要许多的学习和训练，需要时间去习惯这所有的改变。在<strong>过渡</strong>过程中，建立一些重要的业务指标是重要的，如整体的收入和客户的满意度。以有各种本版的目的而创建多个版本是没有意义的。它必须对于你们的业务基础有效果。</p><p>Given all of the benefits that DevOps offers it is safe to say that companies who fail to implement DevOps process risk <strong>falling behind</strong>. One of the most common misconceptions is that DevOps is just for large companies when in fact small and medium-sized business can take advantage of everything DevOps has to offer. In fact, one of the reasons that companies such as Facebook, Netflix, and other conglomerates were able to achieve such rapid growth is because they were early adopters of DevOps and were able to deliver new features to their user faster than the competition. Therefore, if you have not yet begun implementing DevOps, you are falling behind your competitors.</p><p>考虑到 DevOps 所带来的优点，可以负责任的说那些没有完成 DevOps 进程化的公司将面临<strong>落后</strong>的风险。一个普遍的错误观点是 DevOps 仅仅针对大公司，但是小型和中等规模的公司也能够从中获得 DevOps 所提供的好处。事实上，像 Facebook、Netflix 和 其他的集团公司能够实现如此快速的增长，是因为他们很早就采用了 DevOps 的模式，使得他们能够相对于竞争对手更快的提供新功能给用户。因此，如果你还没有开始 DevOps 的进程，你已经落后于你的竞争者了。</p>]]></content>
      
      
      <categories>
          
          <category> 翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> open source </tag>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-Web框架介绍</title>
      <link href="/2019/04/17/Python-Web%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/"/>
      <url>/2019/04/17/Python-Web%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p>针对 Python 中的 全栈框架（Django） 和 微型框架（Flask）行进介绍，对于一些应用特定场景的其他框架做简单的说明~</p><p>英文原文：《A Complete Guide to Python Web Frameworks》作者：Premjith B P K</p><p>原文链接：<a href="https://opensourceforu.com/2019/04/a-complete-guide-to-python-web-frameworks/">https://opensourceforu.com/2019/04/a-complete-guide-to-python-web-frameworks/</a></p><span id="more"></span><h1 id="A-Complete-Guide-to-Python-Web-Frameworks"><a href="#A-Complete-Guide-to-Python-Web-Frameworks" class="headerlink" title="A Complete Guide to Python Web Frameworks"></a>A Complete Guide to Python Web Frameworks</h1><h1 id="Python-Web-框架介绍"><a href="#Python-Web-框架介绍" class="headerlink" title="Python Web 框架介绍"></a>Python Web 框架介绍</h1><p>Web frameworks are code libraries that make Web development faster and easier. The <strong>versatile</strong> programming language, Python, has many Web frameworks like Django, Web2py, Flask, Bottle, etc. We take a closer look at these in this article.</p><p>Web 框架就是一些函数库，通过使用这些库使得 Web 开发更加简单快捷。Python 作为<strong>多功能的</strong>编程语言，有许多 Web 框架，像 Django、Web2py、Flask 和 Bottle等等。接下来我们将来介绍这些框架的相关情况。</p><p>Python is a valuable and flexible programming language designed specifically for teams trying to get a Web application up and running. Developers and frameworks are closely related since they are the building blocks of the products being <strong>crafted</strong>. With such frameworks, a set of solutions is born, thereby allowing the developer to focus more on the app logic rather than repetitive and other low-priority tasks.</p><p>对于开发 Web 应用程序的团队，Python 是一种主流且非常灵活的编程语言。应用程序以一种模块化的开发模式进行<strong>开发</strong>，使得开发者和 Web 框架紧密的联系起来。调用框架中提供的大量的解决方案，使得开发者能够更加专注于应用程序的逻辑业务，不再为重复和低优先级的任务所扰。</p><p>Nowadays, developers try Python’s <strong>robust</strong> collection of frameworks to deal with the details of the implementation, which helps to <strong>hasten</strong> the development and <strong>prototyping</strong> process. There are various well known Python Web frameworks out there – from vigorous full-stack frameworks specifically designed for enterprise based solutions to <strong>ultra-lightweight</strong> micro-frameworks streamlined for developing small and specialised tools.</p><p>如今，开发者尝试使用<strong>强大功能的</strong> Python 框架去解决解决一些具体的实现细节，这个<strong>加速</strong>了<strong>原型</strong>设计和开发的进程。从针对企业的强大全栈框架到适合开发小型专业的工具的<strong>超轻量级</strong>微框架流，目前有各种各样的流行的 Python Web 框架。</p><p>Python Web frameworks help in greatly cutting down the cost, the effort and the time spent on Web app development. We will share some key functionalities of these <strong>intriguing</strong> frameworks to help you during Web application development. In this article we aim to help you settle on the best framework, based on your needs.</p><p>Python Web 框架在很大程度上削减了 Web 应用开发的成本、人力和时间周期。我们将分享这些<strong>流行</strong>框架中一些重要功能点，帮助在你开发 Web 应用程序中做的更好。我们希望能够帮助你确定针对自己实际需求的最合适框架。</p><h2 id="What-are-Web-frameworks"><a href="#What-are-Web-frameworks" class="headerlink" title="What are Web frameworks?"></a>What are Web frameworks?</h2><h3 id="框架的作用"><a href="#框架的作用" class="headerlink" title="框架的作用"></a>框架的作用</h3><p>Web frameworks enable developers to create Web applications and services without getting into the details like sockets, protocols, thread management, etc. Some of the common duties of a Web framework are to handle cookies, get form parameters, deal with sessions, etc. There are two main types of frameworks available – the full-stack and the micro-framework.</p><p>Web 框架使得开发者不需要去关注 Socket、协议 和 线程管理 等细节，专注于 Web 应用程序和服务的开发。框架的完成的大部分职责集中于 cookies 的处理、参数的获取以及 session 的处理等。主流的 Web 框架分为两大类：全栈框架 和 微型框架。</p><h2 id="Full-stack-or-micro-framework"><a href="#Full-stack-or-micro-framework" class="headerlink" title="Full-stack or micro-framework?"></a>Full-stack or micro-framework?</h2><h3 id="选择全栈框架还是微型框架"><a href="#选择全栈框架还是微型框架" class="headerlink" title="选择全栈框架还是微型框架"></a>选择全栈框架还是微型框架</h3><p>You should be extremely focused while picking a framework, and the key things to consider should be the size and <strong>sophistication</strong> of the project. In case you’re hoping to get a function-oriented Web application that will collaborate with <strong>the rest of</strong> your <strong>association</strong>’s frameworks, then a full-stack alternative could help your team both in terms of time and effort. However, if you’re working on a small and relatively simple project with minimal requirements, a micro-framework is your best bet. A related question is: how much effort will you require from the framework? A full-stack Web framework should have all the components you require to develop a fully functional Web app – frame generators, access lists, templating, etc – so your team can assemble the page or app as per requirements. This is an <strong>alluring</strong> option for teams that are attempting to build a product quickly, since it enables them to focus only on the development of the app and not everything else that revolves around it. In any case, if you have sophisticated custom requirements or are already working with different types of custom software, you can’t exploit those libraries.</p><p>当你在框架选择时，你应该将项目规模和<strong>复杂</strong>性作为考虑的重要因素。如果你希望应用的开发以业务功能为主，需要与<strong>其他的</strong>周边框架协作，全栈框架的选择将能够减少整个团队在开发时间和开发任务。但是，如果你在开发一个小型、简单需求的少的项目时，微型框架是你最好的选择。另一个需要考虑的问题是：你需要框架帮你完成多少事情？全栈 Web 框架包含了开发一个功能丰富 Web 应用的所有组件—框架生成器、访问列表和模板等。这使得你的团队能根据不同的需求创建出相应的页面和应用。对于希望快速开发出产品的团队这是一个很好的选择，因为这是使得他们更加专注于应用的开发而不是与之相关的周边事情。如果你有复杂的个性化需求或者已经在开发多种不同类型的定制化的软件，不管在什么情况下，你都不应该使用这些框架。</p><h2 id="Full-stack-frameworks"><a href="#Full-stack-frameworks" class="headerlink" title="Full-stack frameworks"></a>Full-stack frameworks</h2><h3 id="全栈框架"><a href="#全栈框架" class="headerlink" title="全栈框架"></a>全栈框架</h3><p>There are a whole new set of full-stack options available among Python frameworks. Some of the prominent frameworks are TurboGears 2, Pylons, and Web2py. But the most popular one among them is Django.</p><p>有许多新且完备的全栈 web Python框架选择方案：如主流的框架 TurboGears 2、Pylons 和 Web2py。但是其中最流行的是 Django。</p><ul><li><p>Django</p><p>This is the most well-known Python framework and anyone can easily justify the reason behind it. A huge number of websites already use Django, from publishing houses to social media and sharing sites to significant <strong>establishments</strong> and non-profits. Since Django was initially developed for use in the newsroom, it’s not a big deal that dailies like the Washington Post and <strong>The Guardian</strong> work on this framework. New companies and startups like Eventbrite and Disqus have migrated to Django to improve conversion rates, while social media giants like Instagram and Pinterest have used it to control their dynamic Web apps.</p><p>Django 是流程的 Python 框架，至于具体的原因大家不难理解。大量的网站使用了 Django，从出版社到社交媒体和分享网站，再到重要的<strong>机构</strong>和非盈利组织。由于 Django 最初开发于编辑部门，因此 华盛顿邮报 和 <strong>卫报</strong> 运行在该框架上也不是意外。一些新公司和初创公司像 Eventbrite 和 Disqus 已经在往 Django 迁移并且在提高完成度。同时社交巨头 Instagram 和 Pinterest 已经使用该框架去开发他们的动态 Web 应用。 </p><p>When considered as a framework, Django is known for being quick to build and friendly for <strong>amateur</strong> developers. It’s a ‘<strong>batteries</strong> （电池）included’ framework, which means it supplies all the basic components you require such as authentication, rendering template, ORM, routing, etc. It’s also well documented, which isn’t the case with some other mainstream Web frameworks.</p><p>当考虑到框架时，Django 以快速开发 和 对业务开发者友好 而著称。作为一种“可插拔式”的框架，它提供了所有你需要的基础的组件 认证、可渲染模板、ORM 和路由等。相比于其他的主流 Web 框架，它有良好的技术文档。</p><p>Django can considerably reduce the time taken to bootstrap a new project by dealing with a lot of choices. However, what you gain in speed can be lost in long-term flexibility. For instance, the inbuilt ORM of Django works efficiently in major <strong>scenarios</strong>. However, it’s not as <strong>ground breaking</strong>（破土动工） as SQLAlchemy, which is also <strong>termed</strong> the best Python database abstraction tool. While you can <strong>hypothetically</strong> use SQLAlchemy with Django, you’ll lose out on some major functionalities that make Django so appealing to start with.</p><p>通过对大量选择的处理，Django 能够在很大程度上减少新项目的引导时间。但是，在获得速度的同时也牺牲了长期开发维护的灵活性。例如，Django 内置的 ORM 在大部分<strong>情况</strong>下效果显著。但是，它无法像<strong>被称为</strong>最好的 Python 数据库抽象工具 SQLAlchemy那样有突破性。你可以想象在 Django 下使用 SQLAlchemy，但是那样你讲失去 Django 中的一些一开始就吸引人的重要功能。</p></li></ul><ul><li><p>Web2py</p><p>This is another prominent full-stack framework. One thing to remember about Web2py is that it isn’t compatible with Python 3. The original developers behind Web2py have guaranteed a compatible successor for Python 3, but haven’t launched it till now.</p><p>Web2py 是另一个主流的全栈框架。需要牢记的是 Web2py 不兼容 Python3。虽然 Web2py 的早期开发者已经保证会去开发兼容 Python3 的新版，但时至今日依然没有新版依然没有正式发布。</p><p>Even though it is ten years behind the most recent version of Python, Web2py is still used by many major enterprises, including <strong>multinational</strong> banks. What makes this older Web framework still engaging for developers is its unique functionalities. For one, it’s as simple and easy to learn as Django, and is more flexible and portable too. The same code can be employed for almost any <strong>VPS</strong>（Virtual Private Servers） with a SQL database or MongoDB, regardless of whether AWS or Google App Engine are used.</p><p>即便相较目前最新发布的 Python 版本已经十年时间了，Web2py 依然在许多大型企业中使用，其中就包括<strong>跨国</strong>银行。使得这个老 Web 框架依然有许多开发者在使用的原因，是他独一无二的功能。一方面，它即能够像 Django 一样简单易学习，又兼具灵活性和可扩展能力。不管是 AWS 还是 Google App Engine 中 VPS， 同样的一段代码几乎可以应用到 所用的使用 SQL  或者 Mongo DB 的 VPS 中 。</p><p>Web2py has got <strong>intense</strong> support — it is well-documented and has a strong community behind it. Another perfect element is that Web2py is accompanied by its very own <strong>IDE</strong>（ Integrated Developer Editor） that incorporates a code editor, debugger, bug ticketing framework, a single tick deployment, etc. If your organisation is focused on Python 2 for the coming years or you intend to make use of some more established Python libraries and software, then Web2py could perfectly suit your requirements.</p><p>Web2py 有优秀的文档手册和活跃的社区在其背后作为<strong>强大的</strong>支持。另一个亮点在于 Web2py 有自己的IDE，其中包含了 代码编辑器、调试器、bug 票务框架 和 单独的票务部署功能等等。如果你的团队在未来几年中开发以 Python2 为主，或者希望充分利用已有的众多 Python 库和应用，那么 Web2py 框架非常符合你的要求。</p></li><li><p>Pyramid</p><p>Pyramid isn’t exactly a full-stack framework but bills（账单） itself as the Goldilocks framework. Pyramid is enriched with features without forcing any particular way of getting things done on users. It is lightweight without leaving you all alone as your app develops. It’s one of the most loved Web frameworks among experienced Python developers on account of its <strong>transparency</strong> and modularity, and has been used by both <strong>moderately</strong> sized teams as well as tech giants like Mozilla, Yelp, SurveyMonkey and Dropbox.</p><p>Pyramid 确切的来说不是一个全栈的 Web 框架，并且自称是符合“金发姑娘”原则（<strong>适度原则</strong>）的框架。Pyramid 有这丰富的特性不会限制使用某种特定的方式去处理事情。作为一种轻量级的框架，不会使你随着应用的开发陷入独自一人的窘境。由于良好的<strong>通透性</strong>和模块化，Pyramid 是 Python 老鸟最喜爱的开发框架。不仅中等规模的团队在使用，像 Mozilla、Yelp、SurveyMonkey 和 Dropbox 这样的科技巨头也在使用。</p><p>In reality, almost every component of a Pyramid framework can be <strong>swapped</strong> out. You can pick how you interface with a database, or even what type (or types) of databases you want to connect with. It doesn’t <strong>authorise</strong> certain choices for you like Django does, and it also <strong>discourages</strong> some ‘magic’ features which handle certain assignments automatically. It also doesn’t behave in an <strong>anticipated</strong> or attractive way.</p><p>事实上，Pyramid 框架中几乎所有的组件都能够替换掉。你能够使用你的数据库接口，甚者连接任何你想要连接的数据库。它不会像Django那样授权处理具体的选择，也不鼓励自动化处理具体任务的奇妙功能。这使得它不会表现预期的或者吸引人的方式。</p><p>Pyramid is popular because of its security solutions, which make it simple to set up and to check access control records. Another innovative functionality worth mentioning is Pyramid’s Traversal system for mapping URLs to code, which eventually makes it easy to build RESTful APIs.</p><p>Pyramid 流程的原因是它安全的解决方案，使得访问控制记录的创建和检查变得简单。另一个值得关注的创新功能是 Pyramid 的从 URL 到 code 的映射的路由系统，这使得最终创建 RESTful 接口变得容易。</p></li></ul><h2 id="Micro-frameworks"><a href="#Micro-frameworks" class="headerlink" title="Micro-frameworks"></a>Micro-frameworks</h2><h3 id="微型框架"><a href="#微型框架" class="headerlink" title="微型框架"></a>微型框架</h3><p>Consider the possibility that you don’t need handholding or the sophistication of a full-stack framework. Nowadays, modern Web apps require lots of moving parts, including database abstraction, frame approval and modified access control records. But there are a lot of Web applications that don’t require any of it. For such projects, a micro-framework might be exactly what’s required.</p><p>考虑到你可能不需要全面和丰富的全栈框架。如今，新一代的 Web 应用需要许多可以插拔的部分，包括数据库抽象层，框架认证 和 可配置的访问控制规则。但是也有大部分的 Web 应用不要这些模块。对于这种项目，微型框架应该是最需要的。</p><p>These ultra-lightweight frameworks are developed to get dead Web apps up and running as fast as possible. Their capabilities are minimal by design– any functionality you could get by installing another library is intentionally left out. An advantage of working with this moderate approach is that your code can be cleaner and the site quicker. This is because micro-frameworks are less abstracted than full-stack structures. The code you compose will be significantly closer to HTTP capacities than with a more beginner-friendly framework.</p><p>这些超轻量级的应用被开发的目的是使得一些死掉的 Web 应用重新能被使用并且尽可能的运行的更快。他们的设计的功能精简—————— 对一些能通过安装一些其他的库满足的功能专门进行了移除。使用这些透明的方法的好处是使你的代码更加的简洁清晰，并且网站运行速度更快。这就是为什么微型框架没有全栈框架那么抽象。相比于对初学者友好的 Web 框架，你编写的代码将需要触及HTTP 的一些功能。</p><ul><li><p>Flask: </p><p>Flask is undoubtedly the most famous micro-framework for Python and a standout amongst the most well-known Python structures, period. Like Django, it was developed to get Web applications up and running as fast and effortlessly as possible. Regardless of its <strong>tiny</strong> size, Flask has been used by huge organisations, including LinkedIn and Pinterest.</p><p>Flask 无疑是最有名的 Python 微型框架，并且一直是最有名的 Python 结构中的佼佼者。和 Django 一样，开发 Flask 的目的是使得 Web 应用开发并尽可能运行的更快。虽然是微型框架，但 Flask 已经被一些大公司所使用，其中包括 LinkedIn 和 Pinterest。</p><p>In any case, here’s the twist – since Flask is ideal for smaller, easier projects than Django, you can expect Web server development, support for Google App Engine and inbuilt unit testing. There is no database abstraction layer, form verification and validation, and auto upload features are disabled. However, every one of these features can be included via extensions. Some key setups incorporate SQLAlchemy for the database or Jinja2 for templating and CouchDB.</p><p>无论如何，这是个较量。相比 Django，Flask是那些又小又简单项目的理想选择。因此，你可以期待 Web 服务器开发将支持 Google App Engine 并且 内置单元测试功能。Flask 不支持 数据库抽象层 和 表单验证，且自动上传的功能被禁用。但是，每一个这些功能都能够通过外部扩展来实现。例如一些主要的扩展包括 SQLAlchemy 数据库 、 Jinja2 模板和 CouchDB。</p><p>Some Python designers opt for Flask rather than Django <strong>on the grounds that</strong> the former is increasingly pythonic, in that, it generally <strong>adheres</strong>（依附） to the Python <strong>mantra</strong>（口头禅） of there being one approach to accomplish something, and that code ought to be clear about what it’s doing. In case you prefer clean code <strong>from scratch</strong>, Flask might be a <strong>decent</strong> alternative.</p><p>一些 Python 开发者会选择 Flask 而非 Django ，<strong>因为</strong>前者越来越 Pythonic。这更加符合 Pytho 之<strong>禅</strong>的原则：一种方式完成事情，并且相应的代码能够表明在做什么。如果你非常想要从头开始使代码更加简洁明了，Flask 应该是你合适的选择。</p></li><li><p>Bottle: </p><p>Bottle is another prominent micro-framework. It was initially developed for building Web APIs, which is still an excellent use case for it. What is more <strong>intriguing</strong> about Bottle is that it tries to execute everything in one single document, which should give you a brief idea of how micro it is designed to be.</p><p>Bottle 是另一个主流的微型框架。它从一开始就是为创建 Web API 而生，这也是它最好的使用案例。Bottle 更加<strong>奇妙</strong>的地方在于，它尝试使用一个单一的文件做所有的事情，这给我们一个重要的认识：它的设计是多么的 micro。</p><p>The <strong>out-of-the-box</strong> functionalities include templating, routing, utilities, and some fundamental abstraction over the WSGI standard. Like Flask, you’ll be coding significantly nearer to the <strong>metal</strong> than with a full-stack system. Regardless of that, Bottle has been employed by Netflix to create Web interfaces.</p><p>Bottle 包含一些<strong>开箱即用的</strong>功能包括 模板、路由、应用程序 和 一些在 WSGI 标准上的基础抽象。和 Flask 一样，有你的编码将更接近底层相比于全栈框架。尽管如此，Bottle 已经被 Netfilx 用于创建 Web 接口。</p></li></ul><h2 id="Other-popular-frameworks"><a href="#Other-popular-frameworks" class="headerlink" title="Other popular frameworks"></a>Other popular frameworks</h2><h3 id="其他一些流行的框架"><a href="#其他一些流行的框架" class="headerlink" title="其他一些流行的框架"></a>其他一些流行的框架</h3><p>We’ve gone through some of the most widely used Python systems, yet there are a variety of options you could choose from. We’ll quickly take a look at a couple of others which could perform well in particular circumstances.</p><p>我们已经介绍了许多广泛使用的 Python Web 框架，你可以从中有不同的选择。接下来将了解一些在特定情况下表现优良的其他框架。</p><p><strong>Tornado</strong> is a Python Web framework particularly developed to tackle the C10k issue (i.e., it can deal with over 10,000 simultaneous connections if properly configured) using asynchronous I/O. This gives it solid appeal for projects that require <strong>elite</strong> and countless concurrent users.</p><p>Tornado 是专为解决 <strong>C10k</strong> 问题而开发的 Python Web 框架。（在正确配置下，它能够通过异步 I/O 处理超过 10,000 并发连接数）这个对于那些需要高质量且大量并发用户的项目是一个巨大的吸引力。</p><p><strong>CubicWeb</strong> is an intriguing Web framework that is entirely different from the other frameworks. It’s a piece of the <strong>semantic</strong> Web. In a <strong>layman</strong>’s <strong>terms</strong>（条款）, it’s a system that strives to display information in a way that is less demanding for PCs to get it. It replaces the model and view portion of MVC with a solitary concept – the data cube which can be used to develop different components, similar to Docker for the Web.</p><p>CubicWeb 是一个奇妙的 Web 框架，它完全不同其他的 Web 框架。它是<strong>语义</strong> Web 的一种，用<strong>外行人</strong>的话将，它是一个通过减少对于电脑系统性能要求的方式来显示信息的系统。它使用一个单独的概念替代了 MVC 模型中的 model 和 view ，即数据块———能够由于开发不同的组件，有点像 Web 上的 Docker。</p><p><strong>Phalcon</strong> is a micro-framework that is tied in with building cloud APIs. Like other micro-frameworks, it keeps minimal dependencies and maintains a strategic distance from complex features. However, unlike other systems, it wasn’t developed for serving HTML pages. Rather, it’s for building RESTful APIs quickly.</p><p>Phalcon 是一个专注于创建云 API 的微型框架。和其他微型框架一样，它保持的较少的依赖，并且与复杂功能保持着一个明智的距离。但是，不同于其他框架，它不是为 HTML 的页面而开发的，而是，为更快的创建 RESTful API 而生。</p><p>Even though Android has a remarkable SDK （Software Development Kit）out-of-the-box, the implementation of Python instead of Java is a huge advantage for website and app development (using Kivy) since it offers quicker turnaround times and the reuse of Python libraries.</p><p>即便 Android 有非常优秀开箱即用的 SDK ，但使用 Python 实现替代 Java 实现有着巨大的好处，对于网站和应用开发（使用 Kivy 移动应用开发的 Python 开源库 ）。因为 Python 提供了更快的时间转化和库的复用。</p><p>Python is a reliable and secure development language that is used for secure and <strong>agile</strong> Web app development. It is a standout amongst the available options, being the most dependable. It will reduce the development time spent trying to create a <strong>top-notch</strong> and robust Web app and site. You can consult with an experienced Python developer for your next project, for better guidance.</p><p>Python 作为一个可靠、安全的开发语言，被用于安全<strong>敏捷</strong> Web 应用的开发。作为可靠备选中的佼佼者，它减少了<strong>顶尖</strong>稳定 Web 应用和网站的开发周期。你可以在开发你的下一个项目时，咨询有经验的 Python 开发人员，以得到更好的指导。</p>]]></content>
      
      
      <categories>
          
          <category> 翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> open source </tag>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何通过在不写代码的情况下做开源</title>
      <link href="/2019/04/16/%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E5%9C%A8%E4%B8%8D%E5%86%99%E4%BB%A3%E7%A0%81%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E5%81%9A%E5%BC%80%E6%BA%90/"/>
      <url>/2019/04/16/%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E5%9C%A8%E4%B8%8D%E5%86%99%E4%BB%A3%E7%A0%81%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E5%81%9A%E5%BC%80%E6%BA%90/</url>
      
        <content type="html"><![CDATA[<p>本文作者阐述了，如果在不写代码的模式下，优雅的为开源事业做贡献~</p><p>英文原文：《How do you contribute to open source without code?》作者： Chris Hermansen<br>原文链接：<a href="https://opensource.com/article/19/4/contribute-without-code">https://opensource.com/article/19/4/contribute-without-code</a></p><span id="more"></span><h1 id="How-do-you-contribute-to-open-source-without-code"><a href="#How-do-you-contribute-to-open-source-without-code" class="headerlink" title="How do you contribute to open source without code?"></a>How do you contribute to open source without code?</h1><h1 id="如何通过不写代码的方式为开源做贡献"><a href="#如何通过不写代码的方式为开源做贡献" class="headerlink" title="如何通过不写代码的方式为开源做贡献"></a>如何通过不写代码的方式为开源做贡献</h1><p>My earliest open source contributions date back to the mid-1980s when our organization first connected to UseNet where we discovered the contributed code and the opportunities to share in its development and support.</p><p>我最早开始为开源做贡献要追溯到20世纪80年代中期。那是我们组织第一次连接到UseNet网站，在那里我们了解到了代码贡献以及为其开发和维护的机会。</p><p>Today there are endless contribution opportunities, from contributing code to making how-to videos.</p><p>今天，有很多种方式去做贡献，从代码贡献到制作教程。</p><p>I’m going to <strong>step right over</strong> the whole issue of contributing code, other than pointing out that many of us who write code but don’t consider ourselves developers can still contribute code. Instead, I’d like to remind everyone that there are lots of non-code ways to contribute to open source and talk about three alternatives.</p><p>我将<strong>一步步</strong>说明代码贡献这个问题，而不是仅仅指出“那些写代码却不认为自己是开发者的人，依然能够贡献代码”。我愿意告诉每个人：有很多种不通过写代码的方式贡献开源社区的方法。具体谈谈这种不写代码的贡献方式。</p><h2 id="Filing-bug-reports"><a href="#Filing-bug-reports" class="headerlink" title="Filing bug reports"></a>Filing bug reports</h2><h3 id="提交-bug-报告"><a href="#提交-bug-报告" class="headerlink" title="提交 bug 报告"></a>提交 bug 报告</h3><p>One important and <strong>concrete</strong> kind of contribution could best be described as “not being afraid to file a decent bug report” and all the consequences related to that. Sometimes it’s quite challenging to file a decent bug report. For example:</p><p>一种主要、<strong>集中</strong>的代码贡献方式被称为“不要害怕创建一个体面的 bug 报告”，接下来得内容主要是关于这中方式。有时，编写一个相当好的的 bug 报告是一件相当有挑战的事情。比如：</p><ul><li><p>A bug may be difficult to record or describe. A long and complicated message with all sorts of unrecognizable codes may flash by as the computer is booting, or there may just be some “odd behavior” on the screen with no error messages produced.</p><p>一些 bug 可能很难记录并秒速。例如 一个带有一系列的不可知代码的冗长复杂信息可能在计算机启动时闪现，或者导致一些奇怪的现象并且显示屏没有相应的错误信息产生。</p></li><li><p>A bug may be difficult to reproduce. It may occur only on certain hardware/software configurations, or it may be rarely <strong>triggered</strong>, or the <strong>precise</strong> problem area may not be apparent.</p><p>一些 bug 可能是很难复现的。它仅仅在一些特定的 软件/硬件 配置下，并且很难再次<strong>触发</strong>，对于某些<strong>具体</strong>的问题可能并不明显。</p></li><li><p>A bug may be linked to a very specific development environment configuration that is too big, <strong>messy</strong>, and complicated to share, requiring laborious creation of a <strong>stripped-down</strong> example.</p><p>一些 bug 可能涉及到一些非常具体的庞大、<strong>混乱</strong>、复杂开发环境配置，以至于 bug 的提交非常困难。需要花力气去创建一些<strong>精简</strong>的测试案例。</p></li><li><p>When reporting a bug to a <strong>distro</strong>, the maintainers may suggest filing the bug upstream instead, which can sometimes lead to a lot of work when the version supported by the distro is not the primary version of interest to the upstream community. (This can happen when the version provided in the distro <strong>lags</strong> the officially supported release and development version.)</p><p>当提交一个<strong>分支</strong>版的软件 bug 时，维护者会建议提交上流版本的 bug 测试情况。在当前版本不是社区上流推崇的版本的分支时，这将产生许多工作量。（这个通常发生在分支版本的维护<strong>滞后</strong>于官方当前的发行版和开发版时）</p></li></ul><p><strong>Nevertheless</strong>, I <strong>exhort</strong> would-be bug reporters (including me) to press on and try to get bugs fully recorded and acknowledged.</p><p><strong>尽管如此</strong>，我依然<strong>倡导</strong> 未来的 bug 提交者 能够重视并尽可能详细的记录和说明 bug 的情况。</p><p>One way to get started is to use your favorite search tool to look for similar bug reports, see how they are described, where they are filed, and so on. Another important thing to know is the formal mechanism defined for bug reporting by your distro (for example, Fedora’s is here; openSUSE’s is here; Ubuntu’s is here) or software package (LibreOffice’s is here; Mozilla’s seems to be here).</p><p>在开始时，通过自己喜欢的检索工具去寻找相关的 bug 报告，看看它们是如何描述，怎样展现等等。另一种重要的需要知道的是 bug 提交报告的正式术语，关于你用的系统分发版本（Fedora、openSUSE、Ubuntu） 或者 使用的软件（LIbreOffice、Mozilla） 。</p><h2 id="Answering-user’s-questions"><a href="#Answering-user’s-questions" class="headerlink" title="Answering user’s questions"></a>Answering user’s questions</h2><h3 id="解决用户的问题"><a href="#解决用户的问题" class="headerlink" title="解决用户的问题"></a>解决用户的问题</h3><p>I <strong>lurk</strong> and occasionally participate in various mailing lists and forums, such as the Ubuntu quality control team and forums, LinuxQuestions.org, and the ALSA users’ mailing list. Here, the contributions may relate less to bugs and more to documenting complex use cases. It’s a great feeling for everyone to see someone jumping in to help a person sort out their trouble with a particular issue.</p><p>我<strong>潜水</strong>并偶尔参与到各种各样的邮件列表和论坛，像 Ubuntu quality control 小组或者论坛、LinuxQuestions.org 和 the ALSA users’ 邮件列表。在这里，主要的贡献不是 bug 的提交和修复，更多的是编写软件相关的使用案例。当有人加入讨论并解决他们的特殊问题时，每一个人都有一种喜悦。</p><h2 id="Writing-about-open-source"><a href="#Writing-about-open-source" class="headerlink" title="Writing about open source"></a>Writing about open source</h2><h3 id="为开源而创作"><a href="#为开源而创作" class="headerlink" title="为开源而创作"></a>为开源而创作</h3><p>Finally, another area where I really enjoy contributing is writing about using open source software; whether it’s a how-to guide, a comparative evaluation of different solutions to a particular problem, or just generally exploring an area of interest (in my case, using open source music-playing software to enjoy music). A similar option is making an instructional video; it’s easy to record the desktop while demonstrating some fiendishly difficult desktop <strong>maneuver</strong>, such as creating a <strong>splashy</strong> logo with GIMP. And those of you who are bi- or multi-<strong>lingual</strong> can also consider translating existing how-to articles or videos to another language.</p><p>最后，另一个我喜欢的贡献方式是通过创作一些关于开源软件的使用的资料。包括 如何使用的指南、一个针对特殊问题，同类软件之间的测评 以及 对于一个感兴趣领域的探索（就我而言，使用开源的音乐播放器来聆听音乐）。一个类似的方式是制作软件使用教程视频，以一种简单的方式录制一些困难的桌面<strong>操作</strong>，如使用GIMP创作一个<strong>引人注目</strong>的logo。如果你熟悉两种或者多种<strong>语言</strong>可以考虑将目前的已有的一些文字教程和视频教程翻译为另一种语言。</p>]]></content>
      
      
      <categories>
          
          <category> 翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> open source </tag>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你应该知道的markdown语法</title>
      <link href="/2019/03/13/%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84markdown%E8%AF%AD%E6%B3%95/"/>
      <url>/2019/03/13/%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84markdown%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>关于 markdown 常用的一些语法，方便我们以 markdown 的方式记录生活~</p><span id="more"></span><p>你还在用word写笔记、心得体会、说明文档之类的东东吗？是不是还在为word的排版而烦恼? ^_^<br>快来试试,代码圈最风靡的说明文档编写姿势吧，markdown 让你在了解几分钟语法的情况,专注于内容的输出。下面我们一起来看一看这些经常用到的语法~</p><!--  --><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 大秦帝国</span></span><br><span class="line"><span class="section">## 长平杀降</span></span><br></pre></td></tr></table></figure><p>标题总共有六级</p><p>效果：</p><img src="/2019/03/13/%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84markdown%E8%AF%AD%E6%B3%95/%E6%A0%87%E9%A2%98.png" class="" title="标题效果"><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; 白起奉亲昭襄王诏令，坑杀赵国数十万放下武器的士兵</span></span><br><span class="line"><span class="quote">&gt;</span></span><br><span class="line"><span class="quote">&gt; &gt; 白起： 秦国上将军，战国时期四大战神之首。</span></span><br><span class="line"><span class="quote">&gt;</span></span><br><span class="line"><span class="quote">&gt; ## 武安君之死</span></span><br><span class="line"><span class="quote">&gt;</span></span><br><span class="line"><span class="quote">&gt; 硬候范睢建议秦昭襄王赐死辞官回乡的白起</span></span><br></pre></td></tr></table></figure><p>效果：</p><img src="/2019/03/13/%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84markdown%E8%AF%AD%E6%B3%95/%E5%BC%95%E7%94%A8.png" class="" title="引用效果"><p>对于引用可以在内部嵌套 markdown 的语法</p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">战国名士</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 苏秦</span><br><span class="line"><span class="bullet">-</span> 张仪</span><br><span class="line"><span class="bullet">-</span> 公孙衍</span><br><span class="line"><span class="bullet">-</span> 孟尝君</span><br></pre></td></tr></table></figure><p>效果：</p><img src="/2019/03/13/%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84markdown%E8%AF%AD%E6%B3%95/%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8.png" class="" title="无序列表效果"><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">战争的要素</span><br><span class="line"><span class="bullet">1.</span> 钱粮</span><br><span class="line"><span class="bullet">2.</span> 兵马</span><br><span class="line"><span class="bullet">3.</span> 将领</span><br></pre></td></tr></table></figure><p>效果：</p><img src="/2019/03/13/%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84markdown%E8%AF%AD%E6%B3%95/%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8.png" class="" title="有序列表效果"><h3 id="代办事项列表"><a href="#代办事项列表" class="headerlink" title="代办事项列表"></a>代办事项列表</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> [ ] 阅读孙皓晖教授的书籍</span><br><span class="line"><span class="bullet">-</span> [x] 观看大秦帝国之裂变</span><br></pre></td></tr></table></figure><p>效果：</p><img src="/2019/03/13/%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84markdown%E8%AF%AD%E6%B3%95/%E4%BB%A3%E5%8A%9E%E4%BA%8B%E9%A1%B9%E5%88%97%E8%A1%A8.png" class="" title="代办事项列表效果"><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">\<span class="code">`\`</span>\`c</span><br><span class="line"><span class="section">#include <span class="xml"><span class="tag">&lt;<span class="name">stdio.h</span>&gt;</span></span></span></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"><span class="code">    printf(&quot;hi~,markdowner ^-^ \n&quot;);   </span></span><br><span class="line"><span class="code">    </span></span><br><span class="line"><span class="code">    return 0;</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code">\`\`\`</span></span><br></pre></td></tr></table></figure><blockquote><p>代码块的语法以```为开头和结尾，此处由于博客展示的原因（不知道代码块的语法如何做到不转义，如果有知道的小伙伴，还请指教^_^）。</p></blockquote><p>效果：</p><img src="/2019/03/13/%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84markdown%E8%AF%AD%E6%B3%95/%E4%BB%A3%E7%A0%81%E5%9D%97.png" class="" title="代码块效果"><h2 id="内容标识"><a href="#内容标识" class="headerlink" title="内容标识"></a>内容标识</h2><p>斜体、加粗</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="emphasis">_白起的妻子是赵国人?_</span></span><br><span class="line"><span class="strong">**白起一生从无败战**</span></span><br></pre></td></tr></table></figure><p>效果：</p><img src="/2019/03/13/%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84markdown%E8%AF%AD%E6%B3%95/%E6%A0%87%E8%AF%86.png" class="" title="标识效果"><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">Dribbble</span>](<span class="link">https://dribbble.com/shots</span>)</span><br></pre></td></tr></table></figure><p>效果：</p><img src="/2019/03/13/%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84markdown%E8%AF%AD%E6%B3%95/%E9%93%BE%E6%8E%A5.png" class="" title="链接效果"><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">coding man</span>](<span class="link">https://lifeisbianry_codeingman.jpg</span>)</span><br></pre></td></tr></table></figure><p>效果：</p><img src="/2019/03/13/%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84markdown%E8%AF%AD%E6%B3%95/%E5%9B%BE%E7%89%87.png" class="" title="图片效果"><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">国家 | 财政能力 | 兵力 </span><br><span class="line">:---|:---:|---:</span><br><span class="line">秦国 | 不缺钱 | 兵多</span><br><span class="line">赵国 | 还行 | 兵多</span><br></pre></td></tr></table></figure><p>效果：</p><img src="/2019/03/13/%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84markdown%E8%AF%AD%E6%B3%95/%E8%A1%A8%E6%A0%BC.png" class="" title="表格效果"><blockquote><p>表中：第一列左对齐，第二列居中，第三列右对齐</p></blockquote><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">赵国阵营</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 廉颇</span><br><span class="line"><span class="bullet">-</span> 李牧</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">秦军阵营</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 蒙骜</span><br><span class="line"><span class="bullet">-</span> 白起</span><br></pre></td></tr></table></figure><p>效果：</p><img src="/2019/03/13/%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84markdown%E8%AF%AD%E6%B3%95/%E5%88%86%E5%89%B2%E7%BA%BF.png" class="" title="分割效果"><h2 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~~秦军与赵军在长平进行了一场大对决~~</span><br></pre></td></tr></table></figure><p>效果：</p><img src="/2019/03/13/%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84markdown%E8%AF%AD%E6%B3%95/%E5%88%A0%E9%99%A4%E7%BA%BF.png" class="" title="删除线效果"><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>在要展示目录的文章头部输入<code>[TOC]</code><br>效果：</p><img src="/2019/03/13/%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84markdown%E8%AF%AD%E6%B3%95/%E7%9B%AE%E5%BD%95.png" class="" title="目录效果"><h2 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">白起[^1]是战神，他曾经和赵括在长平进行战争[^2]</span><br><span class="line"></span><br><span class="line">[<span class="symbol">^1</span>]:<span class="link">秦国上将军</span></span><br><span class="line">[<span class="symbol">^2</span>]:<span class="link">杀人的机器</span></span><br></pre></td></tr></table></figure><p>效果：</p><img src="/2019/03/13/%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84markdown%E8%AF%AD%E6%B3%95/%E8%84%9A%E6%B3%A8.png" class="" title="脚注效果">]]></content>
      
      
      <categories>
          
          <category> 展现形式 </category>
          
          <category> markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdwon </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
